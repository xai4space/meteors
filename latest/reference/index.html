
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../tutorials/lime/">
      
      
        <link rel="next" href="../changelog/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.36">
    
    
      
        <title>üìñ API Reference - Meteors</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.06209087.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#api-reference" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <div data-md-color-scheme="default" data-md-component="outdated" hidden>
        
      </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Meteors" class="md-header__button md-logo" aria-label="Meteors" data-md-component="logo">
      
  <img src="../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Meteors
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              üìñ API Reference
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Meteors" class="md-nav__button md-logo" aria-label="Meteors" data-md-component="logo">
      
  <img src="../assets/logo.png" alt="logo">

    </a>
    Meteors
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    üè† Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../quickstart/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    üöÄ Quickstart
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    üìö Tutorials
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            üìö Tutorials
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/introduction/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    üéì Introduction
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/lime/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    LIME
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    üìñ API Reference
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    üìñ API Reference
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#hyperspectral-image" class="md-nav__link">
    <span class="md-ellipsis">
      HyperSpectral Image
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HyperSpectral Image">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI" class="md-nav__link">
    <span class="md-ellipsis">
      HSI
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSI">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.spatial_binary_mask" class="md-nav__link">
    <span class="md-ellipsis">
      spatial_binary_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.spectral_axis" class="md-nav__link">
    <span class="md-ellipsis">
      spectral_axis
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.change_orientation" class="md-nav__link">
    <span class="md-ellipsis">
      change_orientation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.extract_band_by_name" class="md-nav__link">
    <span class="md-ellipsis">
      extract_band_by_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.get_image" class="md-nav__link">
    <span class="md-ellipsis">
      get_image
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.get_rgb_image" class="md-nav__link">
    <span class="md-ellipsis">
      get_rgb_image
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.to" class="md-nav__link">
    <span class="md-ellipsis">
      to
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#visualizations" class="md-nav__link">
    <span class="md-ellipsis">
      Visualizations
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Visualizations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.hsi_visualize" class="md-nav__link">
    <span class="md-ellipsis">
      hsi_visualize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.hsi_visualize.visualize_hsi" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_hsi
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize" class="md-nav__link">
    <span class="md-ellipsis">
      attr_visualize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize.visualize_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.lime_visualize.visualize_spectral_attributes_by_waveband" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_spectral_attributes_by_waveband
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.lime_visualize.visualize_spectral_attributes_by_magnitude" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_spectral_attributes_by_magnitude
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.lime_visualize.visualize_spectral_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_spectral_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.lime_visualize.visualize_spatial_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_spatial_attributes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#attribution-methods" class="md-nav__link">
    <span class="md-ellipsis">
      Attribution Methods
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Attribution Methods">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributes" class="md-nav__link">
    <span class="md-ellipsis">
      HSIAttributes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSIAttributes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributes.flattened_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      flattened_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributes.orientation" class="md-nav__link">
    <span class="md-ellipsis">
      orientation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributes.change_orientation" class="md-nav__link">
    <span class="md-ellipsis">
      change_orientation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributes.to" class="md-nav__link">
    <span class="md-ellipsis">
      to
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSISpatialAttributes" class="md-nav__link">
    <span class="md-ellipsis">
      HSISpatialAttributes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSISpatialAttributes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSISpatialAttributes.flattened_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      flattened_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSISpatialAttributes.segmentation_mask" class="md-nav__link">
    <span class="md-ellipsis">
      segmentation_mask
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSISpectralAttributes" class="md-nav__link">
    <span class="md-ellipsis">
      HSISpectralAttributes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSISpectralAttributes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSISpectralAttributes.band_mask" class="md-nav__link">
    <span class="md-ellipsis">
      band_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSISpectralAttributes.flattened_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      flattened_attributes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime" class="md-nav__link">
    <span class="md-ellipsis">
      Lime
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Lime">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime.attribute" class="md-nav__link">
    <span class="md-ellipsis">
      attribute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime.get_band_mask" class="md-nav__link">
    <span class="md-ellipsis">
      get_band_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime.get_segmentation_mask" class="md-nav__link">
    <span class="md-ellipsis">
      get_segmentation_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime.get_spatial_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      get_spatial_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime.get_spectral_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      get_spectral_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lime-base" class="md-nav__link">
    <span class="md-ellipsis">
      Lime Base
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.integrated_gradients.IntegratedGradients" class="md-nav__link">
    <span class="md-ellipsis">
      IntegratedGradients
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.input_x_gradients.InputXGradient" class="md-nav__link">
    <span class="md-ellipsis">
      InputXGradient
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.occlusion.Occlusion" class="md-nav__link">
    <span class="md-ellipsis">
      Occlusion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.saliency.Saliency" class="md-nav__link">
    <span class="md-ellipsis">
      Saliency
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.noise_tunnel.NoiseTunnel" class="md-nav__link">
    <span class="md-ellipsis">
      NoiseTunnel
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hyper-noise-tunnel" class="md-nav__link">
    <span class="md-ellipsis">
      Hyper Noise Tunnel
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Hyper Noise Tunnel">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.hyper_noise_tunnel.HyperNoiseTunnel" class="md-nav__link">
    <span class="md-ellipsis">
      HyperNoiseTunnel
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.hyper_noise_tunnel.BaseHyperNoiseTunnel" class="md-nav__link">
    <span class="md-ellipsis">
      BaseHyperNoiseTunnel
    </span>
  </a>
  
    <nav class="md-nav" aria-label="BaseHyperNoiseTunnel">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.hyper_noise_tunnel.BaseHyperNoiseTunnel.perturb_input" class="md-nav__link">
    <span class="md-ellipsis">
      perturb_input
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../changelog/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    üìù Changelog
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../how-to-guides/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ü§ù How to Contribute
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#hyperspectral-image" class="md-nav__link">
    <span class="md-ellipsis">
      HyperSpectral Image
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HyperSpectral Image">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI" class="md-nav__link">
    <span class="md-ellipsis">
      HSI
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSI">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.spatial_binary_mask" class="md-nav__link">
    <span class="md-ellipsis">
      spatial_binary_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.spectral_axis" class="md-nav__link">
    <span class="md-ellipsis">
      spectral_axis
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.change_orientation" class="md-nav__link">
    <span class="md-ellipsis">
      change_orientation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.extract_band_by_name" class="md-nav__link">
    <span class="md-ellipsis">
      extract_band_by_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.get_image" class="md-nav__link">
    <span class="md-ellipsis">
      get_image
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.get_rgb_image" class="md-nav__link">
    <span class="md-ellipsis">
      get_rgb_image
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.to" class="md-nav__link">
    <span class="md-ellipsis">
      to
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#visualizations" class="md-nav__link">
    <span class="md-ellipsis">
      Visualizations
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Visualizations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.hsi_visualize" class="md-nav__link">
    <span class="md-ellipsis">
      hsi_visualize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.hsi_visualize.visualize_hsi" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_hsi
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize" class="md-nav__link">
    <span class="md-ellipsis">
      attr_visualize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize.visualize_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.lime_visualize.visualize_spectral_attributes_by_waveband" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_spectral_attributes_by_waveband
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.lime_visualize.visualize_spectral_attributes_by_magnitude" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_spectral_attributes_by_magnitude
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.lime_visualize.visualize_spectral_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_spectral_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.lime_visualize.visualize_spatial_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_spatial_attributes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#attribution-methods" class="md-nav__link">
    <span class="md-ellipsis">
      Attribution Methods
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Attribution Methods">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributes" class="md-nav__link">
    <span class="md-ellipsis">
      HSIAttributes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSIAttributes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributes.flattened_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      flattened_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributes.orientation" class="md-nav__link">
    <span class="md-ellipsis">
      orientation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributes.change_orientation" class="md-nav__link">
    <span class="md-ellipsis">
      change_orientation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributes.to" class="md-nav__link">
    <span class="md-ellipsis">
      to
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSISpatialAttributes" class="md-nav__link">
    <span class="md-ellipsis">
      HSISpatialAttributes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSISpatialAttributes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSISpatialAttributes.flattened_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      flattened_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSISpatialAttributes.segmentation_mask" class="md-nav__link">
    <span class="md-ellipsis">
      segmentation_mask
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSISpectralAttributes" class="md-nav__link">
    <span class="md-ellipsis">
      HSISpectralAttributes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSISpectralAttributes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSISpectralAttributes.band_mask" class="md-nav__link">
    <span class="md-ellipsis">
      band_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSISpectralAttributes.flattened_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      flattened_attributes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime" class="md-nav__link">
    <span class="md-ellipsis">
      Lime
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Lime">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime.attribute" class="md-nav__link">
    <span class="md-ellipsis">
      attribute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime.get_band_mask" class="md-nav__link">
    <span class="md-ellipsis">
      get_band_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime.get_segmentation_mask" class="md-nav__link">
    <span class="md-ellipsis">
      get_segmentation_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime.get_spatial_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      get_spatial_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime.get_spectral_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      get_spectral_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lime-base" class="md-nav__link">
    <span class="md-ellipsis">
      Lime Base
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.integrated_gradients.IntegratedGradients" class="md-nav__link">
    <span class="md-ellipsis">
      IntegratedGradients
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.input_x_gradients.InputXGradient" class="md-nav__link">
    <span class="md-ellipsis">
      InputXGradient
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.occlusion.Occlusion" class="md-nav__link">
    <span class="md-ellipsis">
      Occlusion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.saliency.Saliency" class="md-nav__link">
    <span class="md-ellipsis">
      Saliency
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.noise_tunnel.NoiseTunnel" class="md-nav__link">
    <span class="md-ellipsis">
      NoiseTunnel
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hyper-noise-tunnel" class="md-nav__link">
    <span class="md-ellipsis">
      Hyper Noise Tunnel
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Hyper Noise Tunnel">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.hyper_noise_tunnel.HyperNoiseTunnel" class="md-nav__link">
    <span class="md-ellipsis">
      HyperNoiseTunnel
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.hyper_noise_tunnel.BaseHyperNoiseTunnel" class="md-nav__link">
    <span class="md-ellipsis">
      BaseHyperNoiseTunnel
    </span>
  </a>
  
    <nav class="md-nav" aria-label="BaseHyperNoiseTunnel">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.hyper_noise_tunnel.BaseHyperNoiseTunnel.perturb_input" class="md-nav__link">
    <span class="md-ellipsis">
      perturb_input
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="api-reference">API Reference</h1>
<p>The architecture of the package can be seen on the UML diagram:
<img alt="UML diagram of package structure" src="../assets/UML-attribution-methods.png" /></p>
<h2 id="hyperspectral-image">HyperSpectral Image</h2>


<div class="doc doc-object doc-class">



<h3 id="src.meteors.hsi.HSI" class="doc doc-heading">
            <code>HSI</code>


</h3>


    <div class="doc doc-contents first">


        <p>A dataclass for hyperspectral image data, including the image, wavelengths, and binary mask.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.hsi.HSI.image">image</span></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The hyperspectral image data as a PyTorch tensor.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.hsi.HSI.wavelengths">wavelengths</span></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The wavelengths present in the image.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.hsi.HSI.orientation">orientation</span></code></td>
            <td>
                  <code>tuple[str, str, str]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The orientation of the image data.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.hsi.HSI.device">device</span></code></td>
            <td>
                  <code><span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The device to be used for inference.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.hsi.HSI.binary_mask">binary_mask</span></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A binary mask used to cover unimportant parts of the image.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

              <details class="quote">
                <summary>Source code in <code>src/meteors/hsi.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">HSI</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A dataclass for hyperspectral image data, including the image, wavelengths, and binary mask.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        image (torch.Tensor): The hyperspectral image data as a PyTorch tensor.</span>
<span class="sd">        wavelengths (torch.Tensor): The wavelengths present in the image.</span>
<span class="sd">        orientation (tuple[str, str, str]): The orientation of the image data.</span>
<span class="sd">        device (torch.device): The device to be used for inference.</span>
<span class="sd">        binary_mask (torch.Tensor): A binary mask used to cover unimportant parts of the image.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">image</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>  <span class="c1"># Should always be a first field</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">PlainValidator</span><span class="p">(</span><span class="n">ensure_image_tensor</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;Hyperspectral image. Converted to torch tensor.&quot;</span><span class="p">),</span>
    <span class="p">]</span>
    <span class="n">wavelengths</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">PlainValidator</span><span class="p">(</span><span class="n">ensure_wavelengths_tensor</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;Wavelengths present in the image. Defaults to None.&quot;</span><span class="p">),</span>
    <span class="p">]</span>
    <span class="n">orientation</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
        <span class="n">PlainValidator</span><span class="p">(</span><span class="n">validate_orientation</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">description</span><span class="o">=</span><span class="p">(</span>
                <span class="s1">&#39;Orientation of the image - sequence of three one-letter strings in any order: &quot;C&quot;, &quot;H&quot;, &quot;W&quot; &#39;</span>
                <span class="s1">&#39;meaning respectively channels, height and width of the image. Defaults to (&quot;C&quot;, &quot;H&quot;, &quot;W&quot;).&#39;</span>
            <span class="p">),</span>
        <span class="p">),</span>
    <span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">)</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
        <span class="n">PlainValidator</span><span class="p">(</span><span class="n">resolve_inference_device_hsi</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">validate_default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Device to be used for inference. If None, the device of the input image will be used. Defaults to None.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">binary_mask</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">PlainValidator</span><span class="p">(</span><span class="n">process_and_validate_binary_mask</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">validate_default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Binary mask used to cover not important parts of the base image, masked parts have values equals to 0. &quot;</span>
                <span class="s2">&quot;Converted to torch tensor. Defaults to None.&quot;</span>
            <span class="p">),</span>
        <span class="p">),</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spectral_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the index of the spectral (wavelength) axis based on the current data orientation.</span>

<span class="sd">        In hyperspectral imaging, the spectral axis represents the dimension along which</span>
<span class="sd">        different spectral bands or wavelengths are arranged. This property dynamically</span>
<span class="sd">        determines the index of this axis based on the current orientation of the data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The index of the spectral axis in the current data structure.</span>
<span class="sd">                - 0 for &#39;CHW&#39; or &#39;CWH&#39; orientations (Channel/Wavelength first)</span>
<span class="sd">                - 2 for &#39;HWC&#39; or &#39;WHC&#39; orientations (Channel/Wavelength last)</span>
<span class="sd">                - 1 for &#39;HCW&#39; or &#39;WCH&#39; orientations (Channel/Wavelength in the middle)</span>

<span class="sd">        Note:</span>
<span class="sd">            The orientation is typically represented as a string where:</span>
<span class="sd">            - &#39;C&#39; represents the spectral/wavelength dimension</span>
<span class="sd">            - &#39;H&#39; represents the height (rows) of the image</span>
<span class="sd">            - &#39;W&#39; represents the width (columns) of the image</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI()</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.orientation = &quot;CHW&quot;</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.spectral_axis</span>
<span class="sd">            0</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.orientation = &quot;HWC&quot;</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.spectral_axis</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">get_channel_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spatial_binary_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a 2D spatial representation of the binary mask.</span>

<span class="sd">        This property extracts a single 2D slice from the 3D binary mask, assuming that</span>
<span class="sd">        the mask is identical across all spectral bands. It handles different data</span>
<span class="sd">        orientations by first ensuring the spectral dimension is the last dimension</span>
<span class="sd">        before extracting the 2D spatial mask.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A 2D tensor representing the spatial binary mask.</span>
<span class="sd">                The shape will be (H, W) where H is height and W is width of the image.</span>

<span class="sd">        Note:</span>
<span class="sd">            - This assumes that the binary mask is consistent across all spectral bands.</span>
<span class="sd">            - The returned mask is always 2D, regardless of the original data orientation.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; # If self.binary_mask has shape (100, 100, 5) with spectral_axis=2:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(binary_mask=torch.rand(100, 100, 5), orientation=(&quot;H&quot;, &quot;W&quot;, &quot;C&quot;))</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.spatial_binary_mask.shape</span>
<span class="sd">            torch.Size([100, 100])</span>
<span class="sd">            &gt;&gt;&gt; If self.binary_mask has shape (5, 100, 100) with spectral_axis=0:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(binary_mask=torch.rand(5, 100, 100), orientation=(&quot;C&quot;, &quot;H&quot;, &quot;W&quot;))</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.spatial_binary_mask.shape</span>
<span class="sd">            torch.Size([100, 100])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mask</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">model_config</span> <span class="o">=</span> <span class="n">ConfigDict</span><span class="p">(</span><span class="n">arbitrary_types_allowed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@model_validator</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;after&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">validate_image_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validates the image data by checking the shape of the wavelengths, image, and spectral_axis.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: The instance of the class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validate_shapes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Moves the image and binary mask (if available) to the specified device.</span>

<span class="sd">        Args:</span>
<span class="sd">            device (str or torch.device): The device to move the image and binary mask to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: The updated HSI object.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; # Create an HSI object</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(10, 10, 10), wavelengths=np.arange(10))</span>
<span class="sd">            &gt;&gt;&gt; # Move the image to cpu</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = hsi_image.to(&quot;cpu&quot;)</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.device</span>
<span class="sd">            device(type=&#39;cpu&#39;)</span>
<span class="sd">            &gt;&gt;&gt; # Move the image to cuda</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = hsi_image.to(&quot;cuda&quot;)</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.device</span>
<span class="sd">            device(type=&#39;cuda&#39;, index=0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">device</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">get_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the hyperspectral image data with optional masking applied.</span>

<span class="sd">        Args:</span>
<span class="sd">            apply_mask (bool, optional): Whether to apply the binary mask to the image.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The hyperspectral image data.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - If apply_mask is True, the binary mask will be applied to the image based on the `binary_mask` attribute.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(10, 100, 100), wavelengths=np.linspace(400, 1000, 10))</span>
<span class="sd">            &gt;&gt;&gt; image = hsi_image.get_image()</span>
<span class="sd">            &gt;&gt;&gt; image.shape</span>
<span class="sd">            torch.Size([10, 100, 100])</span>
<span class="sd">            &gt;&gt;&gt; image = hsi_image.get_image(apply_mask=False)</span>
<span class="sd">            &gt;&gt;&gt; image.shape</span>
<span class="sd">            torch.Size([10, 100, 100])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">apply_mask</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>

    <span class="k">def</span> <span class="nf">get_rgb_image</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">output_channel_axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts an RGB representation from the hyperspectral image data.</span>

<span class="sd">        This method creates a 3-channel RGB image by selecting appropriate bands</span>
<span class="sd">        corresponding to red, green, and blue wavelengths from the hyperspectral data.</span>

<span class="sd">        Args:</span>
<span class="sd">            apply_mask (bool, optional): Whether to apply the binary mask to the image.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            apply_min_cutoff (bool, optional): Whether to apply a minimum intensity</span>
<span class="sd">                cutoff to the image. Defaults to False.</span>
<span class="sd">            output_channel_axis (int | None, optional): The axis where the RGB channels</span>
<span class="sd">                should be placed in the output tensor. If None, uses the current spectral</span>
<span class="sd">                axis of the hyperspectral data. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The RGB representation of the hyperspectral image.</span>
<span class="sd">                Shape will be either (H, W, 3), (3, H, W), or (H, 3, W) depending on</span>
<span class="sd">                the specified output_channel_axis, where H is height and W is width.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - The RGB bands are extracted using predefined wavelength ranges for R, G, and B.</span>
<span class="sd">            - Each band is normalized independently before combining into the RGB image.</span>
<span class="sd">            - If apply_mask is True, masked areas will be set to zero in the output.</span>
<span class="sd">            - If apply_min_cutoff is True, a minimum intensity threshold is applied to each band.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(10, 100, 100), wavelengths=np.linspace(400, 1000, 10))</span>
<span class="sd">            &gt;&gt;&gt; rgb_image = hsi_image.get_rgb_image()</span>
<span class="sd">            &gt;&gt;&gt; rgb_image.shape</span>
<span class="sd">            torch.Size([100, 100, 3])</span>

<span class="sd">            &gt;&gt;&gt; rgb_image = hsi_image.get_rgb_image(output_channel_axis=0)</span>
<span class="sd">            &gt;&gt;&gt; rgb_image.shape</span>
<span class="sd">            torch.Size([3, 100, 100])</span>

<span class="sd">            &gt;&gt;&gt; rgb_image = hsi_image.get_rgb_image(apply_mask=False, apply_min_cutoff=True)</span>
<span class="sd">            &gt;&gt;&gt; rgb_image.shape</span>
<span class="sd">            torch.Size([100, 100, 3])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">output_channel_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_channel_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span>

        <span class="n">rgb_img</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">extract_band_by_name</span><span class="p">(</span>
                    <span class="n">band</span><span class="p">,</span> <span class="n">apply_mask</span><span class="o">=</span><span class="n">apply_mask</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="n">apply_min_cutoff</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">rgb_img</span>
            <span class="k">if</span> <span class="n">output_channel_axis</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span>
            <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">rgb_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">output_channel_axis</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_extract_central_slice_from_band</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">band_wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">apply_min_cutoff</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts and processes the central wavelength band from a given range in the hyperspectral image.</span>

<span class="sd">        This method selects the central band from a specified range of wavelengths,</span>
<span class="sd">        applies optional processing steps (masking, normalization, and minimum cutoff),</span>
<span class="sd">        and returns the resulting 2D image slice.</span>

<span class="sd">        Args:</span>
<span class="sd">            band_wavelengths (torch.Tensor): The selected wavelengths that define the whole band</span>
<span class="sd">                from which the central slice will be extracted.</span>
<span class="sd">                All of the passed wavelengths must be present in the image.</span>
<span class="sd">            apply_mask (bool, optional): Whether to apply the binary mask to the extracted band.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            apply_min_cutoff (bool, optional): Whether to apply a minimum intensity cutoff.</span>
<span class="sd">                If True, sets the minimum non-zero value to zero after normalization.</span>
<span class="sd">                Defaults to False.</span>
<span class="sd">            normalize (bool, optional): Whether to normalize the band values to [0, 1] range.</span>
<span class="sd">                Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A 2D tensor representing the processed central wavelength band.</span>
<span class="sd">                Shape will be (H, W), where H is height and W is width of the image.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - The central wavelength is determined as the middle index of the provided wavelengths list.</span>
<span class="sd">            - If normalization is applied, it&#39;s done before masking and cutoff operations.</span>
<span class="sd">            - The binary mask, if applied, is expected to have the same spatial dimensions as the image.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(13, 100, 100), wavelengths=np.linspace(400, 1000, 13))</span>
<span class="sd">            &gt;&gt;&gt; band_wavelengths = torch.tensor([500, 600, 650, 700])</span>
<span class="sd">            &gt;&gt;&gt; central_slice = hsi_image._extract_central_slice_from_band(band_wavelengths)</span>
<span class="sd">            &gt;&gt;&gt; central_slice.shape</span>
<span class="sd">            torch.Size([100, 100])</span>

<span class="sd">            &gt;&gt;&gt; # Extract a slice without normalization or masking</span>
<span class="sd">            &gt;&gt;&gt; raw_band = hsi_image._extract_central_slice_from_band(band_wavelengths, apply_mask=False, normalize=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if all wavelengths from the `band_wavelengths` are present in the image</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">wave</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span> <span class="k">for</span> <span class="n">wave</span> <span class="ow">in</span> <span class="n">band_wavelengths</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All of the passed wavelengths must be present in the image&quot;</span><span class="p">)</span>

        <span class="c1"># sort the `band_wavelengths` to ensure the central band is selected</span>
        <span class="n">band_wavelengths</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">band_wavelengths</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

        <span class="n">start_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span> <span class="o">==</span> <span class="n">band_wavelengths</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">relative_center_band_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_wavelengths</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">central_band_index</span> <span class="o">=</span> <span class="n">start_index</span> <span class="o">+</span> <span class="n">relative_center_band_index</span>

        <span class="c1"># Ensure the spectral dimension is the last</span>
        <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="nb">slice</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">central_band_index</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">apply_min_cutoff</span><span class="p">:</span>
                <span class="n">slice_min</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">[</span><span class="nb">slice</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">slice_min</span> <span class="o">=</span> <span class="nb">slice</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

            <span class="n">slice_max</span> <span class="o">=</span> <span class="nb">slice</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">slice_max</span> <span class="o">&gt;</span> <span class="n">slice_min</span><span class="p">:</span>  <span class="c1"># Avoid division by zero</span>
                <span class="nb">slice</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span> <span class="o">-</span> <span class="n">slice_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">slice_max</span> <span class="o">-</span> <span class="n">slice_min</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">apply_min_cutoff</span><span class="p">:</span>
                <span class="nb">slice</span><span class="p">[</span><span class="nb">slice</span> <span class="o">==</span> <span class="nb">slice</span><span class="o">.</span><span class="n">min</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Set minimum values to zero</span>

        <span class="k">if</span> <span class="n">apply_mask</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="nb">slice</span> <span class="o">=</span> <span class="nb">slice</span> <span class="o">*</span> <span class="n">mask</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">central_band_index</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">slice</span>

    <span class="k">def</span> <span class="nf">extract_band_by_name</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">band_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">selection_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;center&quot;</span><span class="p">,</span>
        <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">apply_min_cutoff</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts a single spectral band from the hyperspectral image based on a standardized band name.</span>

<span class="sd">        This method uses the spyndex library to map standardized band names to wavelength ranges,</span>
<span class="sd">        then extracts the corresponding band from the hyperspectral data.</span>

<span class="sd">        Args:</span>
<span class="sd">            band_name (str): The standardized name of the band to extract (e.g., &quot;Red&quot;, &quot;NIR&quot;, &quot;SWIR1&quot;).</span>
<span class="sd">            selection_method (str, optional): The method to use for selecting the band within the wavelength range.</span>
<span class="sd">                Currently, only &quot;center&quot; is supported, which selects the central wavelength.</span>
<span class="sd">                Defaults to &quot;center&quot;.</span>
<span class="sd">            apply_mask (bool, optional): Whether to apply the binary mask to the extracted band.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            apply_min_cutoff (bool, optional): Whether to apply a minimum intensity cutoff after normalization.</span>
<span class="sd">                If True, sets the minimum non-zero value to zero. Defaults to False.</span>
<span class="sd">            normalize (bool, optional): Whether to normalize the band values to the [0, 1] range.</span>
<span class="sd">                Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A 2D tensor representing the extracted and processed spectral band.</span>
<span class="sd">                Shape will be (H, W), where H is height and W is width of the image.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the specified band name is not found in the spyndex library.</span>
<span class="sd">            NotImplementedError: If a selection method other than &quot;center&quot; is specified.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - The spyndex library is used to map band names to wavelength ranges.</span>
<span class="sd">            - Currently, only the &quot;center&quot; selection method is implemented, which chooses</span>
<span class="sd">            the central wavelength within the specified range.</span>
<span class="sd">            - Processing steps are applied in the order: normalization, cutoff, masking.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(200, 100, 100), wavelengths=np.linspace(400, 2500, 200))</span>
<span class="sd">            &gt;&gt;&gt; red_band = hsi_image.extract_band_by_name(&quot;Red&quot;)</span>
<span class="sd">            &gt;&gt;&gt; red_band.shape</span>
<span class="sd">            torch.Size([100, 100])</span>

<span class="sd">            &gt;&gt;&gt; # Extract NIR band without normalization or masking</span>
<span class="sd">            &gt;&gt;&gt; nir_band = hsi_image.extract_band_by_name(&quot;NIR&quot;, apply_mask=False, normalize=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">band_info</span> <span class="o">=</span> <span class="n">spyndex</span><span class="o">.</span><span class="n">bands</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">band_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">band_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Band name &#39;</span><span class="si">{</span><span class="n">band_name</span><span class="si">}</span><span class="s2">&#39; not found in the spyndex library&quot;</span><span class="p">)</span>

        <span class="n">min_wave</span><span class="p">,</span> <span class="n">max_wave</span> <span class="o">=</span> <span class="n">band_info</span><span class="o">.</span><span class="n">min_wavelength</span><span class="p">,</span> <span class="n">band_info</span><span class="o">.</span><span class="n">max_wavelength</span>
        <span class="n">selected_wavelengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span> <span class="o">&gt;=</span> <span class="n">min_wave</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span> <span class="o">&lt;=</span> <span class="n">max_wave</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">selection_method</span> <span class="o">==</span> <span class="s2">&quot;center&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_central_slice_from_band</span><span class="p">(</span>
                <span class="n">selected_wavelengths</span><span class="p">,</span> <span class="n">apply_mask</span><span class="o">=</span><span class="n">apply_mask</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="n">apply_min_cutoff</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Selection method &#39;</span><span class="si">{</span><span class="n">selection_method</span><span class="si">}</span><span class="s2">&#39; is not supported. Only &#39;center&#39; is currently available.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">change_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_orientation</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Changes the orientation of the hsi data to the target orientation.</span>

<span class="sd">        Args:</span>
<span class="sd">            target_orientation (tuple[str, str, str], list[str], str): The target orientation for the hsi data.</span>
<span class="sd">                This should be a tuple of three one-letter strings in any order: &quot;C&quot;, &quot;H&quot;, &quot;W&quot;.</span>
<span class="sd">            inplace (bool, optional): Whether to modify the hsi data in place or return a new object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: The updated HSI object with the new orientation.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the target orientation is not a valid tuple of three one-letter strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target_orientation</span> <span class="o">=</span> <span class="n">validate_orientation</span><span class="p">(</span><span class="n">target_orientation</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">hsi</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hsi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">target_orientation</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hsi</span>

        <span class="n">permute_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">target_orientation</span><span class="p">]</span>

        <span class="c1"># permute the image</span>
        <span class="n">hsi</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">permute_dims</span><span class="p">)</span>

        <span class="c1"># permute the binary mask</span>
        <span class="k">if</span> <span class="n">hsi</span><span class="o">.</span><span class="n">binary_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hsi</span><span class="o">.</span><span class="n">binary_mask</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">binary_mask</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">permute_dims</span><span class="p">)</span>

        <span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">target_orientation</span>

        <span class="k">return</span> <span class="n">hsi</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h4 id="src.meteors.hsi.HSI.spatial_binary_mask" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">spatial_binary_mask</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Returns a 2D spatial representation of the binary mask.</p>
<p>This property extracts a single 2D slice from the 3D binary mask, assuming that
the mask is identical across all spectral bands. It handles different data
orientations by first ensuring the spectral dimension is the last dimension
before extracting the 2D spatial mask.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: A 2D tensor representing the spatial binary mask.
The shape will be (H, W) where H is height and W is width of the image.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="note" open>
  <summary>Note</summary>
  <ul>
<li>This assumes that the binary mask is consistent across all spectral bands.</li>
<li>The returned mask is always 2D, regardless of the original data orientation.</li>
</ul>
</details>

<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># If self.binary_mask has shape (100, 100, 5) with spectral_axis=2:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">binary_mask</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">orientation</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">spatial_binary_mask</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([100, 100])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">If</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="n">has</span> <span class="n">shape</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="k">with</span> <span class="n">spectral_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">binary_mask</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">orientation</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">spatial_binary_mask</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([100, 100])</span>
</code></pre></div>
    </div>

</div>

<div class="doc doc-object doc-attribute">



<h4 id="src.meteors.hsi.HSI.spectral_axis" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">spectral_axis</span><span class="p">:</span> <span class="nb">int</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Returns the index of the spectral (wavelength) axis based on the current data orientation.</p>
<p>In hyperspectral imaging, the spectral axis represents the dimension along which
different spectral bands or wavelengths are arranged. This property dynamically
determines the index of this axis based on the current orientation of the data.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>int</code></td>            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The index of the spectral axis in the current data structure.
- 0 for 'CHW' or 'CWH' orientations (Channel/Wavelength first)
- 2 for 'HWC' or 'WHC' orientations (Channel/Wavelength last)
- 1 for 'HCW' or 'WCH' orientations (Channel/Wavelength in the middle)</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="note" open>
  <summary>Note</summary>
  <p>The orientation is typically represented as a string where:
- 'C' represents the spectral/wavelength dimension
- 'H' represents the height (rows) of the image
- 'W' represents the width (columns) of the image</p>
</details>

<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="s2">&quot;CHW&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">spectral_axis</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="s2">&quot;HWC&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">spectral_axis</span>
<span class="go">2</span>
</code></pre></div>
    </div>

</div>



<div class="doc doc-object doc-function">


<h4 id="src.meteors.hsi.HSI.change_orientation" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">change_orientation</span><span class="p">(</span><span class="n">target_orientation</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Changes the orientation of the hsi data to the target orientation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>target_orientation</code></td>
            <td>
                  <code>(tuple[str, str, str], list[str], str)</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The target orientation for the hsi data.
This should be a tuple of three one-letter strings in any order: "C", "H", "W".</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>inplace</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to modify the hsi data in place or return a new object.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Self</code></td>            <td>
                  <code><span title="typing_extensions.Self">Self</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The updated HSI object with the new orientation.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the target orientation is not a valid tuple of three one-letter strings.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">change_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_orientation</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Changes the orientation of the hsi data to the target orientation.</span>

<span class="sd">    Args:</span>
<span class="sd">        target_orientation (tuple[str, str, str], list[str], str): The target orientation for the hsi data.</span>
<span class="sd">            This should be a tuple of three one-letter strings in any order: &quot;C&quot;, &quot;H&quot;, &quot;W&quot;.</span>
<span class="sd">        inplace (bool, optional): Whether to modify the hsi data in place or return a new object.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Self: The updated HSI object with the new orientation.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the target orientation is not a valid tuple of three one-letter strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">target_orientation</span> <span class="o">=</span> <span class="n">validate_orientation</span><span class="p">(</span><span class="n">target_orientation</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">target_orientation</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hsi</span>

    <span class="n">permute_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">target_orientation</span><span class="p">]</span>

    <span class="c1"># permute the image</span>
    <span class="n">hsi</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">permute_dims</span><span class="p">)</span>

    <span class="c1"># permute the binary mask</span>
    <span class="k">if</span> <span class="n">hsi</span><span class="o">.</span><span class="n">binary_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hsi</span><span class="o">.</span><span class="n">binary_mask</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">binary_mask</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">permute_dims</span><span class="p">)</span>

    <span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">target_orientation</span>

    <span class="k">return</span> <span class="n">hsi</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.hsi.HSI.extract_band_by_name" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">extract_band_by_name</span><span class="p">(</span><span class="n">band_name</span><span class="p">,</span> <span class="n">selection_method</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">apply_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Extracts a single spectral band from the hyperspectral image based on a standardized band name.</p>
<p>This method uses the spyndex library to map standardized band names to wavelength ranges,
then extracts the corresponding band from the hyperspectral data.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>band_name</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The standardized name of the band to extract (e.g., "Red", "NIR", "SWIR1").</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>selection_method</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The method to use for selecting the band within the wavelength range.
Currently, only "center" is supported, which selects the central wavelength.
Defaults to "center".</p>
              </div>
            </td>
            <td>
                  <code>&#39;center&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>apply_mask</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to apply the binary mask to the extracted band.
Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>apply_min_cutoff</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to apply a minimum intensity cutoff after normalization.
If True, sets the minimum non-zero value to zero. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>normalize</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to normalize the band values to the [0, 1] range.
Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: A 2D tensor representing the extracted and processed spectral band.
Shape will be (H, W), where H is height and W is width of the image.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the specified band name is not found in the spyndex library.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>NotImplementedError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If a selection method other than "center" is specified.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The spyndex library is used to map band names to wavelength ranges.</li>
<li>Currently, only the "center" selection method is implemented, which chooses
the central wavelength within the specified range.</li>
<li>Processing steps are applied in the order: normalization, cutoff, masking.</li>
</ul>
</details>

<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">2500</span><span class="p">,</span> <span class="mi">200</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">red_band</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">extract_band_by_name</span><span class="p">(</span><span class="s2">&quot;Red&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">red_band</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([100, 100])</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Extract NIR band without normalization or masking</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nir_band</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">extract_band_by_name</span><span class="p">(</span><span class="s2">&quot;NIR&quot;</span><span class="p">,</span> <span class="n">apply_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">extract_band_by_name</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">band_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">selection_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;center&quot;</span><span class="p">,</span>
    <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">apply_min_cutoff</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extracts a single spectral band from the hyperspectral image based on a standardized band name.</span>

<span class="sd">    This method uses the spyndex library to map standardized band names to wavelength ranges,</span>
<span class="sd">    then extracts the corresponding band from the hyperspectral data.</span>

<span class="sd">    Args:</span>
<span class="sd">        band_name (str): The standardized name of the band to extract (e.g., &quot;Red&quot;, &quot;NIR&quot;, &quot;SWIR1&quot;).</span>
<span class="sd">        selection_method (str, optional): The method to use for selecting the band within the wavelength range.</span>
<span class="sd">            Currently, only &quot;center&quot; is supported, which selects the central wavelength.</span>
<span class="sd">            Defaults to &quot;center&quot;.</span>
<span class="sd">        apply_mask (bool, optional): Whether to apply the binary mask to the extracted band.</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">        apply_min_cutoff (bool, optional): Whether to apply a minimum intensity cutoff after normalization.</span>
<span class="sd">            If True, sets the minimum non-zero value to zero. Defaults to False.</span>
<span class="sd">        normalize (bool, optional): Whether to normalize the band values to the [0, 1] range.</span>
<span class="sd">            Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: A 2D tensor representing the extracted and processed spectral band.</span>
<span class="sd">            Shape will be (H, W), where H is height and W is width of the image.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the specified band name is not found in the spyndex library.</span>
<span class="sd">        NotImplementedError: If a selection method other than &quot;center&quot; is specified.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The spyndex library is used to map band names to wavelength ranges.</span>
<span class="sd">        - Currently, only the &quot;center&quot; selection method is implemented, which chooses</span>
<span class="sd">        the central wavelength within the specified range.</span>
<span class="sd">        - Processing steps are applied in the order: normalization, cutoff, masking.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(200, 100, 100), wavelengths=np.linspace(400, 2500, 200))</span>
<span class="sd">        &gt;&gt;&gt; red_band = hsi_image.extract_band_by_name(&quot;Red&quot;)</span>
<span class="sd">        &gt;&gt;&gt; red_band.shape</span>
<span class="sd">        torch.Size([100, 100])</span>

<span class="sd">        &gt;&gt;&gt; # Extract NIR band without normalization or masking</span>
<span class="sd">        &gt;&gt;&gt; nir_band = hsi_image.extract_band_by_name(&quot;NIR&quot;, apply_mask=False, normalize=False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">band_info</span> <span class="o">=</span> <span class="n">spyndex</span><span class="o">.</span><span class="n">bands</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">band_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">band_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Band name &#39;</span><span class="si">{</span><span class="n">band_name</span><span class="si">}</span><span class="s2">&#39; not found in the spyndex library&quot;</span><span class="p">)</span>

    <span class="n">min_wave</span><span class="p">,</span> <span class="n">max_wave</span> <span class="o">=</span> <span class="n">band_info</span><span class="o">.</span><span class="n">min_wavelength</span><span class="p">,</span> <span class="n">band_info</span><span class="o">.</span><span class="n">max_wavelength</span>
    <span class="n">selected_wavelengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span> <span class="o">&gt;=</span> <span class="n">min_wave</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span> <span class="o">&lt;=</span> <span class="n">max_wave</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">selection_method</span> <span class="o">==</span> <span class="s2">&quot;center&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_central_slice_from_band</span><span class="p">(</span>
            <span class="n">selected_wavelengths</span><span class="p">,</span> <span class="n">apply_mask</span><span class="o">=</span><span class="n">apply_mask</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="n">apply_min_cutoff</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Selection method &#39;</span><span class="si">{</span><span class="n">selection_method</span><span class="si">}</span><span class="s2">&#39; is not supported. Only &#39;center&#39; is currently available.&quot;</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.hsi.HSI.get_image" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_image</span><span class="p">(</span><span class="n">apply_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Returns the hyperspectral image data with optional masking applied.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>apply_mask</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to apply the binary mask to the image.
Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Returns:
    torch.Tensor: The hyperspectral image data.</p>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>If apply_mask is True, the binary mask will be applied to the image based on the <code>binary_mask</code> attribute.</li>
</ul>
</details>

<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([10, 100, 100])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">get_image</span><span class="p">(</span><span class="n">apply_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([10, 100, 100])</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the hyperspectral image data with optional masking applied.</span>

<span class="sd">    Args:</span>
<span class="sd">        apply_mask (bool, optional): Whether to apply the binary mask to the image.</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: The hyperspectral image data.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - If apply_mask is True, the binary mask will be applied to the image based on the `binary_mask` attribute.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(10, 100, 100), wavelengths=np.linspace(400, 1000, 10))</span>
<span class="sd">        &gt;&gt;&gt; image = hsi_image.get_image()</span>
<span class="sd">        &gt;&gt;&gt; image.shape</span>
<span class="sd">        torch.Size([10, 100, 100])</span>
<span class="sd">        &gt;&gt;&gt; image = hsi_image.get_image(apply_mask=False)</span>
<span class="sd">        &gt;&gt;&gt; image.shape</span>
<span class="sd">        torch.Size([10, 100, 100])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">apply_mask</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.hsi.HSI.get_rgb_image" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_rgb_image</span><span class="p">(</span><span class="n">apply_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_channel_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Extracts an RGB representation from the hyperspectral image data.</p>
<p>This method creates a 3-channel RGB image by selecting appropriate bands
corresponding to red, green, and blue wavelengths from the hyperspectral data.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>apply_mask</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to apply the binary mask to the image.
Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>apply_min_cutoff</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to apply a minimum intensity
cutoff to the image. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>output_channel_axis</code></td>
            <td>
                  <code>int | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The axis where the RGB channels
should be placed in the output tensor. If None, uses the current spectral
axis of the hyperspectral data. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: The RGB representation of the hyperspectral image.
Shape will be either (H, W, 3), (3, H, W), or (H, 3, W) depending on
the specified output_channel_axis, where H is height and W is width.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The RGB bands are extracted using predefined wavelength ranges for R, G, and B.</li>
<li>Each band is normalized independently before combining into the RGB image.</li>
<li>If apply_mask is True, masked areas will be set to zero in the output.</li>
<li>If apply_min_cutoff is True, a minimum intensity threshold is applied to each band.</li>
</ul>
</details>

<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb_image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">get_rgb_image</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb_image</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([100, 100, 3])</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">rgb_image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">get_rgb_image</span><span class="p">(</span><span class="n">output_channel_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb_image</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([3, 100, 100])</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">rgb_image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">get_rgb_image</span><span class="p">(</span><span class="n">apply_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb_image</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([100, 100, 3])</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_rgb_image</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">output_channel_axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extracts an RGB representation from the hyperspectral image data.</span>

<span class="sd">    This method creates a 3-channel RGB image by selecting appropriate bands</span>
<span class="sd">    corresponding to red, green, and blue wavelengths from the hyperspectral data.</span>

<span class="sd">    Args:</span>
<span class="sd">        apply_mask (bool, optional): Whether to apply the binary mask to the image.</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">        apply_min_cutoff (bool, optional): Whether to apply a minimum intensity</span>
<span class="sd">            cutoff to the image. Defaults to False.</span>
<span class="sd">        output_channel_axis (int | None, optional): The axis where the RGB channels</span>
<span class="sd">            should be placed in the output tensor. If None, uses the current spectral</span>
<span class="sd">            axis of the hyperspectral data. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: The RGB representation of the hyperspectral image.</span>
<span class="sd">            Shape will be either (H, W, 3), (3, H, W), or (H, 3, W) depending on</span>
<span class="sd">            the specified output_channel_axis, where H is height and W is width.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The RGB bands are extracted using predefined wavelength ranges for R, G, and B.</span>
<span class="sd">        - Each band is normalized independently before combining into the RGB image.</span>
<span class="sd">        - If apply_mask is True, masked areas will be set to zero in the output.</span>
<span class="sd">        - If apply_min_cutoff is True, a minimum intensity threshold is applied to each band.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(10, 100, 100), wavelengths=np.linspace(400, 1000, 10))</span>
<span class="sd">        &gt;&gt;&gt; rgb_image = hsi_image.get_rgb_image()</span>
<span class="sd">        &gt;&gt;&gt; rgb_image.shape</span>
<span class="sd">        torch.Size([100, 100, 3])</span>

<span class="sd">        &gt;&gt;&gt; rgb_image = hsi_image.get_rgb_image(output_channel_axis=0)</span>
<span class="sd">        &gt;&gt;&gt; rgb_image.shape</span>
<span class="sd">        torch.Size([3, 100, 100])</span>

<span class="sd">        &gt;&gt;&gt; rgb_image = hsi_image.get_rgb_image(apply_mask=False, apply_min_cutoff=True)</span>
<span class="sd">        &gt;&gt;&gt; rgb_image.shape</span>
<span class="sd">        torch.Size([100, 100, 3])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">output_channel_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_channel_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span>

    <span class="n">rgb_img</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extract_band_by_name</span><span class="p">(</span>
                <span class="n">band</span><span class="p">,</span> <span class="n">apply_mask</span><span class="o">=</span><span class="n">apply_mask</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="n">apply_min_cutoff</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">]</span>
        <span class="p">],</span>
        <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">rgb_img</span>
        <span class="k">if</span> <span class="n">output_channel_axis</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span>
        <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">rgb_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">output_channel_axis</span><span class="p">)</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.hsi.HSI.to" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Moves the image and binary mask (if available) to the specified device.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>device</code></td>
            <td>
                  <code>str or <span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The device to move the image and binary mask to.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Self</code></td>            <td>
                  <code><span title="typing_extensions.Self">Self</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The updated HSI object.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create an HSI object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Move the image to cpu</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span>
<span class="go">device(type=&#39;cpu&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Move the image to cuda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span>
<span class="go">device(type=&#39;cuda&#39;, index=0)</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Moves the image and binary mask (if available) to the specified device.</span>

<span class="sd">    Args:</span>
<span class="sd">        device (str or torch.device): The device to move the image and binary mask to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Self: The updated HSI object.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Create an HSI object</span>
<span class="sd">        &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(10, 10, 10), wavelengths=np.arange(10))</span>
<span class="sd">        &gt;&gt;&gt; # Move the image to cpu</span>
<span class="sd">        &gt;&gt;&gt; hsi_image = hsi_image.to(&quot;cpu&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hsi_image.device</span>
<span class="sd">        device(type=&#39;cpu&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Move the image to cuda</span>
<span class="sd">        &gt;&gt;&gt; hsi_image = hsi_image.to(&quot;cuda&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hsi_image.device</span>
<span class="sd">        device(type=&#39;cuda&#39;, index=0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">device</span>
    <span class="k">return</span> <span class="bp">self</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h2 id="visualizations">Visualizations</h2>


<div class="doc doc-object doc-module">



<a id="src.meteors.visualize.hsi_visualize"></a>
    <div class="doc doc-contents first">



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="src.meteors.visualize.hsi_visualize.visualize_hsi" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">visualize_hsi</span><span class="p">(</span><span class="n">hsi_or_attributes</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Visualizes a Hyperspectral image object on the given axes. It uses either the object from HSI class or a field
from the HSIAttributes class.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>hsi_or_attributes</code></td>
            <td>
                  <code><span title="meteors.HSI">HSI</span> | <span title="meteors.attr.HSIAttributes">HSIAttributes</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The hyperspectral image, or the attributes to be visualized.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>ax</code></td>
            <td>
                  <code><span title="matplotlib.axes.Axes">Axes</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The axes on which the image will be plotted.
If None, the current axes will be used.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>use_mask</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to use the image mask if provided for the visualization.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="matplotlib.axes.Axes">Axes</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>matplotlib.figure.Figure | None:
If use_pyplot is False, returns the figure and axes objects.
If use_pyplot is True, returns None.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/visualize/hsi_visualize.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">visualize_hsi</span><span class="p">(</span><span class="n">hsi_or_attributes</span><span class="p">:</span> <span class="n">HSI</span> <span class="o">|</span> <span class="n">HSIAttributes</span><span class="p">,</span> <span class="n">ax</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">use_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualizes a Hyperspectral image object on the given axes. It uses either the object from HSI class or a field</span>
<span class="sd">    from the HSIAttributes class.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        hsi_or_attributes (HSI | HSIAttributes): The hyperspectral image, or the attributes to be visualized.</span>
<span class="sd">        ax (matplotlib.axes.Axes | None): The axes on which the image will be plotted.</span>
<span class="sd">            If None, the current axes will be used.</span>
<span class="sd">        use_mask (bool): Whether to use the image mask if provided for the visualization.</span>


<span class="sd">    Returns:</span>
<span class="sd">        matplotlib.figure.Figure | None:</span>
<span class="sd">            If use_pyplot is False, returns the figure and axes objects.</span>
<span class="sd">            If use_pyplot is True, returns None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi_or_attributes</span><span class="p">,</span> <span class="n">HSIAttributes</span><span class="p">):</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi_or_attributes</span><span class="o">.</span><span class="n">hsi</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi_or_attributes</span>

    <span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">change_orientation</span><span class="p">(</span><span class="s2">&quot;HWC&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">rgb</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">get_rgb_image</span><span class="p">(</span><span class="n">output_channel_axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">apply_mask</span><span class="o">=</span><span class="n">use_mask</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span> <span class="ow">or</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rgb</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-module">



<a id="src.meteors.visualize.attr_visualize"></a>
    <div class="doc doc-contents first">



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="src.meteors.visualize.attr_visualize.visualize_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">visualize_attributes</span><span class="p">(</span><span class="n">image_attributes</span><span class="p">,</span> <span class="n">use_pyplot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Visualizes the attributes of an image on the given axes.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>image_attributes</code></td>
            <td>
                  <code><span title="meteors.attr.HSIAttributes">HSIAttributes</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The image attributes to be visualized.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>use_pyplot</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, uses pyplot to display the image. If False, returns the figure and axes objects.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>tuple[<span title="matplotlib.figure.Figure">Figure</span>, <span title="matplotlib.axes.Axes">Axes</span>] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>matplotlib.figure.Figure | None:
If use_pyplot is False, returns the figure and axes objects.
If use_pyplot is True, returns None .
If all the attributions are zero, returns None.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/visualize/attr_visualize.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">visualize_attributes</span><span class="p">(</span><span class="n">image_attributes</span><span class="p">:</span> <span class="n">HSIAttributes</span><span class="p">,</span> <span class="n">use_pyplot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualizes the attributes of an image on the given axes.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        image_attributes (HSIAttributes): The image attributes to be visualized.</span>
<span class="sd">        use_pyplot (bool): If True, uses pyplot to display the image. If False, returns the figure and axes objects.</span>

<span class="sd">    Returns:</span>
<span class="sd">        matplotlib.figure.Figure | None:</span>
<span class="sd">            If use_pyplot is False, returns the figure and axes objects.</span>
<span class="sd">            If use_pyplot is True, returns None .</span>
<span class="sd">            If all the attributions are zero, returns None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">image_attributes</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span> <span class="o">!=</span> <span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;HSI orientation </span><span class="si">{</span><span class="n">image_attributes</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span><span class="si">}</span><span class="s2"> is not supported yet&quot;</span><span class="p">)</span>

    <span class="n">rotated_attributes_dataclass</span> <span class="o">=</span> <span class="n">image_attributes</span><span class="o">.</span><span class="n">change_orientation</span><span class="p">(</span><span class="s2">&quot;HWC&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">rotated_attributes</span> <span class="o">=</span> <span class="n">rotated_attributes_dataclass</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">rotated_attributes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;All the attributions are zero. There is nothing to visualize.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Attribution Heatmap&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>

    <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;HSI Attributes of: </span><span class="si">{</span><span class="n">image_attributes</span><span class="o">.</span><span class="n">attribution_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">_</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">visualize_image_attr</span><span class="p">(</span>
        <span class="n">rotated_attributes</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;heat_map&quot;</span><span class="p">,</span>
        <span class="n">sign</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">plt_fig_axis</span><span class="o">=</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
        <span class="n">show_colorbar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">use_pyplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Attribution Module Values&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>

    <span class="c1"># Attributions module values</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">visualize_image_attr</span><span class="p">(</span>
        <span class="n">rotated_attributes</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;heat_map&quot;</span><span class="p">,</span>
        <span class="n">sign</span><span class="o">=</span><span class="s2">&quot;absolute_value&quot;</span><span class="p">,</span>
        <span class="n">plt_fig_axis</span><span class="o">=</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
        <span class="n">show_colorbar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">use_pyplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">sign_attr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">rotated_attributes</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">rotated_attributes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">sign_attr</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;PiYG&quot;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">square</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">&quot;Attribution Sign Values&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

    <span class="n">attr_all</span> <span class="o">=</span> <span class="n">rotated_attributes</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">image_attributes</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">attr_all</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Spectral Attribution&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Wavelength&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Attribution&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">attr_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rotated_attributes</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">image_attributes</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">attr_abs</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Spectral Attribution Absolute Values&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Wavelength&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Attribution Absolute Value&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Sign values</span>
    <span class="n">sign_attr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">rotated_attributes</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">rotated_attributes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">rotated_attributes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">image_attributes</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">sign_attr</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;g&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Spectral Attribution Sign Values&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Wavelength&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Attribution Sign Proportion&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">use_pyplot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># pragma: no cover</span>

    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.visualize.lime_visualize.visualize_spectral_attributes_by_waveband" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">visualize_spectral_attributes_by_waveband</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">color_palette</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_not_included</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_legend</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents first">

        <p>Visualizes spectral attributes by waveband.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>spectral_attributes</code></td>
            <td>
                  <code><span title="meteors.attr.HSISpectralAttributes">HSISpectralAttributes</span> | list[<span title="meteors.attr.HSISpectralAttributes">HSISpectralAttributes</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The spectral attributes to visualize.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>ax</code></td>
            <td>
                  <code><span title="matplotlib.axes.Axes">Axes</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The matplotlib axes to plot the visualization on.
If None, a new axes will be created.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>color_palette</code></td>
            <td>
                  <code>list[str] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The color palette to use for plotting.
If None, a default color palette will be used.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>show_not_included</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to show the "not_included" band in the visualization.
Default is True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>show_legend</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to show the legend in the visualization.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Axes</code></td>            <td>
                  <code><span title="matplotlib.axes.Axes">Axes</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The matplotlib axes object containing the visualization.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/visualize/lime_visualize.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">visualize_spectral_attributes_by_waveband</span><span class="p">(</span>
    <span class="n">spectral_attributes</span><span class="p">:</span> <span class="n">HSISpectralAttributes</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSISpectralAttributes</span><span class="p">],</span>
    <span class="n">ax</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">color_palette</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">show_not_included</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">show_legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualizes spectral attributes by waveband.</span>

<span class="sd">    Args:</span>
<span class="sd">        spectral_attributes (HSISpectralAttributes | list[HSISpectralAttributes]):</span>
<span class="sd">            The spectral attributes to visualize.</span>
<span class="sd">        ax (Axes | None): The matplotlib axes to plot the visualization on.</span>
<span class="sd">            If None, a new axes will be created.</span>
<span class="sd">        color_palette (list[str] | None): The color palette to use for plotting.</span>
<span class="sd">            If None, a default color palette will be used.</span>
<span class="sd">        show_not_included (bool): Whether to show the &quot;not_included&quot; band in the visualization.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        show_legend (bool): Whether to show the legend in the visualization.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Axes: The matplotlib axes object containing the visualization.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">,</span> <span class="n">HSISpectralAttributes</span><span class="p">):</span>
        <span class="n">spectral_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="n">spectral_attributes</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">HSISpectralAttributes</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">spectral_attributes</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;spectral_attributes must be an HSISpectralAttributes object or a list of HSISpectralAttributes objects.&quot;</span>
        <span class="p">)</span>

    <span class="n">aggregate_results</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">True</span>
    <span class="n">band_names</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">band_names</span><span class="p">)</span>
    <span class="n">wavelengths</span> <span class="o">=</span> <span class="n">spectral_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span>
    <span class="n">validate_consistent_band_and_wavelengths</span><span class="p">(</span><span class="n">band_names</span><span class="p">,</span> <span class="n">wavelengths</span><span class="p">,</span> <span class="n">spectral_attributes</span><span class="p">)</span>

    <span class="n">ax</span> <span class="o">=</span> <span class="n">setup_visualization</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s2">&quot;Attributions by Waveband&quot;</span><span class="p">,</span> <span class="s2">&quot;Wavelength (nm)&quot;</span><span class="p">,</span> <span class="s2">&quot;Correlation with Output&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">show_not_included</span> <span class="ow">and</span> <span class="n">band_names</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;not_included&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">band_names</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;not_included&quot;</span><span class="p">)</span>

    <span class="n">band_names</span> <span class="o">=</span> <span class="n">_merge_band_names_segments</span><span class="p">(</span><span class="n">band_names</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

    <span class="k">if</span> <span class="n">color_palette</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">color_palette</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s2">&quot;hsv&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_names</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

    <span class="n">band_mask</span> <span class="o">=</span> <span class="n">spectral_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">band_mask</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
    <span class="n">attribution_map</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">attr</span><span class="o">.</span><span class="n">flattened_attributes</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">spectral_attributes</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">band_name</span><span class="p">,</span> <span class="n">segment_id</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">band_names</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="n">current_wavelengths</span> <span class="o">=</span> <span class="n">wavelengths</span><span class="p">[</span><span class="n">band_mask</span> <span class="o">==</span> <span class="n">segment_id</span><span class="p">]</span>
        <span class="n">current_attribution_map</span> <span class="o">=</span> <span class="n">attribution_map</span><span class="p">[:,</span> <span class="n">band_mask</span> <span class="o">==</span> <span class="n">segment_id</span><span class="p">]</span>

        <span class="n">current_mean</span> <span class="o">=</span> <span class="n">current_attribution_map</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">aggregate_results</span><span class="p">:</span>
            <span class="n">lolims</span> <span class="o">=</span> <span class="n">current_attribution_map</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">uplims</span> <span class="o">=</span> <span class="n">current_attribution_map</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span>
                <span class="n">current_wavelengths</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span>
                <span class="n">current_mean</span><span class="p">,</span>
                <span class="n">yerr</span><span class="o">=</span><span class="p">[</span><span class="n">current_mean</span> <span class="o">-</span> <span class="n">lolims</span><span class="p">,</span> <span class="n">uplims</span> <span class="o">-</span> <span class="n">current_mean</span><span class="p">],</span>
                <span class="n">label</span><span class="o">=</span><span class="n">band_name</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="n">color_palette</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span>
                <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
                <span class="n">markersize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="n">current_wavelengths</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span>
                <span class="n">current_mean</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="n">band_name</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="n">color_palette</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">show_legend</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">&quot;SuperBand&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.visualize.lime_visualize.visualize_spectral_attributes_by_magnitude" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">visualize_spectral_attributes_by_magnitude</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">color_palette</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">annotate_bars</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_not_included</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents first">

        <p>Visualizes the spectral attributes by magnitude.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>spectral_attributes</code></td>
            <td>
                  <code><span title="meteors.attr.HSISpectralAttributes">HSISpectralAttributes</span> | list[<span title="meteors.attr.HSISpectralAttributes">HSISpectralAttributes</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The spectral attributes to visualize.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>ax</code></td>
            <td>
                  <code><span title="matplotlib.axes.Axes">Axes</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The matplotlib Axes object to plot the visualization on.
If None, a new Axes object will be created.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>color_palette</code></td>
            <td>
                  <code>list[str] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The color palette to use for the visualization.
If None, a default color palette will be used.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>annotate_bars</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to annotate the bars with their magnitudes.
Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>show_not_included</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to show the 'not_included' band in the visualization.
Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Axes</code></td>            <td>
                  <code><span title="matplotlib.axes.Axes">Axes</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The matplotlib Axes object containing the visualization.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/visualize/lime_visualize.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">visualize_spectral_attributes_by_magnitude</span><span class="p">(</span>
    <span class="n">spectral_attributes</span><span class="p">:</span> <span class="n">HSISpectralAttributes</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSISpectralAttributes</span><span class="p">],</span>
    <span class="n">ax</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">color_palette</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">annotate_bars</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">show_not_included</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualizes the spectral attributes by magnitude.</span>

<span class="sd">    Args:</span>
<span class="sd">        spectral_attributes (HSISpectralAttributes | list[HSISpectralAttributes]):</span>
<span class="sd">            The spectral attributes to visualize.</span>
<span class="sd">        ax (Axes | None): The matplotlib Axes object to plot the visualization on.</span>
<span class="sd">            If None, a new Axes object will be created.</span>
<span class="sd">        color_palette (list[str] | None): The color palette to use for the visualization.</span>
<span class="sd">            If None, a default color palette will be used.</span>
<span class="sd">        annotate_bars (bool): Whether to annotate the bars with their magnitudes.</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">        show_not_included (bool): Whether to show the &#39;not_included&#39; band in the visualization.</span>
<span class="sd">            Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Axes: The matplotlib Axes object containing the visualization.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">,</span> <span class="n">HSISpectralAttributes</span><span class="p">):</span>
        <span class="n">spectral_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="n">spectral_attributes</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">HSISpectralAttributes</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">spectral_attributes</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;spectral_attributes must be an HSISpectralAttributes object or a list of HSISpectralAttributes objects.&quot;</span>
        <span class="p">)</span>

    <span class="n">aggregate_results</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">True</span>
    <span class="n">band_names</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">band_names</span><span class="p">)</span>
    <span class="n">wavelengths</span> <span class="o">=</span> <span class="n">spectral_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span>
    <span class="n">validate_consistent_band_and_wavelengths</span><span class="p">(</span><span class="n">band_names</span><span class="p">,</span> <span class="n">wavelengths</span><span class="p">,</span> <span class="n">spectral_attributes</span><span class="p">)</span>

    <span class="n">ax</span> <span class="o">=</span> <span class="n">setup_visualization</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s2">&quot;Attributions by Magnitude&quot;</span><span class="p">,</span> <span class="s2">&quot;Group&quot;</span><span class="p">,</span> <span class="s2">&quot;Average Attribution Magnitude&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">)</span>

    <span class="n">band_names</span> <span class="o">=</span> <span class="n">_merge_band_names_segments</span><span class="p">(</span><span class="n">band_names</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">band_names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">show_not_included</span> <span class="ow">and</span> <span class="n">band_names</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;not_included&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">band_names</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;not_included&quot;</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">band_names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">color_palette</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">color_palette</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s2">&quot;hsv&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_names</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

    <span class="n">band_mask</span> <span class="o">=</span> <span class="n">spectral_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">band_mask</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
    <span class="n">attribution_map</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">attr</span><span class="o">.</span><span class="n">flattened_attributes</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">spectral_attributes</span><span class="p">])</span>
    <span class="n">avg_magnitudes</span> <span class="o">=</span> <span class="n">calculate_average_magnitudes</span><span class="p">(</span><span class="n">band_names</span><span class="p">,</span> <span class="n">band_mask</span><span class="p">,</span> <span class="n">attribution_map</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">aggregate_results</span><span class="p">:</span>
        <span class="n">boxplot</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">boxplot</span><span class="p">(</span><span class="n">avg_magnitudes</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">patch_artist</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">patch</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">boxplot</span><span class="p">[</span><span class="s2">&quot;boxes&quot;</span><span class="p">],</span> <span class="n">color_palette</span><span class="p">):</span>
            <span class="n">patch</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">bars</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">avg_magnitudes</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color_palette</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">annotate_bars</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">bar</span> <span class="ow">in</span> <span class="n">bars</span><span class="p">:</span>
                <span class="n">height</span> <span class="o">=</span> <span class="n">bar</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">height</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">get_x</span><span class="p">()</span> <span class="o">+</span> <span class="n">bar</span><span class="o">.</span><span class="n">get_width</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span>
                    <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>  <span class="c1"># 3 points vertical offset</span>
                    <span class="n">textcoords</span><span class="o">=</span><span class="s2">&quot;offset points&quot;</span><span class="p">,</span>
                    <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
                    <span class="n">va</span><span class="o">=</span><span class="s2">&quot;bottom&quot;</span><span class="p">,</span>
                <span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.visualize.lime_visualize.visualize_spectral_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">visualize_spectral_attributes</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">,</span> <span class="n">use_pyplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">color_palette</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_not_included</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents first">

        <p>Visualizes the spectral attributes of an hsi object or a list of hsi objects.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>spectral_attributes</code></td>
            <td>
                  <code><span title="meteors.attr.HSISpectralAttributes">HSISpectralAttributes</span> | list[<span title="meteors.attr.HSISpectralAttributes">HSISpectralAttributes</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The spectral attributes of the image object to visualize.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>use_pyplot</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, displays the visualization using pyplot.
If False, returns the figure and axes objects. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>color_palette</code></td>
            <td>
                  <code>list[str] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The color palette to use for visualizing different spectral bands.
If None, a default color palette is used.
Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>show_not_included</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, includes the spectral bands that are not included in the visualization.
If False, only includes the spectral bands that are included in the visualization.
Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>tuple[<span title="matplotlib.figure.Figure">Figure</span>, <span title="matplotlib.axes.Axes">Axes</span>] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple[matplotlib.figure.Figure, matplotlib.axes.Axes] | None:
If use_pyplot is False, returns the figure and axes objects.
If use_pyplot is True, returns None.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/visualize/lime_visualize.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">visualize_spectral_attributes</span><span class="p">(</span>
    <span class="n">spectral_attributes</span><span class="p">:</span> <span class="n">HSISpectralAttributes</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSISpectralAttributes</span><span class="p">],</span>
    <span class="n">use_pyplot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">color_palette</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">show_not_included</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualizes the spectral attributes of an hsi object or a list of hsi objects.</span>

<span class="sd">    Args:</span>
<span class="sd">        spectral_attributes (HSISpectralAttributes | list[HSISpectralAttributes]):</span>
<span class="sd">            The spectral attributes of the image object to visualize.</span>
<span class="sd">        use_pyplot (bool, optional):</span>
<span class="sd">            If True, displays the visualization using pyplot.</span>
<span class="sd">            If False, returns the figure and axes objects. Defaults to False.</span>
<span class="sd">        color_palette (list[str] | None, optional):</span>
<span class="sd">            The color palette to use for visualizing different spectral bands.</span>
<span class="sd">            If None, a default color palette is used.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        show_not_included (bool, optional):</span>
<span class="sd">            If True, includes the spectral bands that are not included in the visualization.</span>
<span class="sd">            If False, only includes the spectral bands that are included in the visualization.</span>
<span class="sd">            Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[matplotlib.figure.Figure, matplotlib.axes.Axes] | None:</span>
<span class="sd">            If use_pyplot is False, returns the figure and axes objects.</span>
<span class="sd">            If use_pyplot is True, returns None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">agg</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="n">band_names</span> <span class="o">=</span> <span class="n">spectral_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">band_names</span> <span class="k">if</span> <span class="n">agg</span> <span class="k">else</span> <span class="n">spectral_attributes</span><span class="o">.</span><span class="n">band_names</span>  <span class="c1"># type: ignore</span>

    <span class="n">color_palette</span> <span class="o">=</span> <span class="n">color_palette</span> <span class="ow">or</span> <span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s2">&quot;hsv&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_names</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="k">if</span> <span class="n">agg</span> <span class="k">else</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Spectral Attributes Visualization&quot;</span><span class="p">)</span>

    <span class="n">visualize_spectral_attributes_by_waveband</span><span class="p">(</span>
        <span class="n">spectral_attributes</span><span class="p">,</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">color_palette</span><span class="o">=</span><span class="n">color_palette</span><span class="p">,</span>
        <span class="n">show_not_included</span><span class="o">=</span><span class="n">show_not_included</span><span class="p">,</span>
        <span class="n">show_legend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">visualize_spectral_attributes_by_magnitude</span><span class="p">(</span>
        <span class="n">spectral_attributes</span><span class="p">,</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">color_palette</span><span class="o">=</span><span class="n">color_palette</span><span class="p">,</span>
        <span class="n">show_not_included</span><span class="o">=</span><span class="n">show_not_included</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">agg</span><span class="p">:</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">attr</span><span class="o">.</span><span class="n">score</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">spectral_attributes</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
        <span class="n">mean_score</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;steelblue&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">mean_score</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;darkred&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span><span class="p">)</span>

        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Distribution of Score Values&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Score&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Frequency&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">use_pyplot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># pragma: no cover</span>

    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.visualize.lime_visualize.visualize_spatial_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">visualize_spatial_attributes</span><span class="p">(</span><span class="n">spatial_attributes</span><span class="p">,</span> <span class="n">use_pyplot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents first">

        <p>Visualizes the spatial attributes of an hsi using Lime attribution.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>spatial_attributes</code></td>
            <td>
                  <code><span title="meteors.attr.HSISpatialAttributes">HSISpatialAttributes</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The spatial attributes of the image object to visualize.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>use_pyplot</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to use pyplot for visualization. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>tuple[<span title="matplotlib.figure.Figure">Figure</span>, <span title="matplotlib.axes.Axes">Axes</span>] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple[matplotlib.figure.Figure, matplotlib.axes.Axes] | None:
If use_pyplot is False, returns the figure and axes objects.
If use_pyplot is True, returns None.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/visualize/lime_visualize.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">visualize_spatial_attributes</span><span class="p">(</span>
    <span class="n">spatial_attributes</span><span class="p">:</span> <span class="n">HSISpatialAttributes</span><span class="p">,</span> <span class="n">use_pyplot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualizes the spatial attributes of an hsi using Lime attribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        spatial_attributes (HSISpatialAttributes):</span>
<span class="sd">            The spatial attributes of the image object to visualize.</span>
<span class="sd">        use_pyplot (bool, optional):</span>
<span class="sd">            Whether to use pyplot for visualization. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[matplotlib.figure.Figure, matplotlib.axes.Axes] | None:</span>
<span class="sd">            If use_pyplot is False, returns the figure and axes objects.</span>
<span class="sd">            If use_pyplot is True, returns None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask_enabled</span> <span class="o">=</span> <span class="n">spatial_attributes</span><span class="o">.</span><span class="n">segmentation_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="k">if</span> <span class="n">mask_enabled</span> <span class="k">else</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Spatial Attributes Visualization&quot;</span><span class="p">)</span>
    <span class="n">spatial_attributes</span> <span class="o">=</span> <span class="n">spatial_attributes</span><span class="o">.</span><span class="n">change_orientation</span><span class="p">(</span><span class="s2">&quot;HWC&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mask_enabled</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">spatial_attributes</span><span class="o">.</span><span class="n">segmentation_mask</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>

        <span class="n">group_names</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s2">&quot;hsv&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">group_names</span><span class="p">))</span>
        <span class="n">color_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">group_names</span><span class="p">,</span> <span class="n">colors</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">unique</span> <span class="ow">in</span> <span class="n">group_names</span><span class="p">:</span>
            <span class="n">segment_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">unique</span><span class="p">)</span>

            <span class="n">y_center</span><span class="p">,</span> <span class="n">x_center</span> <span class="o">=</span> <span class="n">segment_indices</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x_center</span><span class="p">,</span> <span class="n">y_center</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">unique</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="n">color_map</span><span class="p">[</span><span class="n">unique</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x_center</span><span class="p">,</span> <span class="n">y_center</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">unique</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="n">color_map</span><span class="p">[</span><span class="n">unique</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">)</span>

        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="o">/</span> <span class="n">mask</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Mask&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>

    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">spatial_attributes</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">get_rgb_image</span><span class="p">(</span><span class="n">output_channel_axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Original image&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>

    <span class="n">attrs</span> <span class="o">=</span> <span class="n">spatial_attributes</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">attrs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;All spatial attributes are zero.&quot;</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">LinearSegmentedColormap</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span><span class="s2">&quot;RdWhGn&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="s2">&quot;white&quot;</span><span class="p">,</span> <span class="s2">&quot;green&quot;</span><span class="p">])</span>
        <span class="n">heat_map</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">attrs</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">axis_separator</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">colorbar_axis</span> <span class="o">=</span> <span class="n">axis_separator</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;bottom&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">heat_map</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;horizontal&quot;</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">colorbar_axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">viz</span><span class="o">.</span><span class="n">visualize_image_attr</span><span class="p">(</span>
            <span class="n">attrs</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;heat_map&quot;</span><span class="p">,</span>
            <span class="n">sign</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
            <span class="n">plt_fig_axis</span><span class="o">=</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">show_colorbar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">use_pyplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Attribution Map&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">use_pyplot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># pragma: no cover</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div><h2 id="attribution-methods">Attribution Methods</h2>


<div class="doc doc-object doc-class">



<h3 id="src.meteors.attr.attributes.HSIAttributes" class="doc doc-heading">
            <code>HSIAttributes</code>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="pydantic.BaseModel">BaseModel</span></code></p>


        <p>Represents an object that contains Hyperspectral image attributes and explanations.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributes.hsi">hsi</span></code></td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Hyperspectral image object for which the explanations were created.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributes.attributes">attributes</span></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Attributions (explanations) for the hsi.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributes.score">score</span></code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The score provided by the interpretable model. Can be None if method don't provide one.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributes.device">device</span></code></td>
            <td>
                  <code><span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Device to be used for inference. If None, the device of the input hsi will be used.
Defaults to None.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributes.attribution_method">attribution_method</span></code></td>
            <td>
                  <code>str | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The method used to generate the explanation. Defaults to None.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/attributes.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">HSIAttributes</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents an object that contains Hyperspectral image attributes and explanations.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        hsi (HSI): Hyperspectral image object for which the explanations were created.</span>
<span class="sd">        attributes (torch.Tensor): Attributions (explanations) for the hsi.</span>
<span class="sd">        score (float): The score provided by the interpretable model. Can be None if method don&#39;t provide one.</span>
<span class="sd">        device (torch.device): Device to be used for inference. If None, the device of the input hsi will be used.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        attribution_method (str | None): The method used to generate the explanation. Defaults to None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">hsi</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">HSI</span><span class="p">,</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Hyperspectral image object for which the explanations were created.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span>
    <span class="n">attributes</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">BeforeValidator</span><span class="p">(</span><span class="n">validate_and_convert_attributes</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Attributions (explanations) for the hsi.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span>
    <span class="n">attribution_method</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">AfterValidator</span><span class="p">(</span><span class="n">validate_attribution_method</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The method used to generate the explanation.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">score</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">validate_default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The score provided by the interpretable model. Can be None if method don&#39;t provide one.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">BeforeValidator</span><span class="p">(</span><span class="n">validate_and_convert_mask</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;`superpixel` or `superband` mask used for the explanation.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
        <span class="n">BeforeValidator</span><span class="p">(</span><span class="n">resolve_inference_device_attributes</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">validate_default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Device to be used for inference. If None, the device of the input hsi will be used. &quot;</span>
                <span class="s2">&quot;Defaults to None.&quot;</span>
            <span class="p">),</span>
        <span class="p">),</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flattened_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a flattened tensor of attributes.</span>

<span class="sd">        This method should be implemented in the subclass.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A flattened tensor of attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;This method should be implemented in the subclass&quot;</span><span class="p">)</span>

    <span class="n">model_config</span> <span class="o">=</span> <span class="n">ConfigDict</span><span class="p">(</span><span class="n">arbitrary_types_allowed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the orientation of the hsi.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[str, str, str]: The orientation of the hsi corresponding to the attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span>

    <span class="k">def</span> <span class="nf">_validate_hsi_attributions_and_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validates the hsi attributions and performs necessary operations to ensure compatibility with the device.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the shapes of the attributes and hsi tensors do not match.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validate_shapes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">validate_shapes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="nd">@model_validator</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;after&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">validate_hsi_attributions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validates the hsi attributions.</span>

<span class="sd">        This method performs validation on the hsi attributions to ensure they are correct.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: The current instance of the class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_hsi_attributions_and_mask</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move the hsi and attributes tensors to the specified device.</span>

<span class="sd">        Args:</span>
<span class="sd">            device (str or torch.device): The device to move the tensors to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: The modified object with tensors moved to the specified device.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; attrs = HSIAttributes(hsi, attributes, score=0.5)</span>
<span class="sd">            &gt;&gt;&gt; attrs.to(&quot;cpu&quot;)</span>
<span class="sd">            &gt;&gt;&gt; attrs.hsi.device</span>
<span class="sd">            device(type=&#39;cpu&#39;)</span>
<span class="sd">            &gt;&gt;&gt; attrs.attributes.device</span>
<span class="sd">            device(type=&#39;cpu&#39;)</span>
<span class="sd">            &gt;&gt;&gt; attrs.to(&quot;cuda&quot;)</span>
<span class="sd">            &gt;&gt;&gt; attrs.hsi.device</span>
<span class="sd">            device(type=&#39;cuda&#39;)</span>
<span class="sd">            &gt;&gt;&gt; attrs.attributes.device</span>
<span class="sd">            device(type=&#39;cuda&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">device</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">change_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_orientation</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Changes the orientation of the image data along with the attributions to the target orientation.</span>

<span class="sd">        Args:</span>
<span class="sd">            target_orientation (tuple[str, str, str] | list[str] | str): The target orientation for the attribution data.</span>
<span class="sd">                This should be a tuple of three one-letter strings in any order: &quot;C&quot;, &quot;H&quot;, &quot;W&quot;.</span>
<span class="sd">            inplace (bool, optional): Whether to modify the data in place or return a new object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: The updated Image object with the new orientation.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the target orientation is not a valid tuple of three one-letter strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current_orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">change_orientation</span><span class="p">(</span><span class="n">target_orientation</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_copy</span><span class="p">()</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi</span>

        <span class="c1"># now change the orientation of the attributes</span>
        <span class="k">if</span> <span class="n">current_orientation</span> <span class="o">==</span> <span class="n">target_orientation</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">attrs</span>

        <span class="n">permute_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">target_orientation</span><span class="p">]</span>

        <span class="n">attrs</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">permute_dims</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">attrs</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">permute_dims</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">attrs</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h4 id="src.meteors.attr.attributes.HSIAttributes.flattened_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">flattened_attributes</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Returns a flattened tensor of attributes.</p>
<p>This method should be implemented in the subclass.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: A flattened tensor of attributes.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
    </div>

</div>

<div class="doc doc-object doc-attribute">



<h4 id="src.meteors.attr.attributes.HSIAttributes.orientation" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">orientation</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Returns the orientation of the hsi.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>tuple[str, str, str]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple[str, str, str]: The orientation of the hsi corresponding to the attributes.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
    </div>

</div>



<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.attributes.HSIAttributes.change_orientation" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">change_orientation</span><span class="p">(</span><span class="n">target_orientation</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Changes the orientation of the image data along with the attributions to the target orientation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>target_orientation</code></td>
            <td>
                  <code>tuple[str, str, str] | list[str] | str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The target orientation for the attribution data.
This should be a tuple of three one-letter strings in any order: "C", "H", "W".</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>inplace</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to modify the data in place or return a new object.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Self</code></td>            <td>
                  <code><span title="typing_extensions.Self">Self</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The updated Image object with the new orientation.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the target orientation is not a valid tuple of three one-letter strings.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/attributes.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">change_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_orientation</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Changes the orientation of the image data along with the attributions to the target orientation.</span>

<span class="sd">    Args:</span>
<span class="sd">        target_orientation (tuple[str, str, str] | list[str] | str): The target orientation for the attribution data.</span>
<span class="sd">            This should be a tuple of three one-letter strings in any order: &quot;C&quot;, &quot;H&quot;, &quot;W&quot;.</span>
<span class="sd">        inplace (bool, optional): Whether to modify the data in place or return a new object.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Self: The updated Image object with the new orientation.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the target orientation is not a valid tuple of three one-letter strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">current_orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span>
    <span class="n">hsi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">change_orientation</span><span class="p">(</span><span class="n">target_orientation</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_copy</span><span class="p">()</span>
        <span class="n">attrs</span><span class="o">.</span><span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi</span>

    <span class="c1"># now change the orientation of the attributes</span>
    <span class="k">if</span> <span class="n">current_orientation</span> <span class="o">==</span> <span class="n">target_orientation</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">attrs</span>

    <span class="n">permute_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">target_orientation</span><span class="p">]</span>

    <span class="n">attrs</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">permute_dims</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">attrs</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">attrs</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">permute_dims</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">attrs</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.attributes.HSIAttributes.to" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Move the hsi and attributes tensors to the specified device.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>device</code></td>
            <td>
                  <code>str or <span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The device to move the tensors to.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Self</code></td>            <td>
                  <code><span title="typing_extensions.Self">Self</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The modified object with tensors moved to the specified device.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span> <span class="o">=</span> <span class="n">HSIAttributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">score</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">device</span>
<span class="go">device(type=&#39;cpu&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">device</span>
<span class="go">device(type=&#39;cpu&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">device</span>
<span class="go">device(type=&#39;cuda&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">device</span>
<span class="go">device(type=&#39;cuda&#39;)</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/attributes.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Move the hsi and attributes tensors to the specified device.</span>

<span class="sd">    Args:</span>
<span class="sd">        device (str or torch.device): The device to move the tensors to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Self: The modified object with tensors moved to the specified device.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; attrs = HSIAttributes(hsi, attributes, score=0.5)</span>
<span class="sd">        &gt;&gt;&gt; attrs.to(&quot;cpu&quot;)</span>
<span class="sd">        &gt;&gt;&gt; attrs.hsi.device</span>
<span class="sd">        device(type=&#39;cpu&#39;)</span>
<span class="sd">        &gt;&gt;&gt; attrs.attributes.device</span>
<span class="sd">        device(type=&#39;cpu&#39;)</span>
<span class="sd">        &gt;&gt;&gt; attrs.to(&quot;cuda&quot;)</span>
<span class="sd">        &gt;&gt;&gt; attrs.hsi.device</span>
<span class="sd">        device(type=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; attrs.attributes.device</span>
<span class="sd">        device(type=&#39;cuda&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">device</span>
    <span class="k">return</span> <span class="bp">self</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.meteors.attr.attributes.HSISpatialAttributes" class="doc doc-heading">
            <code>HSISpatialAttributes</code>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributes" href="#src.meteors.attr.attributes.HSIAttributes">HSIAttributes</a></code></p>


        <p>Represents spatial attributes of an hsi used for explanation.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSISpatialAttributes.hsi">hsi</span></code></td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Hyperspectral image object for which the explanations were created.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSISpatialAttributes.attributes">attributes</span></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Attributions (explanations) for the hsi.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSISpatialAttributes.score">score</span></code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The score provided by the interpretable model. Can be None if method don't provide one.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSISpatialAttributes.device">device</span></code></td>
            <td>
                  <code><span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Device to be used for inference. If None, the device of the input hsi will be used.
Defaults to None.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSISpatialAttributes.attribution_method">attribution_method</span></code></td>
            <td>
                  <code>str | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The method used to generate the explanation. Defaults to None.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSISpatialAttributes.segmentation_mask" href="#src.meteors.attr.attributes.HSISpatialAttributes.segmentation_mask">segmentation_mask</a></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Spatial (Segmentation) mask used for the explanation.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSISpatialAttributes.flattened_attributes" href="#src.meteors.attr.attributes.HSISpatialAttributes.flattened_attributes">flattened_attributes</a></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Spatial 2D attribution map.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/attributes.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">HSISpatialAttributes</span><span class="p">(</span><span class="n">HSIAttributes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents spatial attributes of an hsi used for explanation.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        hsi (HSI): Hyperspectral image object for which the explanations were created.</span>
<span class="sd">        attributes (torch.Tensor): Attributions (explanations) for the hsi.</span>
<span class="sd">        score (float): The score provided by the interpretable model. Can be None if method don&#39;t provide one.</span>
<span class="sd">        device (torch.device): Device to be used for inference. If None, the device of the input hsi will be used.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        attribution_method (str | None): The method used to generate the explanation. Defaults to None.</span>
<span class="sd">        segmentation_mask (torch.Tensor): Spatial (Segmentation) mask used for the explanation.</span>
<span class="sd">        flattened_attributes (torch.Tensor): Spatial 2D attribution map.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">segmentation_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the 2D spatial segmentation mask that has the same size as the hsi image.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The segmentation mask tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Segmentation mask is not provided&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flattened_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a flattened tensor of attributes, with removed repeated dimensions.</span>

<span class="sd">        In the case of spatial attributes, the flattened attributes are 2D spatial attributes of shape (rows, columns) and the spectral dimension is removed.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask = torch.zeros((3, 2, 2))</span>
<span class="sd">            &gt;&gt;&gt; attrs = HSISpatialAttributes(hsi, attributes, score=0.5, segmentation_mask=segmentation_mask)</span>
<span class="sd">            &gt;&gt;&gt; attrs.flattened_attributes</span>
<span class="sd">                tensor([[0., 0.],</span>
<span class="sd">                        [0., 0.]])</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A flattened tensor of attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_hsi_attributions_and_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validates the hsi attributions and performs necessary operations to ensure compatibility with the device.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the shapes of the attributes and hsi tensors do not match.</span>
<span class="sd">            ValueError: If the segmentation mask is not provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_validate_hsi_attributions_and_mask</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Segmentation mask is not provided&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h4 id="src.meteors.attr.attributes.HSISpatialAttributes.flattened_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">flattened_attributes</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Returns a flattened tensor of attributes, with removed repeated dimensions.</p>
<p>In the case of spatial attributes, the flattened attributes are 2D spatial attributes of shape (rows, columns) and the spectral dimension is removed.</p>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span> <span class="o">=</span> <span class="n">HSISpatialAttributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">score</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">segmentation_mask</span><span class="o">=</span><span class="n">segmentation_mask</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">flattened_attributes</span>
<span class="go">    tensor([[0., 0.],</span>
<span class="go">            [0., 0.]])</span>
</code></pre></div>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: A flattened tensor of attributes.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
    </div>

</div>

<div class="doc doc-object doc-attribute">



<h4 id="src.meteors.attr.attributes.HSISpatialAttributes.segmentation_mask" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">segmentation_mask</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Returns the 2D spatial segmentation mask that has the same size as the hsi image.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: The segmentation mask tensor.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
    </div>

</div>





  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.meteors.attr.attributes.HSISpectralAttributes" class="doc doc-heading">
            <code>HSISpectralAttributes</code>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributes" href="#src.meteors.attr.attributes.HSIAttributes">HSIAttributes</a></code></p>


        <p>Represents an hsi with spectral attributes used for explanation.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSISpectralAttributes.hsi">hsi</span></code></td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Hyperspectral hsi object for which the explanations were created.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSISpectralAttributes.attributes">attributes</span></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Attributions (explanations) for the hsi.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSISpectralAttributes.score">score</span></code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>R^2 score of interpretable model used for the explanation.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSISpectralAttributes.device">device</span></code></td>
            <td>
                  <code><span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Device to be used for inference. If None, the device of the input hsi will be used.
Defaults to None.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSISpectralAttributes.attribution_method">attribution_method</span></code></td>
            <td>
                  <code>str | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The method used to generate the explanation. Defaults to None.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSISpectralAttributes.band_mask" href="#src.meteors.attr.attributes.HSISpectralAttributes.band_mask">band_mask</a></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Band mask used for the explanation.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSISpectralAttributes.band_names">band_names</span></code></td>
            <td>
                  <code>dict[str | tuple[str, ...], int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dictionary that translates the band names into the band segment ids.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSISpectralAttributes.flattened_attributes" href="#src.meteors.attr.attributes.HSISpectralAttributes.flattened_attributes">flattened_attributes</a></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Spectral 1D attribution map.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/attributes.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">HSISpectralAttributes</span><span class="p">(</span><span class="n">HSIAttributes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents an hsi with spectral attributes used for explanation.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        hsi (HSI): Hyperspectral hsi object for which the explanations were created.</span>
<span class="sd">        attributes (torch.Tensor): Attributions (explanations) for the hsi.</span>
<span class="sd">        score (float): R^2 score of interpretable model used for the explanation.</span>
<span class="sd">        device (torch.device): Device to be used for inference. If None, the device of the input hsi will be used.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        attribution_method (str | None): The method used to generate the explanation. Defaults to None.</span>
<span class="sd">        band_mask (torch.Tensor): Band mask used for the explanation.</span>
<span class="sd">        band_names (dict[str | tuple[str, ...], int]): Dictionary that translates the band names into the band segment ids.</span>
<span class="sd">        flattened_attributes (torch.Tensor): Spectral 1D attribution map.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">band_names</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Dictionary that translates the band names into the band segment ids.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">band_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a 1D band mask - a band mask with removed repeated dimensions (num_bands, ),</span>
<span class="sd">        where num_bands is the number of bands in the hsi image.</span>

<span class="sd">        The method selects the appropriate dimensions from the `band_mask` tensor</span>
<span class="sd">        based on the `axis_to_select` and returns a flattened version of the selected</span>
<span class="sd">        tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The flattened band mask tensor.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; band_names = {&quot;R&quot;: 0, &quot;G&quot;: 1, &quot;B&quot;: 2}</span>
<span class="sd">            &gt;&gt;&gt; attrs = HSISpectralAttributes(hsi, attributes, score=0.5, mask=band_mask)</span>
<span class="sd">            &gt;&gt;&gt; attrs.flattened_band_mask</span>
<span class="sd">            torch.tensor([0, 1, 2])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Band mask is not provided&quot;</span><span class="p">)</span>
        <span class="n">axis_to_select</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">axis_to_select</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">axis_to_select</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flattened_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a flattened tensor of attributes with removed repeated dimensions.</span>

<span class="sd">        In the case of spectral attributes, the flattened attributes are 1D tensor of shape (num_bands, ), where num_bands is the number of bands in the hsi image.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A flattened tensor of attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_hsi_attributions_and_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validates the hsi attributions and performs necessary operations to ensure compatibility with the device.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the shapes of the attributes and hsi tensors do not match.</span>
<span class="sd">            ValueError: If the band mask is not provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_validate_hsi_attributions_and_mask</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Band mask is not provided&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span> <span class="o">=</span> <span class="n">align_band_names_with_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">band_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h4 id="src.meteors.attr.attributes.HSISpectralAttributes.band_mask" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">band_mask</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Returns a 1D band mask - a band mask with removed repeated dimensions (num_bands, ),
where num_bands is the number of bands in the hsi image.</p>
<p>The method selects the appropriate dimensions from the <code>band_mask</code> tensor
based on the <code>axis_to_select</code> and returns a flattened version of the selected
tensor.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: The flattened band mask tensor.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">band_names</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;R&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span> <span class="o">=</span> <span class="n">HSISpectralAttributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">score</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">band_mask</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">flattened_band_mask</span>
<span class="go">torch.tensor([0, 1, 2])</span>
</code></pre></div>
    </div>

</div>

<div class="doc doc-object doc-attribute">



<h4 id="src.meteors.attr.attributes.HSISpectralAttributes.flattened_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">flattened_attributes</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Returns a flattened tensor of attributes with removed repeated dimensions.</p>
<p>In the case of spectral attributes, the flattened attributes are 1D tensor of shape (num_bands, ), where num_bands is the number of bands in the hsi image.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: A flattened tensor of attributes.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
    </div>

</div>





  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.meteors.attr.lime.Lime" class="doc doc-heading">
            <code>Lime</code>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="meteors.attr.Explainer">Explainer</span></code></p>


        <p>Lime class is a subclass of Explainer and represents the Lime explainer. Lime is an interpretable model-agnostic
explanation method that explains the predictions of a black-box model by approximating it with a simpler
interpretable model. The Lime method is based on the <a href="https://captum.ai/api/lime.html"><code>captum</code> implementation</a>
and is an implementation of an idea coming from the <a href="https://arxiv.org/abs/1602.04938">original paper on Lime</a>,
where more details about this method can be found.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>explainable_model</code></td>
            <td>
                  <code><span title="meteors.utils.models.ExplainableModel">ExplainableModel</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The explainable model to be explained.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>interpretable_model</code></td>
            <td>
                  <code><span title="meteors.utils.models.InterpretableModel">InterpretableModel</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The interpretable model used to approximate the black-box model.
Defaults to <code>SkLearnLasso</code> with alpha parameter set to 0.08.</p>
              </div>
            </td>
            <td>
                  <code><span title="meteors.utils.models.SkLearnLasso">SkLearnLasso</span>(alpha=0.08)</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>similarity_func</code></td>
            <td>
                  <code><span title="typing_extensions.Callable">Callable</span>[[<span title="torch.Tensor">Tensor</span>], <span title="torch.Tensor">Tensor</span>] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The similarity function used by Lime.
Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>perturb_func</code></td>
            <td>
                  <code><span title="typing_extensions.Callable">Callable</span>[[<span title="torch.Tensor">Tensor</span>], <span title="torch.Tensor">Tensor</span>] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The perturbation function used by Lime.
Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>

              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/lime.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 297</span>
<span class="normal"> 298</span>
<span class="normal"> 299</span>
<span class="normal"> 300</span>
<span class="normal"> 301</span>
<span class="normal"> 302</span>
<span class="normal"> 303</span>
<span class="normal"> 304</span>
<span class="normal"> 305</span>
<span class="normal"> 306</span>
<span class="normal"> 307</span>
<span class="normal"> 308</span>
<span class="normal"> 309</span>
<span class="normal"> 310</span>
<span class="normal"> 311</span>
<span class="normal"> 312</span>
<span class="normal"> 313</span>
<span class="normal"> 314</span>
<span class="normal"> 315</span>
<span class="normal"> 316</span>
<span class="normal"> 317</span>
<span class="normal"> 318</span>
<span class="normal"> 319</span>
<span class="normal"> 320</span>
<span class="normal"> 321</span>
<span class="normal"> 322</span>
<span class="normal"> 323</span>
<span class="normal"> 324</span>
<span class="normal"> 325</span>
<span class="normal"> 326</span>
<span class="normal"> 327</span>
<span class="normal"> 328</span>
<span class="normal"> 329</span>
<span class="normal"> 330</span>
<span class="normal"> 331</span>
<span class="normal"> 332</span>
<span class="normal"> 333</span>
<span class="normal"> 334</span>
<span class="normal"> 335</span>
<span class="normal"> 336</span>
<span class="normal"> 337</span>
<span class="normal"> 338</span>
<span class="normal"> 339</span>
<span class="normal"> 340</span>
<span class="normal"> 341</span>
<span class="normal"> 342</span>
<span class="normal"> 343</span>
<span class="normal"> 344</span>
<span class="normal"> 345</span>
<span class="normal"> 346</span>
<span class="normal"> 347</span>
<span class="normal"> 348</span>
<span class="normal"> 349</span>
<span class="normal"> 350</span>
<span class="normal"> 351</span>
<span class="normal"> 352</span>
<span class="normal"> 353</span>
<span class="normal"> 354</span>
<span class="normal"> 355</span>
<span class="normal"> 356</span>
<span class="normal"> 357</span>
<span class="normal"> 358</span>
<span class="normal"> 359</span>
<span class="normal"> 360</span>
<span class="normal"> 361</span>
<span class="normal"> 362</span>
<span class="normal"> 363</span>
<span class="normal"> 364</span>
<span class="normal"> 365</span>
<span class="normal"> 366</span>
<span class="normal"> 367</span>
<span class="normal"> 368</span>
<span class="normal"> 369</span>
<span class="normal"> 370</span>
<span class="normal"> 371</span>
<span class="normal"> 372</span>
<span class="normal"> 373</span>
<span class="normal"> 374</span>
<span class="normal"> 375</span>
<span class="normal"> 376</span>
<span class="normal"> 377</span>
<span class="normal"> 378</span>
<span class="normal"> 379</span>
<span class="normal"> 380</span>
<span class="normal"> 381</span>
<span class="normal"> 382</span>
<span class="normal"> 383</span>
<span class="normal"> 384</span>
<span class="normal"> 385</span>
<span class="normal"> 386</span>
<span class="normal"> 387</span>
<span class="normal"> 388</span>
<span class="normal"> 389</span>
<span class="normal"> 390</span>
<span class="normal"> 391</span>
<span class="normal"> 392</span>
<span class="normal"> 393</span>
<span class="normal"> 394</span>
<span class="normal"> 395</span>
<span class="normal"> 396</span>
<span class="normal"> 397</span>
<span class="normal"> 398</span>
<span class="normal"> 399</span>
<span class="normal"> 400</span>
<span class="normal"> 401</span>
<span class="normal"> 402</span>
<span class="normal"> 403</span>
<span class="normal"> 404</span>
<span class="normal"> 405</span>
<span class="normal"> 406</span>
<span class="normal"> 407</span>
<span class="normal"> 408</span>
<span class="normal"> 409</span>
<span class="normal"> 410</span>
<span class="normal"> 411</span>
<span class="normal"> 412</span>
<span class="normal"> 413</span>
<span class="normal"> 414</span>
<span class="normal"> 415</span>
<span class="normal"> 416</span>
<span class="normal"> 417</span>
<span class="normal"> 418</span>
<span class="normal"> 419</span>
<span class="normal"> 420</span>
<span class="normal"> 421</span>
<span class="normal"> 422</span>
<span class="normal"> 423</span>
<span class="normal"> 424</span>
<span class="normal"> 425</span>
<span class="normal"> 426</span>
<span class="normal"> 427</span>
<span class="normal"> 428</span>
<span class="normal"> 429</span>
<span class="normal"> 430</span>
<span class="normal"> 431</span>
<span class="normal"> 432</span>
<span class="normal"> 433</span>
<span class="normal"> 434</span>
<span class="normal"> 435</span>
<span class="normal"> 436</span>
<span class="normal"> 437</span>
<span class="normal"> 438</span>
<span class="normal"> 439</span>
<span class="normal"> 440</span>
<span class="normal"> 441</span>
<span class="normal"> 442</span>
<span class="normal"> 443</span>
<span class="normal"> 444</span>
<span class="normal"> 445</span>
<span class="normal"> 446</span>
<span class="normal"> 447</span>
<span class="normal"> 448</span>
<span class="normal"> 449</span>
<span class="normal"> 450</span>
<span class="normal"> 451</span>
<span class="normal"> 452</span>
<span class="normal"> 453</span>
<span class="normal"> 454</span>
<span class="normal"> 455</span>
<span class="normal"> 456</span>
<span class="normal"> 457</span>
<span class="normal"> 458</span>
<span class="normal"> 459</span>
<span class="normal"> 460</span>
<span class="normal"> 461</span>
<span class="normal"> 462</span>
<span class="normal"> 463</span>
<span class="normal"> 464</span>
<span class="normal"> 465</span>
<span class="normal"> 466</span>
<span class="normal"> 467</span>
<span class="normal"> 468</span>
<span class="normal"> 469</span>
<span class="normal"> 470</span>
<span class="normal"> 471</span>
<span class="normal"> 472</span>
<span class="normal"> 473</span>
<span class="normal"> 474</span>
<span class="normal"> 475</span>
<span class="normal"> 476</span>
<span class="normal"> 477</span>
<span class="normal"> 478</span>
<span class="normal"> 479</span>
<span class="normal"> 480</span>
<span class="normal"> 481</span>
<span class="normal"> 482</span>
<span class="normal"> 483</span>
<span class="normal"> 484</span>
<span class="normal"> 485</span>
<span class="normal"> 486</span>
<span class="normal"> 487</span>
<span class="normal"> 488</span>
<span class="normal"> 489</span>
<span class="normal"> 490</span>
<span class="normal"> 491</span>
<span class="normal"> 492</span>
<span class="normal"> 493</span>
<span class="normal"> 494</span>
<span class="normal"> 495</span>
<span class="normal"> 496</span>
<span class="normal"> 497</span>
<span class="normal"> 498</span>
<span class="normal"> 499</span>
<span class="normal"> 500</span>
<span class="normal"> 501</span>
<span class="normal"> 502</span>
<span class="normal"> 503</span>
<span class="normal"> 504</span>
<span class="normal"> 505</span>
<span class="normal"> 506</span>
<span class="normal"> 507</span>
<span class="normal"> 508</span>
<span class="normal"> 509</span>
<span class="normal"> 510</span>
<span class="normal"> 511</span>
<span class="normal"> 512</span>
<span class="normal"> 513</span>
<span class="normal"> 514</span>
<span class="normal"> 515</span>
<span class="normal"> 516</span>
<span class="normal"> 517</span>
<span class="normal"> 518</span>
<span class="normal"> 519</span>
<span class="normal"> 520</span>
<span class="normal"> 521</span>
<span class="normal"> 522</span>
<span class="normal"> 523</span>
<span class="normal"> 524</span>
<span class="normal"> 525</span>
<span class="normal"> 526</span>
<span class="normal"> 527</span>
<span class="normal"> 528</span>
<span class="normal"> 529</span>
<span class="normal"> 530</span>
<span class="normal"> 531</span>
<span class="normal"> 532</span>
<span class="normal"> 533</span>
<span class="normal"> 534</span>
<span class="normal"> 535</span>
<span class="normal"> 536</span>
<span class="normal"> 537</span>
<span class="normal"> 538</span>
<span class="normal"> 539</span>
<span class="normal"> 540</span>
<span class="normal"> 541</span>
<span class="normal"> 542</span>
<span class="normal"> 543</span>
<span class="normal"> 544</span>
<span class="normal"> 545</span>
<span class="normal"> 546</span>
<span class="normal"> 547</span>
<span class="normal"> 548</span>
<span class="normal"> 549</span>
<span class="normal"> 550</span>
<span class="normal"> 551</span>
<span class="normal"> 552</span>
<span class="normal"> 553</span>
<span class="normal"> 554</span>
<span class="normal"> 555</span>
<span class="normal"> 556</span>
<span class="normal"> 557</span>
<span class="normal"> 558</span>
<span class="normal"> 559</span>
<span class="normal"> 560</span>
<span class="normal"> 561</span>
<span class="normal"> 562</span>
<span class="normal"> 563</span>
<span class="normal"> 564</span>
<span class="normal"> 565</span>
<span class="normal"> 566</span>
<span class="normal"> 567</span>
<span class="normal"> 568</span>
<span class="normal"> 569</span>
<span class="normal"> 570</span>
<span class="normal"> 571</span>
<span class="normal"> 572</span>
<span class="normal"> 573</span>
<span class="normal"> 574</span>
<span class="normal"> 575</span>
<span class="normal"> 576</span>
<span class="normal"> 577</span>
<span class="normal"> 578</span>
<span class="normal"> 579</span>
<span class="normal"> 580</span>
<span class="normal"> 581</span>
<span class="normal"> 582</span>
<span class="normal"> 583</span>
<span class="normal"> 584</span>
<span class="normal"> 585</span>
<span class="normal"> 586</span>
<span class="normal"> 587</span>
<span class="normal"> 588</span>
<span class="normal"> 589</span>
<span class="normal"> 590</span>
<span class="normal"> 591</span>
<span class="normal"> 592</span>
<span class="normal"> 593</span>
<span class="normal"> 594</span>
<span class="normal"> 595</span>
<span class="normal"> 596</span>
<span class="normal"> 597</span>
<span class="normal"> 598</span>
<span class="normal"> 599</span>
<span class="normal"> 600</span>
<span class="normal"> 601</span>
<span class="normal"> 602</span>
<span class="normal"> 603</span>
<span class="normal"> 604</span>
<span class="normal"> 605</span>
<span class="normal"> 606</span>
<span class="normal"> 607</span>
<span class="normal"> 608</span>
<span class="normal"> 609</span>
<span class="normal"> 610</span>
<span class="normal"> 611</span>
<span class="normal"> 612</span>
<span class="normal"> 613</span>
<span class="normal"> 614</span>
<span class="normal"> 615</span>
<span class="normal"> 616</span>
<span class="normal"> 617</span>
<span class="normal"> 618</span>
<span class="normal"> 619</span>
<span class="normal"> 620</span>
<span class="normal"> 621</span>
<span class="normal"> 622</span>
<span class="normal"> 623</span>
<span class="normal"> 624</span>
<span class="normal"> 625</span>
<span class="normal"> 626</span>
<span class="normal"> 627</span>
<span class="normal"> 628</span>
<span class="normal"> 629</span>
<span class="normal"> 630</span>
<span class="normal"> 631</span>
<span class="normal"> 632</span>
<span class="normal"> 633</span>
<span class="normal"> 634</span>
<span class="normal"> 635</span>
<span class="normal"> 636</span>
<span class="normal"> 637</span>
<span class="normal"> 638</span>
<span class="normal"> 639</span>
<span class="normal"> 640</span>
<span class="normal"> 641</span>
<span class="normal"> 642</span>
<span class="normal"> 643</span>
<span class="normal"> 644</span>
<span class="normal"> 645</span>
<span class="normal"> 646</span>
<span class="normal"> 647</span>
<span class="normal"> 648</span>
<span class="normal"> 649</span>
<span class="normal"> 650</span>
<span class="normal"> 651</span>
<span class="normal"> 652</span>
<span class="normal"> 653</span>
<span class="normal"> 654</span>
<span class="normal"> 655</span>
<span class="normal"> 656</span>
<span class="normal"> 657</span>
<span class="normal"> 658</span>
<span class="normal"> 659</span>
<span class="normal"> 660</span>
<span class="normal"> 661</span>
<span class="normal"> 662</span>
<span class="normal"> 663</span>
<span class="normal"> 664</span>
<span class="normal"> 665</span>
<span class="normal"> 666</span>
<span class="normal"> 667</span>
<span class="normal"> 668</span>
<span class="normal"> 669</span>
<span class="normal"> 670</span>
<span class="normal"> 671</span>
<span class="normal"> 672</span>
<span class="normal"> 673</span>
<span class="normal"> 674</span>
<span class="normal"> 675</span>
<span class="normal"> 676</span>
<span class="normal"> 677</span>
<span class="normal"> 678</span>
<span class="normal"> 679</span>
<span class="normal"> 680</span>
<span class="normal"> 681</span>
<span class="normal"> 682</span>
<span class="normal"> 683</span>
<span class="normal"> 684</span>
<span class="normal"> 685</span>
<span class="normal"> 686</span>
<span class="normal"> 687</span>
<span class="normal"> 688</span>
<span class="normal"> 689</span>
<span class="normal"> 690</span>
<span class="normal"> 691</span>
<span class="normal"> 692</span>
<span class="normal"> 693</span>
<span class="normal"> 694</span>
<span class="normal"> 695</span>
<span class="normal"> 696</span>
<span class="normal"> 697</span>
<span class="normal"> 698</span>
<span class="normal"> 699</span>
<span class="normal"> 700</span>
<span class="normal"> 701</span>
<span class="normal"> 702</span>
<span class="normal"> 703</span>
<span class="normal"> 704</span>
<span class="normal"> 705</span>
<span class="normal"> 706</span>
<span class="normal"> 707</span>
<span class="normal"> 708</span>
<span class="normal"> 709</span>
<span class="normal"> 710</span>
<span class="normal"> 711</span>
<span class="normal"> 712</span>
<span class="normal"> 713</span>
<span class="normal"> 714</span>
<span class="normal"> 715</span>
<span class="normal"> 716</span>
<span class="normal"> 717</span>
<span class="normal"> 718</span>
<span class="normal"> 719</span>
<span class="normal"> 720</span>
<span class="normal"> 721</span>
<span class="normal"> 722</span>
<span class="normal"> 723</span>
<span class="normal"> 724</span>
<span class="normal"> 725</span>
<span class="normal"> 726</span>
<span class="normal"> 727</span>
<span class="normal"> 728</span>
<span class="normal"> 729</span>
<span class="normal"> 730</span>
<span class="normal"> 731</span>
<span class="normal"> 732</span>
<span class="normal"> 733</span>
<span class="normal"> 734</span>
<span class="normal"> 735</span>
<span class="normal"> 736</span>
<span class="normal"> 737</span>
<span class="normal"> 738</span>
<span class="normal"> 739</span>
<span class="normal"> 740</span>
<span class="normal"> 741</span>
<span class="normal"> 742</span>
<span class="normal"> 743</span>
<span class="normal"> 744</span>
<span class="normal"> 745</span>
<span class="normal"> 746</span>
<span class="normal"> 747</span>
<span class="normal"> 748</span>
<span class="normal"> 749</span>
<span class="normal"> 750</span>
<span class="normal"> 751</span>
<span class="normal"> 752</span>
<span class="normal"> 753</span>
<span class="normal"> 754</span>
<span class="normal"> 755</span>
<span class="normal"> 756</span>
<span class="normal"> 757</span>
<span class="normal"> 758</span>
<span class="normal"> 759</span>
<span class="normal"> 760</span>
<span class="normal"> 761</span>
<span class="normal"> 762</span>
<span class="normal"> 763</span>
<span class="normal"> 764</span>
<span class="normal"> 765</span>
<span class="normal"> 766</span>
<span class="normal"> 767</span>
<span class="normal"> 768</span>
<span class="normal"> 769</span>
<span class="normal"> 770</span>
<span class="normal"> 771</span>
<span class="normal"> 772</span>
<span class="normal"> 773</span>
<span class="normal"> 774</span>
<span class="normal"> 775</span>
<span class="normal"> 776</span>
<span class="normal"> 777</span>
<span class="normal"> 778</span>
<span class="normal"> 779</span>
<span class="normal"> 780</span>
<span class="normal"> 781</span>
<span class="normal"> 782</span>
<span class="normal"> 783</span>
<span class="normal"> 784</span>
<span class="normal"> 785</span>
<span class="normal"> 786</span>
<span class="normal"> 787</span>
<span class="normal"> 788</span>
<span class="normal"> 789</span>
<span class="normal"> 790</span>
<span class="normal"> 791</span>
<span class="normal"> 792</span>
<span class="normal"> 793</span>
<span class="normal"> 794</span>
<span class="normal"> 795</span>
<span class="normal"> 796</span>
<span class="normal"> 797</span>
<span class="normal"> 798</span>
<span class="normal"> 799</span>
<span class="normal"> 800</span>
<span class="normal"> 801</span>
<span class="normal"> 802</span>
<span class="normal"> 803</span>
<span class="normal"> 804</span>
<span class="normal"> 805</span>
<span class="normal"> 806</span>
<span class="normal"> 807</span>
<span class="normal"> 808</span>
<span class="normal"> 809</span>
<span class="normal"> 810</span>
<span class="normal"> 811</span>
<span class="normal"> 812</span>
<span class="normal"> 813</span>
<span class="normal"> 814</span>
<span class="normal"> 815</span>
<span class="normal"> 816</span>
<span class="normal"> 817</span>
<span class="normal"> 818</span>
<span class="normal"> 819</span>
<span class="normal"> 820</span>
<span class="normal"> 821</span>
<span class="normal"> 822</span>
<span class="normal"> 823</span>
<span class="normal"> 824</span>
<span class="normal"> 825</span>
<span class="normal"> 826</span>
<span class="normal"> 827</span>
<span class="normal"> 828</span>
<span class="normal"> 829</span>
<span class="normal"> 830</span>
<span class="normal"> 831</span>
<span class="normal"> 832</span>
<span class="normal"> 833</span>
<span class="normal"> 834</span>
<span class="normal"> 835</span>
<span class="normal"> 836</span>
<span class="normal"> 837</span>
<span class="normal"> 838</span>
<span class="normal"> 839</span>
<span class="normal"> 840</span>
<span class="normal"> 841</span>
<span class="normal"> 842</span>
<span class="normal"> 843</span>
<span class="normal"> 844</span>
<span class="normal"> 845</span>
<span class="normal"> 846</span>
<span class="normal"> 847</span>
<span class="normal"> 848</span>
<span class="normal"> 849</span>
<span class="normal"> 850</span>
<span class="normal"> 851</span>
<span class="normal"> 852</span>
<span class="normal"> 853</span>
<span class="normal"> 854</span>
<span class="normal"> 855</span>
<span class="normal"> 856</span>
<span class="normal"> 857</span>
<span class="normal"> 858</span>
<span class="normal"> 859</span>
<span class="normal"> 860</span>
<span class="normal"> 861</span>
<span class="normal"> 862</span>
<span class="normal"> 863</span>
<span class="normal"> 864</span>
<span class="normal"> 865</span>
<span class="normal"> 866</span>
<span class="normal"> 867</span>
<span class="normal"> 868</span>
<span class="normal"> 869</span>
<span class="normal"> 870</span>
<span class="normal"> 871</span>
<span class="normal"> 872</span>
<span class="normal"> 873</span>
<span class="normal"> 874</span>
<span class="normal"> 875</span>
<span class="normal"> 876</span>
<span class="normal"> 877</span>
<span class="normal"> 878</span>
<span class="normal"> 879</span>
<span class="normal"> 880</span>
<span class="normal"> 881</span>
<span class="normal"> 882</span>
<span class="normal"> 883</span>
<span class="normal"> 884</span>
<span class="normal"> 885</span>
<span class="normal"> 886</span>
<span class="normal"> 887</span>
<span class="normal"> 888</span>
<span class="normal"> 889</span>
<span class="normal"> 890</span>
<span class="normal"> 891</span>
<span class="normal"> 892</span>
<span class="normal"> 893</span>
<span class="normal"> 894</span>
<span class="normal"> 895</span>
<span class="normal"> 896</span>
<span class="normal"> 897</span>
<span class="normal"> 898</span>
<span class="normal"> 899</span>
<span class="normal"> 900</span>
<span class="normal"> 901</span>
<span class="normal"> 902</span>
<span class="normal"> 903</span>
<span class="normal"> 904</span>
<span class="normal"> 905</span>
<span class="normal"> 906</span>
<span class="normal"> 907</span>
<span class="normal"> 908</span>
<span class="normal"> 909</span>
<span class="normal"> 910</span>
<span class="normal"> 911</span>
<span class="normal"> 912</span>
<span class="normal"> 913</span>
<span class="normal"> 914</span>
<span class="normal"> 915</span>
<span class="normal"> 916</span>
<span class="normal"> 917</span>
<span class="normal"> 918</span>
<span class="normal"> 919</span>
<span class="normal"> 920</span>
<span class="normal"> 921</span>
<span class="normal"> 922</span>
<span class="normal"> 923</span>
<span class="normal"> 924</span>
<span class="normal"> 925</span>
<span class="normal"> 926</span>
<span class="normal"> 927</span>
<span class="normal"> 928</span>
<span class="normal"> 929</span>
<span class="normal"> 930</span>
<span class="normal"> 931</span>
<span class="normal"> 932</span>
<span class="normal"> 933</span>
<span class="normal"> 934</span>
<span class="normal"> 935</span>
<span class="normal"> 936</span>
<span class="normal"> 937</span>
<span class="normal"> 938</span>
<span class="normal"> 939</span>
<span class="normal"> 940</span>
<span class="normal"> 941</span>
<span class="normal"> 942</span>
<span class="normal"> 943</span>
<span class="normal"> 944</span>
<span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Lime</span><span class="p">(</span><span class="n">Explainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Lime class is a subclass of Explainer and represents the Lime explainer. Lime is an interpretable model-agnostic</span>
<span class="sd">    explanation method that explains the predictions of a black-box model by approximating it with a simpler</span>
<span class="sd">    interpretable model. The Lime method is based on the [`captum` implementation](https://captum.ai/api/lime.html)</span>
<span class="sd">    and is an implementation of an idea coming from the [original paper on Lime](https://arxiv.org/abs/1602.04938),</span>
<span class="sd">    where more details about this method can be found.</span>

<span class="sd">    Args:</span>
<span class="sd">        explainable_model (ExplainableModel): The explainable model to be explained.</span>
<span class="sd">        interpretable_model (InterpretableModel): The interpretable model used to approximate the black-box model.</span>
<span class="sd">            Defaults to `SkLearnLasso` with alpha parameter set to 0.08.</span>
<span class="sd">        similarity_func (Callable[[torch.Tensor], torch.Tensor] | None, optional): The similarity function used by Lime.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        perturb_func (Callable[[torch.Tensor], torch.Tensor] | None, optional): The perturbation function used by Lime.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">explainable_model</span><span class="p">:</span> <span class="n">ExplainableModel</span><span class="p">,</span>
        <span class="n">interpretable_model</span><span class="p">:</span> <span class="n">InterpretableModel</span> <span class="o">=</span> <span class="n">SkLearnLasso</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.08</span><span class="p">),</span>
        <span class="n">similarity_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">perturb_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">explainable_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpretable_model</span> <span class="o">=</span> <span class="n">interpretable_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="p">:</span> <span class="n">LimeBase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_lime</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">explainable_model</span><span class="o">.</span><span class="n">forward_func</span><span class="p">,</span> <span class="n">interpretable_model</span><span class="p">,</span> <span class="n">similarity_func</span><span class="p">,</span> <span class="n">perturb_func</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_construct_lime</span><span class="p">(</span>
        <span class="n">forward_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
        <span class="n">interpretable_model</span><span class="p">:</span> <span class="n">InterpretableModel</span><span class="p">,</span>
        <span class="n">similarity_func</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">perturb_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LimeBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructs the LimeBase object.</span>

<span class="sd">        Args:</span>
<span class="sd">            forward_func (Callable[[torch.Tensor], torch.Tensor]): The forward function of the explainable model.</span>
<span class="sd">            interpretable_model (InterpretableModel): The interpretable model used to approximate the black-box model.</span>
<span class="sd">            similarity_func (Callable | None): The similarity function used by Lime.</span>
<span class="sd">            perturb_func (Callable[[torch.Tensor], torch.Tensor] | None): The perturbation function used by Lime.</span>

<span class="sd">        Returns:</span>
<span class="sd">            LimeBase: The constructed LimeBase object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">LimeBase</span><span class="p">(</span>
            <span class="n">forward_func</span><span class="o">=</span><span class="n">forward_func</span><span class="p">,</span>
            <span class="n">interpretable_model</span><span class="o">=</span><span class="n">interpretable_model</span><span class="p">,</span>
            <span class="n">similarity_func</span><span class="o">=</span><span class="n">similarity_func</span><span class="p">,</span>
            <span class="n">perturb_func</span><span class="o">=</span><span class="n">perturb_func</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_segmentation_mask</span><span class="p">(</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">segmentation_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;patch&quot;</span><span class="p">,</span> <span class="s2">&quot;slic&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;slic&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generates a segmentation mask for the given hsi using the specified segmentation method.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): The input hyperspectral image for which the segmentation mask needs to be generated.</span>
<span class="sd">            segmentation_method (Literal[&quot;patch&quot;, &quot;slic&quot;], optional): The segmentation method to be used.</span>
<span class="sd">                Defaults to &quot;slic&quot;.</span>
<span class="sd">            **segmentation_method_params (Any): Additional parameters specific to the chosen segmentation method.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The segmentation mask as a tensor.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the input hsi is not an instance of the HSI class.</span>
<span class="sd">            ValueError: If an unsupported segmentation method is specified.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi = meteors.HSI(image=torch.ones((3, 240, 240)), wavelengths=[462.08, 465.27, 468.47])</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask = mt_lime.Lime.get_segmentation_mask(hsi, segmentation_method=&quot;slic&quot;)</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask.shape</span>
<span class="sd">            torch.Size([1, 240, 240])</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask = meteors.attr.Lime.get_segmentation_mask(hsi, segmentation_method=&quot;patch&quot;, patch_size=2)</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask.shape</span>
<span class="sd">            torch.Size([1, 240, 240])</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask[0, :2, :2]</span>
<span class="sd">            torch.tensor([[1, 1],</span>
<span class="sd">                          [1, 1]])</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask[0, 2:4, :2]</span>
<span class="sd">            torch.tensor([[2, 2],</span>
<span class="sd">                          [2, 2]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;hsi should be an instance of HSI class&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">segmentation_method</span> <span class="o">==</span> <span class="s2">&quot;slic&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_slick_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">segmentation_method</span> <span class="o">==</span> <span class="s2">&quot;patch&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_patch_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported segmentation method: </span><span class="si">{</span><span class="n">segmentation_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_band_mask</span><span class="p">(</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">band_names</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">band_indices</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ListOfWavelengthsIndices</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">band_wavelengths</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ListOfWavelengths</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">repeat_dimensions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generates a band mask based on the provided hsi and band information.</span>

<span class="sd">        Remember you need to provide either band_names, band_indices, or band_wavelengths to create the band mask.</span>
<span class="sd">        If you provide more than one, the band mask will be created using only one using the following priority:</span>
<span class="sd">        band_names &gt; band_wavelengths &gt; band_indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): The input hyperspectral image.</span>
<span class="sd">            band_names (None | list[str | list[str]] | dict[tuple[str, ...] | str, int], optional):</span>
<span class="sd">                The names of the spectral bands to include in the mask. Defaults to None.</span>
<span class="sd">            band_indices (None | dict[str | tuple[str, ...], list[tuple[int, int]] | tuple[int, int] | list[int]], optional):</span>
<span class="sd">                The indices or ranges of indices of the spectral bands to include in the mask. Defaults to None.</span>
<span class="sd">            band_wavelengths (None | dict[str | tuple[str, ...], list[tuple[float, float]] | tuple[float, float], list[float], float], optional):</span>
<span class="sd">                The wavelengths or ranges of wavelengths of the spectral bands to include in the mask. Defaults to None.</span>
<span class="sd">            device (str | torch.device | None, optional):</span>
<span class="sd">                The device to use for computation. Defaults to None.</span>
<span class="sd">            repeat_dimensions (bool, optional):</span>
<span class="sd">                Whether to repeat the dimensions of the mask to match the input hsi shape. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[torch.Tensor, dict[tuple[str, ...] | str, int]]: A tuple containing the band mask tensor and a dictionary</span>
<span class="sd">            mapping band names to segment IDs.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the input hsi is not an instance of the HSI class.</span>
<span class="sd">            ValueError: If no band names, indices, or wavelengths are provided.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((len(wavelengths), 10, 10)), wavelengths=wavelengths)</span>
<span class="sd">            &gt;&gt;&gt; band_names = [&quot;R&quot;, &quot;G&quot;]</span>
<span class="sd">            &gt;&gt;&gt; band_mask, dict_labels_to_segment_ids = mt_lime.Lime.get_band_mask(hsi, band_names=band_names)</span>
<span class="sd">            &gt;&gt;&gt; dict_labels_to_segment_ids</span>
<span class="sd">            {&quot;R&quot;: 1, &quot;G&quot;: 2}</span>
<span class="sd">            &gt;&gt;&gt; band_indices = {&quot;RGB&quot;: [0, 1, 2]}</span>
<span class="sd">            &gt;&gt;&gt; band_mask, dict_labels_to_segment_ids = mt_lime.Lime.get_band_mask(hsi, band_indices=band_indices)</span>
<span class="sd">            &gt;&gt;&gt; dict_labels_to_segment_ids</span>
<span class="sd">            {&quot;RGB&quot;: 1}</span>
<span class="sd">            &gt;&gt;&gt; band_wavelengths = {&quot;RGB&quot;: [(462.08, 465.27), (465.27, 468.47), (468.47, 471.68)]}</span>
<span class="sd">            &gt;&gt;&gt; band_mask, dict_labels_to_segment_ids = mt_lime.Lime.get_band_mask(hsi, band_wavelengths=band_wavelengths)</span>
<span class="sd">            &gt;&gt;&gt; dict_labels_to_segment_ids</span>
<span class="sd">            {&quot;RGB&quot;: 1}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;hsi should be an instance of HSI class&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">band_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">band_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;No band names, indices, or wavelengths are provided.&quot;</span>

        <span class="c1"># validate types</span>
        <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">band_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting band mask from band names of spectral bands&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">band_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ignored_params</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">param</span>
                    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;band_wavelengths&quot;</span><span class="p">,</span> <span class="s2">&quot;band_indices&quot;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">param</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="p">]</span>
                <span class="n">ignored_params_str</span> <span class="o">=</span> <span class="s2">&quot; and &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ignored_params</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Only the band names will be used to create the band mask. The additional parameters </span><span class="si">{</span><span class="n">ignored_params_str</span><span class="si">}</span><span class="s2"> will be ignored.&quot;</span>
                <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">validate_band_names</span><span class="p">(</span><span class="n">band_names</span><span class="p">)</span>
                <span class="n">band_groups</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_band_wavelengths_indices_from_band_names</span><span class="p">(</span>
                    <span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">band_names</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Incorrect band names provided: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
        <span class="k">elif</span> <span class="n">band_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting band mask from band groups given by ranges of wavelengths&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Only the band wavelengths will be used to create the band mask. The band_indices will be ignored.&quot;</span>
                <span class="p">)</span>
            <span class="n">validate_band_format</span><span class="p">(</span><span class="n">band_wavelengths</span><span class="p">,</span> <span class="n">variable_name</span><span class="o">=</span><span class="s2">&quot;band_wavelengths&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">band_groups</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_band_indices_from_band_wavelengths</span><span class="p">(</span>
                    <span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span>
                    <span class="n">band_wavelengths</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Incorrect band ranges wavelengths provided, please check if provided wavelengths are correct: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
        <span class="k">elif</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting band mask from band groups given by ranges of indices&quot;</span><span class="p">)</span>
            <span class="n">validate_band_format</span><span class="p">(</span><span class="n">band_indices</span><span class="p">,</span> <span class="n">variable_name</span><span class="o">=</span><span class="s2">&quot;band_indices&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">band_groups</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_band_indices_from_input_band_indices</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">band_indices</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Incorrect band ranges indices provided, please check if provided indices are correct: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">return</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_create_tensor_band_mask</span><span class="p">(</span>
            <span class="n">hsi</span><span class="p">,</span>
            <span class="n">band_groups</span><span class="p">,</span>
            <span class="n">dict_labels_to_segment_ids</span><span class="o">=</span><span class="n">dict_labels_to_segment_ids</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
            <span class="n">repeat_dimensions</span><span class="o">=</span><span class="n">repeat_dimensions</span><span class="p">,</span>
            <span class="n">return_dict_labels_to_segment_ids</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_make_band_names_indexable</span><span class="p">(</span><span class="n">segment_name</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts a list of strings into a tuple of strings if necessary to make it indexable.</span>

<span class="sd">        Args:</span>
<span class="sd">            segment_name (list[str] | tuple[str, ...] | str): The segment name to be converted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[str, ...] | str: The converted segment name.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the segment_name is not of type list or string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment_name</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">subitem</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">subitem</span> <span class="ow">in</span> <span class="n">segment_name</span><span class="p">)</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">segment_name</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">subitem</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">subitem</span> <span class="ow">in</span> <span class="n">segment_name</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">segment_name</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Incorrect segment </span><span class="si">{</span><span class="n">segment_name</span><span class="si">}</span><span class="s2"> type. Should be either a list or string&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="c1"># @lru_cache(maxsize=32) Can&#39;t use with lists as they are not hashable</span>
    <span class="k">def</span> <span class="nf">_extract_bands_from_spyndex</span><span class="p">(</span><span class="n">segment_name</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts bands from the given segment name.</span>

<span class="sd">        Args:</span>
<span class="sd">            segment_name (list[str] | tuple[str, ...] | str): The name of the segment.</span>
<span class="sd">                Users may pass either band names or indices names, as in the spyndex library.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[str, ...] | str: A tuple of band names if multiple bands are extracted,</span>
<span class="sd">                or a single band name if only one band is extracted.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the provided band name is invalid.</span>
<span class="sd">                The band name must be either in `spyndex.indices` or `spyndex.bands`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">segment_name</span> <span class="o">=</span> <span class="p">(</span><span class="n">segment_name</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">segment_name</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">segment_name</span><span class="p">)</span>

        <span class="n">band_names_segment</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="n">segment_name</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="n">spyndex</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
                <span class="n">band_names_segment</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spyndex</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">bands</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="n">spyndex</span><span class="o">.</span><span class="n">bands</span><span class="p">:</span>
                <span class="n">band_names_segment</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">band_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Invalid band name </span><span class="si">{</span><span class="n">band_name</span><span class="si">}</span><span class="s2">, band name must be either in `spyndex.indices` or `spyndex.bands`&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">band_names_segment</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_names_segment</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">band_names_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_indices_from_wavelength_indices_range</span><span class="p">(</span>
        <span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">ranges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts wavelength indices ranges to list indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            wavelengths (torch.Tensor): The tensor containing the wavelengths.</span>
<span class="sd">            ranges (list[tuple[int, int]] | tuple[int, int]): The wavelength indices ranges.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[int]: The indices of bands corresponding to the wavelength indices ranges.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validated_ranges_list</span> <span class="o">=</span> <span class="n">validate_segment_format</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span>
        <span class="n">validated_ranges_list</span> <span class="o">=</span> <span class="n">adjust_and_validate_segment_ranges</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">validated_ranges_list</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span>
                <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">validated_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">validated_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span> <span class="k">for</span> <span class="n">validated_range</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_band_wavelengths_indices_from_band_names</span><span class="p">(</span>
        <span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">band_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts band wavelengths indices from the given band names.</span>

<span class="sd">        This function takes a list or dictionary of band names or segments and extracts the list of wavelengths indices</span>
<span class="sd">        associated with each segment. It returns a tuple containing a dictionary with mapping segment labels into</span>
<span class="sd">        wavelength indices and a dictionary mapping segment labels into segment ids.</span>

<span class="sd">        Args:</span>
<span class="sd">            wavelengths (torch.Tensor): The tensor containing the wavelengths.</span>
<span class="sd">            band_names (list[str | list[str]] | dict[tuple[str, ...] | str, int]):</span>
<span class="sd">                A list or dictionary with band names or segments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[dict[tuple[str, ...] | str, list[int]], dict[tuple[str, ...] | str, int]]:</span>
<span class="sd">                A tuple containing the dictionary with mapping segment labels into wavelength indices and the mapping</span>
<span class="sd">                from segment labels into segment ids.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">band_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">band_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;band_names is a list of segments, creating a dictionary of segments&quot;</span><span class="p">)</span>
            <span class="n">band_names_hashed</span> <span class="o">=</span> <span class="p">[</span><span class="n">Lime</span><span class="o">.</span><span class="n">_make_band_names_indexable</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span> <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">band_names</span><span class="p">]</span>
            <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="p">{</span><span class="n">segment</span><span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">band_names_hashed</span><span class="p">)}</span>
            <span class="n">segments_list</span> <span class="o">=</span> <span class="n">band_names_hashed</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_names</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">band_names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">segments_list</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">band_names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>  <span class="c1"># type: ignore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incorrect band_names type. It should be a dict or a list&quot;</span><span class="p">)</span>
        <span class="n">segments_list_after_mapping</span> <span class="o">=</span> <span class="p">[</span><span class="n">Lime</span><span class="o">.</span><span class="n">_extract_bands_from_spyndex</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span> <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments_list</span><span class="p">]</span>
        <span class="n">band_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">original_segment</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">segments_list</span><span class="p">,</span> <span class="n">segments_list_after_mapping</span><span class="p">):</span>
            <span class="n">segment_indices_ranges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">segment</span> <span class="o">=</span> <span class="p">(</span><span class="n">segment</span><span class="p">,)</span>
            <span class="k">for</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="n">segment</span><span class="p">:</span>
                <span class="n">min_wavelength</span> <span class="o">=</span> <span class="n">spyndex</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">min_wavelength</span>
                <span class="n">max_wavelength</span> <span class="o">=</span> <span class="n">spyndex</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">max_wavelength</span>

                <span class="k">if</span> <span class="n">min_wavelength</span> <span class="o">&gt;</span> <span class="n">wavelengths</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="ow">or</span> <span class="n">max_wavelength</span> <span class="o">&lt;</span> <span class="n">wavelengths</span><span class="o">.</span><span class="n">min</span><span class="p">():</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Band </span><span class="si">{</span><span class="n">band_name</span><span class="si">}</span><span class="s2"> is not present in the given wavelengths. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Band ranges from </span><span class="si">{</span><span class="n">min_wavelength</span><span class="si">}</span><span class="s2"> nm to </span><span class="si">{</span><span class="n">max_wavelength</span><span class="si">}</span><span class="s2"> nm and the HSI wavelengths &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;range from </span><span class="si">{</span><span class="n">wavelengths</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> nm to </span><span class="si">{</span><span class="n">wavelengths</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> nm. The given band will be skipped&quot;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">segment_indices_ranges</span> <span class="o">+=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_convert_wavelengths_to_indices</span><span class="p">(</span>
                        <span class="n">wavelengths</span><span class="p">,</span>
                        <span class="p">(</span><span class="n">spyndex</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">min_wavelength</span><span class="p">,</span> <span class="n">spyndex</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">max_wavelength</span><span class="p">),</span>
                    <span class="p">)</span>

            <span class="n">segment_list</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_indices_from_wavelength_indices_range</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">segment_indices_ranges</span><span class="p">)</span>
            <span class="n">band_indices</span><span class="p">[</span><span class="n">original_segment</span><span class="p">]</span> <span class="o">=</span> <span class="n">segment_list</span>
        <span class="k">return</span> <span class="n">band_indices</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_convert_wavelengths_to_indices</span><span class="p">(</span>
        <span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">ranges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts wavelength ranges to index ranges.</span>

<span class="sd">        Args:</span>
<span class="sd">            wavelengths (torch.Tensor): The tensor containing the wavelengths.</span>
<span class="sd">            ranges (list[tuple[float, float]] | tuple[float, float]): The wavelength ranges.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[tuple[int, int]]: The index ranges corresponding to the wavelength ranges.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ranges</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">ranges</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="n">start_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
            <span class="n">end_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start_idx</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">end_idx</span><span class="o">.</span><span class="n">item</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">indices</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_band_indices_from_band_wavelengths</span><span class="p">(</span>
        <span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">band_wavelengths</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ListOfWavelengths</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts the ranges or list of wavelengths into indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            wavelengths (torch.Tensor): The tensor containing the wavelengths.</span>
<span class="sd">            band_wavelengths (dict): A dictionary mapping segment labels to wavelength list or ranges.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: A dictionary mapping segment labels to index ranges.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If band_wavelengths is not a dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_wavelengths</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;band_wavelengths should be a dictionary&quot;</span><span class="p">)</span>

        <span class="n">band_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">segment_label</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">band_wavelengths</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch_dtype_to_python_dtype</span><span class="p">(</span><span class="n">wavelengths</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                    <span class="n">segment</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtype</span><span class="p">(</span><span class="n">segment</span><span class="p">)]</span>  <span class="c1"># type: ignore</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">segment</span><span class="p">):</span>
                    <span class="n">segment_dtype</span> <span class="o">=</span> <span class="n">change_dtype_of_list</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_convert_wavelengths_list_to_indices</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">segment_dtype</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">segment_dtype</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="nb">tuple</span><span class="p">(</span><span class="n">change_dtype_of_list</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ranges</span><span class="p">),</span> <span class="n">dtype</span><span class="p">))</span>  <span class="c1"># type: ignore</span>
                            <span class="k">for</span> <span class="n">ranges</span> <span class="ow">in</span> <span class="n">segment</span>
                        <span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">segment_dtype</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">change_dtype_of_list</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">dtype</span><span class="p">))</span>

                    <span class="n">valid_segment_range</span> <span class="o">=</span> <span class="n">validate_segment_format</span><span class="p">(</span><span class="n">segment_dtype</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
                    <span class="n">range_indices</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_convert_wavelengths_to_indices</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">valid_segment_range</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                    <span class="n">valid_indices_format</span> <span class="o">=</span> <span class="n">validate_segment_format</span><span class="p">(</span><span class="n">range_indices</span><span class="p">)</span>
                    <span class="n">valid_range_indices</span> <span class="o">=</span> <span class="n">adjust_and_validate_segment_ranges</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">valid_indices_format</span><span class="p">)</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_indices_from_wavelength_indices_range</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">valid_range_indices</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Problem with segment </span><span class="si">{</span><span class="n">segment_label</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

            <span class="n">band_indices</span><span class="p">[</span><span class="n">segment_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>

        <span class="k">return</span> <span class="n">band_indices</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_convert_wavelengths_list_to_indices</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">ranges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts a list of wavelengths into indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            wavelengths (torch.Tensor): The tensor containing the wavelengths.</span>
<span class="sd">            ranges (list[float]): The list of wavelengths.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[int]: The indices corresponding to the wavelengths.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">wavelength</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">wavelengths</span> <span class="o">==</span> <span class="n">wavelength</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">as_tuple</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">number_of_elements</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">numel</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">number_of_elements</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">number_of_elements</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Couldn&#39;t find wavelength of value </span><span class="si">{</span><span class="n">wavelength</span><span class="si">}</span><span class="s2"> in list of wavelength&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Wavelength of value </span><span class="si">{</span><span class="n">wavelength</span><span class="si">}</span><span class="s2"> was present more than once in list of wavelength&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">indices</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_band_indices_from_input_band_indices</span><span class="p">(</span>
        <span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">input_band_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ListOfWavelengthsIndices</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get band indices from band list or ranges indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            wavelengths (torch.Tensor): The tensor containing the wavelengths.</span>
<span class="sd">            band_indices (dict[str | tuple[str, ...], ListOfWavelengthsIndices]):</span>
<span class="sd">                A dictionary mapping segment labels to a list of wavelength indices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict[str | tuple[str, ...], list[int]]: A dictionary mapping segment labels to a list of band indices.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `band_indices` is not a dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_band_indices</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;band_indices should be a dictionary&quot;</span><span class="p">)</span>

        <span class="n">band_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">segment_label</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">input_band_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">indices</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">):</span>
                    <span class="n">indices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>  <span class="c1"># type: ignore</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">valid_indices_format</span> <span class="o">=</span> <span class="n">validate_segment_format</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                    <span class="n">valid_range_indices</span> <span class="o">=</span> <span class="n">adjust_and_validate_segment_ranges</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">valid_indices_format</span><span class="p">)</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_indices_from_wavelength_indices_range</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">valid_range_indices</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

                <span class="n">band_indices</span><span class="p">[</span><span class="n">segment_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>  <span class="c1"># type: ignore</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Problem with segment </span><span class="si">{</span><span class="n">segment_label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">return</span> <span class="n">band_indices</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_overlapping_segments</span><span class="p">(</span><span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span> <span class="n">dict_labels_to_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check for overlapping segments in the given hsi.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): The hsi object containing the wavelengths.</span>
<span class="sd">            dict_labels_to_indices (dict[str | tuple[str, ...], list[int]]):</span>
<span class="sd">                A dictionary mapping segment labels to indices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">overlapping_segments</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">segment_label</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">dict_labels_to_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="ow">in</span> <span class="n">overlapping_segments</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Segments </span><span class="si">{</span><span class="n">overlapping_segments</span><span class="p">[</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()]</span><span class="si">}</span><span class="s2"> &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;and </span><span class="si">{</span><span class="n">segment_label</span><span class="si">}</span><span class="s2"> are overlapping on wavelength </span><span class="si">{</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">overlapping_segments</span><span class="p">[</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()]</span> <span class="o">=</span> <span class="n">segment_label</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_validate_and_create_dict_labels_to_segment_ids</span><span class="p">(</span>
        <span class="n">dict_labels_to_segment_ids</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">segment_labels</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validates and creates a dictionary mapping segment labels to segment IDs.</span>

<span class="sd">        Args:</span>
<span class="sd">            dict_labels_to_segment_ids (dict[str | tuple[str, ...], int] | None):</span>
<span class="sd">                The existing mapping from segment labels to segment IDs, or None if it doesn&#39;t exist.</span>
<span class="sd">            segment_labels (list[str | tuple[str, ...]]): The list of segment labels.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict[str | tuple[str, ...], int]: A tuple containing the validated dictionary mapping segment</span>
<span class="sd">            labels to segment IDs and a boolean flag indicating whether the segment labels are hashed.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the length of `dict_labels_to_segment_ids` doesn&#39;t match the length of `segment_labels`.</span>
<span class="sd">            ValueError: If a segment label is not present in `dict_labels_to_segment_ids`.</span>
<span class="sd">            ValueError: If there are non-unique segment IDs in `dict_labels_to_segment_ids`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dict_labels_to_segment_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Creating mapping from segment labels into ids&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">segment</span><span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segment_labels</span><span class="p">)}</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Using existing mapping from segment labels into segment ids&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dict_labels_to_segment_ids</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment_labels</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Incorrect dict_labels_to_segment_ids - length mismatch. Expected: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">segment_labels</span><span class="p">)</span><span class="si">}</span><span class="s2">, Actual: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dict_labels_to_segment_ids</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">unique_segment_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dict_labels_to_segment_ids</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_segment_ids</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment_labels</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Non unique segment ids in the dict_labels_to_segment_ids&quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Passed mapping is correct&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dict_labels_to_segment_ids</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_single_dim_band_mask</span><span class="p">(</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">dict_labels_to_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
        <span class="n">dict_labels_to_segment_ids</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a one-dimensional band mask based on the given image, labels, and segment IDs.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): The input hsi.</span>
<span class="sd">            dict_labels_to_indices (dict[str | tuple[str, ...], list[int]]):</span>
<span class="sd">                A dictionary mapping labels or label tuples to lists of indices.</span>
<span class="sd">            dict_labels_to_segment_ids (dict[str | tuple[str, ...], int]):</span>
<span class="sd">                A dictionary mapping labels or label tuples to segment IDs.</span>
<span class="sd">            device (torch.device): The device to use for the tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The one-dimensional band mask tensor.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the indices for a segment are out of bounds for the one-dimensional band mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">band_mask_single_dim</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

        <span class="n">segment_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dict_labels_to_segment_ids</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">segment_label</span> <span class="ow">in</span> <span class="n">segment_labels</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">segment_indices</span> <span class="o">=</span> <span class="n">dict_labels_to_indices</span><span class="p">[</span><span class="n">segment_label</span><span class="p">]</span>
            <span class="n">segment_id</span> <span class="o">=</span> <span class="n">dict_labels_to_segment_ids</span><span class="p">[</span><span class="n">segment_label</span><span class="p">]</span>
            <span class="n">are_indices_valid</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">band_mask_single_dim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">segment_indices</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">are_indices_valid</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Indices for segment </span><span class="si">{</span><span class="n">segment_label</span><span class="si">}</span><span class="s2"> are out of bounds for the one-dimensional band mask&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;of shape </span><span class="si">{</span><span class="n">band_mask_single_dim</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">band_mask_single_dim</span><span class="p">[</span><span class="n">segment_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">segment_id</span>

        <span class="k">return</span> <span class="n">band_mask_single_dim</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_tensor_band_mask</span><span class="p">(</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">dict_labels_to_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
        <span class="n">dict_labels_to_segment_ids</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">repeat_dimensions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_dict_labels_to_segment_ids</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a tensor band mask from dictionaries. The band mask is created based on the given hsi, labels, and</span>
<span class="sd">        segment IDs. The band mask is a tensor with the same shape as the input hsi and contains segment IDs, where each</span>
<span class="sd">        segment is represented by a unique ID. The band mask will be used to attribute the hsi using the LIME method.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): The input hsi.</span>
<span class="sd">            dict_labels_to_indices (dict[str | tuple[str, ...], list[int]]): A dictionary mapping labels to indices.</span>
<span class="sd">            dict_labels_to_segment_ids (dict[str | tuple[str, ...], int] | None, optional):</span>
<span class="sd">                A dictionary mapping labels to segment IDs. Defaults to None.</span>
<span class="sd">            device (str | torch.device | None, optional): The device to use. Defaults to None.</span>
<span class="sd">            repeat_dimensions (bool, optional): Whether to repeat dimensions. Defaults to False.</span>
<span class="sd">            return_dict_labels_to_segment_ids (bool, optional):</span>
<span class="sd">                Whether to return the dictionary mapping labels to segment IDs. Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor | tuple[torch.Tensor, dict[tuple[str, ...] | str, int]]:</span>
<span class="sd">                The tensor band mask or a tuple containing the tensor band mask</span>
<span class="sd">                and the dictionary mapping labels to segment IDs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">device</span>
        <span class="n">segment_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dict_labels_to_indices</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating a band mask on the device </span><span class="si">{</span><span class="n">device</span><span class="si">}</span><span class="s2"> using </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">segment_labels</span><span class="p">)</span><span class="si">}</span><span class="s2"> segments&quot;</span><span class="p">)</span>

        <span class="c1"># Check for overlapping segments</span>
        <span class="n">Lime</span><span class="o">.</span><span class="n">_check_overlapping_segments</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">dict_labels_to_indices</span><span class="p">)</span>

        <span class="c1"># Create or validate dict_labels_to_segment_ids</span>
        <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_validate_and_create_dict_labels_to_segment_ids</span><span class="p">(</span>
            <span class="n">dict_labels_to_segment_ids</span><span class="p">,</span> <span class="n">segment_labels</span>
        <span class="p">)</span>

        <span class="c1"># Create single-dimensional band mask</span>
        <span class="n">band_mask_single_dim</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_create_single_dim_band_mask</span><span class="p">(</span>
            <span class="n">hsi</span><span class="p">,</span> <span class="n">dict_labels_to_indices</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span><span class="p">,</span> <span class="n">device</span>
        <span class="p">)</span>

        <span class="c1"># Expand band mask to match image dimensions</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="n">expand_spectral_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask_single_dim</span><span class="p">,</span> <span class="n">repeat_dimensions</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_dict_labels_to_segment_ids</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">band_mask</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span>
        <span class="k">return</span> <span class="n">band_mask</span>

    <span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">attribution_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;spatial&quot;</span><span class="p">,</span> <span class="s2">&quot;spectral&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSISpectralAttributes</span> <span class="o">|</span> <span class="n">HSISpatialAttributes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A wrapper function to attribute the image using the LIME method. It executes either the</span>
<span class="sd">        `get_spatial_attributes` or `get_spectral_attributes` method based on the provided `attribution_type`. For more</span>
<span class="sd">        detailed description of the methods, please refer to the respective method documentation.</span>

<span class="sd">        Additional, nondefault parameters, should be passed as keyword arguments to avoid misalignment of the arguments.</span>

<span class="sd">        Args:</span>
<span class="sd">            attribution_type (Literal[&quot;spatial&quot;, &quot;spectral&quot;] | None): An attribution type to be executed. By default None.</span>
<span class="sd">            hsi (HSI): an image on which the explanation is performed.</span>
<span class="sd">            target (int | None, optional): Target output index for the explanation. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            HSISpectralAttributes | HSISpatialAttributes: An object containing the image, the attributions and additional information. In case the `attribution_type` is `spatial`, the object is of type `HSISpatialAttributes`, otherwise it is of type `HSISpectralAttributes`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">attribution_type</span> <span class="o">==</span> <span class="s2">&quot;spatial&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spatial_attributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">attribution_type</span> <span class="o">==</span> <span class="s2">&quot;spectral&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spectral_attributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported attribution type: </span><span class="si">{</span><span class="n">attribution_type</span><span class="si">}</span><span class="s2">. Use &#39;spatial&#39; or &#39;spectral&#39;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_spatial_attributes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">segmentation_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">perturbations_per_eval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">postprocessing_segmentation_output</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">segmentation_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;slic&quot;</span><span class="p">,</span> <span class="s2">&quot;patch&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;slic&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSISpatialAttributes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get spatial attributes of an hsi image using the LIME method. Based on the provided hsi and segmentation mask</span>
<span class="sd">        LIME method attributes the `superpixels` provided by the segmentation mask. Please refer to the original paper</span>
<span class="sd">        `https://arxiv.org/abs/1602.04938` for more details or to Christoph Molnar&#39;s book</span>
<span class="sd">        `https://christophm.github.io/interpretable-ml-book/lime.html`.</span>

<span class="sd">        This function attributes the hyperspectral image using the LIME (Local Interpretable Model-Agnostic Explanations)</span>
<span class="sd">        method for spatial data. It returns an `HSISpatialAttributes` object that contains the hyperspectral image,,</span>
<span class="sd">        the attributions, the segmentation mask, and the score of the interpretable model used for the explanation.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): An HSI object for which the attribution is performed.</span>
<span class="sd">            segmentation_mask (np.ndarray | torch.Tensor | None, optional):</span>
<span class="sd">                A segmentation mask according to which the attribution should be performed.</span>
<span class="sd">                The segmentation mask should have a 3D shape, which can be broadcastable to the shape of the input image.</span>
<span class="sd">                The only dimension on which the image and the mask shapes can differ is the spectral dimension, marked with letter `C` in the `image.orientation` parameter.</span>
<span class="sd">                If None, a new segmentation mask is created using the `segmentation_method`.</span>
<span class="sd">                    Additional parameters for the segmentation method may be passed as kwargs. Defaults to None.</span>
<span class="sd">            target (int, optional): If the model creates more than one output, it analyzes the given target.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            n_samples (int, optional): The number of samples to generate/analyze in LIME. The more the better but slower. Defaults to 10.</span>
<span class="sd">            perturbations_per_eval (int, optional): The number of perturbations to evaluate at once (Simply the inner batch size).</span>
<span class="sd">                Defaults to 4.</span>
<span class="sd">            verbose (bool, optional): Whether to show the progress bar. Defaults to False.</span>
<span class="sd">                postprocessing_segmentation_output (Callable[[torch.Tensor, torch.Tensor], torch.Tensor] | None): A</span>
<span class="sd">                segmentation postprocessing function for segmentation problem type. This is required for segmentation problem type as</span>
<span class="sd">                lime surrogate model needs to be optimized on the 1d output, and the model should be able to modify the model output with</span>
<span class="sd">                inner lime active region mask as input and return the 1d output (for example number of pixel for each class) and not class mask.</span>
<span class="sd">                   Defaults to None.</span>
<span class="sd">            segmentation_method (Literal[&quot;slic&quot;, &quot;patch&quot;], optional):</span>
<span class="sd">                Segmentation method used only if `segmentation_mask` is None. Defaults to &quot;slic&quot;.</span>
<span class="sd">            **segmentation_method_params (Any): Additional parameters for the segmentation method.</span>

<span class="sd">        Returns:</span>
<span class="sd">            HSISpatialAttributes: A `HSISpatialAttributes` object that contains the image, the attributions,</span>
<span class="sd">                the segmentation mask, and the score of the interpretable model used for the explanation.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the Lime object is not initialized or is not an instance of LimeBase.</span>
<span class="sd">            AssertionError: If explainable model type is `segmentation` and `postprocessing_segmentation_output` is not provided.</span>
<span class="sd">            AssertionError: If the hsi is not an instance of the HSI class.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; simple_model = lambda x: torch.rand((x.shape[0], 2))</span>
<span class="sd">            &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask = torch.randint(1, 4, (1, 240, 240))</span>
<span class="sd">            &gt;&gt;&gt; lime = meteors.attr.Lime(</span>
<span class="sd">                    explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="sd">                )</span>
<span class="sd">            &gt;&gt;&gt; spatial_attribution = lime.get_spatial_attributes(hsi, segmentation_mask=segmentation_mask, target=0)</span>
<span class="sd">            &gt;&gt;&gt; spatial_attribution.hsi</span>
<span class="sd">            HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="sd">            &gt;&gt;&gt; spatial_attribution.attributes.shape</span>
<span class="sd">            torch.Size([4, 240, 240])</span>
<span class="sd">            &gt;&gt;&gt; spatial_attribution.segmentation_mask.shape</span>
<span class="sd">            torch.Size([1, 240, 240])</span>
<span class="sd">            &gt;&gt;&gt; spatial_attribution.score</span>
<span class="sd">            1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="p">,</span> <span class="n">LimeBase</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Lime object not initialized&quot;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">),</span> <span class="s2">&quot;hsi should be an instance of HSI class&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">explainable_model</span><span class="o">.</span><span class="n">problem_type</span> <span class="o">==</span> <span class="s2">&quot;segmentation&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">postprocessing_segmentation_output</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;postprocessing_segmentation_output is required for segmentation problem type, please provide &quot;</span>
                <span class="s2">&quot;the `postprocessing_segmentation_output`. For a reference &quot;</span>
                <span class="s2">&quot;we provided an example function to use `agg_segmentation_postprocessing` from `meteors.utils.utils` module&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">postprocessing_segmentation_output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;postprocessing_segmentation_output is provided but the problem is not segmentation, will be ignored&quot;</span>
            <span class="p">)</span>
            <span class="n">postprocessing_segmentation_output</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">segmentation_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_method</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">ensure_torch_tensor</span><span class="p">(</span>
            <span class="n">segmentation_mask</span><span class="p">,</span> <span class="s2">&quot;Segmentation mask should be None, numpy array, or torch tensor&quot;</span>
        <span class="p">)</span>

        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">validate_mask_shape</span><span class="p">(</span><span class="s2">&quot;segmentation&quot;</span><span class="p">,</span> <span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_mask</span><span class="p">)</span>

        <span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="n">lime_attributes</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
            <span class="n">inputs</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
            <span class="n">feature_mask</span><span class="o">=</span><span class="n">segmentation_mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">n_samples</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
            <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="n">perturbations_per_eval</span><span class="p">,</span>
            <span class="n">model_postprocessing</span><span class="o">=</span><span class="n">postprocessing_segmentation_output</span><span class="p">,</span>
            <span class="n">show_progress</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">return_input_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">spatial_attribution</span> <span class="o">=</span> <span class="n">HSISpatialAttributes</span><span class="p">(</span>
            <span class="n">hsi</span><span class="o">=</span><span class="n">hsi</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">lime_attributes</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">segmentation_mask</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="p">),</span>
            <span class="n">score</span><span class="o">=</span><span class="n">score</span><span class="p">,</span>
            <span class="n">attribution_method</span><span class="o">=</span><span class="s2">&quot;Lime&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">spatial_attribution</span>

    <span class="k">def</span> <span class="nf">get_spectral_attributes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">band_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">perturbations_per_eval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">postprocessing_segmentation_output</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">band_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSISpectralAttributes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attributes the hsi image using LIME method for spectral data. Based on the provided hsi and band mask, the LIME</span>
<span class="sd">        method attributes the hsi based on `superbands` (clustered bands) provided by the band mask.</span>
<span class="sd">        Please refer to the original paper `https://arxiv.org/abs/1602.04938` for more details or to</span>
<span class="sd">        Christoph Molnar&#39;s book `https://christophm.github.io/interpretable-ml-book/lime.html`.</span>

<span class="sd">        The function returns a HSISpectralAttributes object that contains the image, the attributions, the band mask,</span>
<span class="sd">        the band names, and the score of the interpretable model used for the explanation.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): An HSI object for which the attribution is performed.</span>
<span class="sd">            band_mask (np.ndarray | torch.Tensor | None, optional): Band mask that is used for the spectral attribution.</span>
<span class="sd">                The band mask should have a 3D shape, which can be broadcastable to the shape of the input image.</span>
<span class="sd">                The only dimensions on which the image and the mask shapes can differ is the height and width dimensions, marked with letters `H` and `W` in the `image.orientation` parameter.</span>
<span class="sd">                If equals to None, the band mask is created within the function. Defaults to None.</span>
<span class="sd">            target (int, optional): If the model creates more than one output, it analyzes the given target.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            n_samples (int, optional): The number of samples to generate/analyze in LIME. The more the better but slower. Defaults to 10.</span>
<span class="sd">            perturbations_per_eval (int, optional): The number of perturbations to evaluate at once (Simply the inner batch size).</span>
<span class="sd">                Defaults to 4.</span>
<span class="sd">            verbose (bool, optional): Specifies whether to show progress during the attribution process. Defaults to False.</span>
<span class="sd">            postprocessing_segmentation_output: (Callable[[torch.Tensor, torch.Tensor], torch.Tensor] | None):</span>
<span class="sd">                A segmentation postprocessing function for segmentation problem type. This is required for segmentation problem type as</span>
<span class="sd">                lime surrogate model needs to be optimized on the 1d output, and the model should be able to modify the model output with</span>
<span class="sd">                inner lime active region mask as input and return the 1d output (for example number of pixel for each class) and not class mask.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            band_names (list[str] | dict[str | tuple[str, ...], int] | None, optional): Band names. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            HSISpectralAttributes: A HSISpectralAttributes object containing the image, the attributions,</span>
<span class="sd">                the band mask, the band names, and the score of the interpretable model used for the explanation.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the Lime object is not initialized or is not an instance of LimeBase.</span>
<span class="sd">            AssertionError: If explainable model type is `segmentation` and `postprocessing_segmentation_output` is not provided.</span>
<span class="sd">            AssertionError: If the hsi is not an instance of the HSI class.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; simple_model = lambda x: torch.rand((x.shape[0], 2))</span>
<span class="sd">            &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">            &gt;&gt;&gt; band_mask = torch.randint(1, 4, (4, 1, 1)).repeat(1, 240, 240)</span>
<span class="sd">            &gt;&gt;&gt; band_names = [&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]</span>
<span class="sd">            &gt;&gt;&gt; lime = meteors.attr.Lime(</span>
<span class="sd">                    explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="sd">                )</span>
<span class="sd">            &gt;&gt;&gt; spectral_attribution = lime.get_spectral_attributes(hsi, band_mask=band_mask, band_names=band_names, target=0)</span>
<span class="sd">            &gt;&gt;&gt; spectral_attribution.hsi</span>
<span class="sd">            HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="sd">            &gt;&gt;&gt; spectral_attribution.attributes.shape</span>
<span class="sd">            torch.Size([4, 240, 240])</span>
<span class="sd">            &gt;&gt;&gt; spectral_attribution.band_mask.shape</span>
<span class="sd">            torch.Size([4, 240, 240])</span>
<span class="sd">            &gt;&gt;&gt; spectral_attribution.band_names</span>
<span class="sd">            [&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]</span>
<span class="sd">            &gt;&gt;&gt; spectral_attribution.score</span>
<span class="sd">            1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="p">,</span> <span class="n">LimeBase</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Lime object not initialized&quot;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">explainable_model</span><span class="o">.</span><span class="n">problem_type</span> <span class="o">==</span> <span class="s2">&quot;segmentation&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">postprocessing_segmentation_output</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;postprocessing_segmentation_output is required for segmentation problem type, please provide &quot;</span>
                <span class="s2">&quot;the `postprocessing_segmentation_output`. For a reference &quot;</span>
                <span class="s2">&quot;we provided an example function to use `agg_segmentation_postprocessing` from `meteors.utils.utils` module&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">postprocessing_segmentation_output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;postprocessing_segmentation_output is provided but the problem is not segmentation, will be ignored&quot;</span>
            <span class="p">)</span>
            <span class="n">postprocessing_segmentation_output</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">),</span> <span class="s2">&quot;hsi should be an instance of HSI class&quot;</span>

        <span class="k">if</span> <span class="n">band_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">band_mask</span><span class="p">,</span> <span class="n">band_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_band_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_names</span><span class="p">)</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="n">ensure_torch_tensor</span><span class="p">(</span><span class="n">band_mask</span><span class="p">,</span> <span class="s2">&quot;Band mask should be None, numpy array, or torch tensor&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">band_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">band_mask</span> <span class="o">=</span> <span class="n">expand_spectral_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask</span><span class="p">,</span> <span class="n">repeat_dimensions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="n">band_mask</span><span class="o">.</span><span class="n">int</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">band_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unique_segments</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">band_mask</span><span class="p">)</span>
            <span class="n">band_names</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">segment</span><span class="p">):</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_segments</span><span class="p">)}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># checking consistency of names</span>
            <span class="c1"># unique_segments = torch.unique(band_mask)</span>
            <span class="c1"># if isinstance(band_names, dict):</span>
            <span class="c1">#     assert set(unique_segments).issubset(set(band_names.values())), &quot;Incorrect band names&quot;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Band names are provided and will be used. In the future, there should be an option to validate them.&quot;</span>
            <span class="p">)</span>

        <span class="n">band_mask</span> <span class="o">=</span> <span class="n">validate_mask_shape</span><span class="p">(</span><span class="s2">&quot;band&quot;</span><span class="p">,</span> <span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask</span><span class="p">)</span>

        <span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="n">band_mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="n">lime_attributes</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
            <span class="n">inputs</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
            <span class="n">feature_mask</span><span class="o">=</span><span class="n">band_mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">n_samples</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
            <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="n">perturbations_per_eval</span><span class="p">,</span>
            <span class="n">model_postprocessing</span><span class="o">=</span><span class="n">postprocessing_segmentation_output</span><span class="p">,</span>
            <span class="n">show_progress</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">return_input_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">spectral_attribution</span> <span class="o">=</span> <span class="n">HSISpectralAttributes</span><span class="p">(</span>
            <span class="n">hsi</span><span class="o">=</span><span class="n">hsi</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">lime_attributes</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">band_mask</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="p">),</span>
            <span class="n">band_names</span><span class="o">=</span><span class="n">band_names</span><span class="p">,</span>
            <span class="n">score</span><span class="o">=</span><span class="n">score</span><span class="p">,</span>
            <span class="n">attribution_method</span><span class="o">=</span><span class="s2">&quot;Lime&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">spectral_attribution</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_slick_segmentation_mask</span><span class="p">(</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span> <span class="n">num_interpret_features</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a segmentation mask using the SLIC method.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): An HSI object for which the segmentation mask is created.</span>
<span class="sd">            num_interpret_features (int, optional): Number of segments. Defaults to 10.</span>
<span class="sd">            *args: Additional positional arguments to be passed to the SLIC method.</span>
<span class="sd">            **kwargs: Additional keyword arguments to be passed to the SLIC method.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: An output segmentation mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">slic</span><span class="p">(</span>
            <span class="n">hsi</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span>
            <span class="n">n_segments</span><span class="o">=</span><span class="n">num_interpret_features</span><span class="p">,</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">spatial_binary_mask</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span>
            <span class="n">channel_axis</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">segmentation_mask</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">)</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">segmentation_mask</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_patch_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a segmentation mask using the patch method - creates small squares of the same size</span>
<span class="sd">            and assigns a unique value to each square.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): An HSI object for which the segmentation mask is created.</span>
<span class="sd">            patch_size (int, optional): Size of the patch, the hsi size should be divisible by this value.</span>
<span class="sd">                Defaults to 10.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: An output segmentation mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">patch_size</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">patch_size</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid patch_size. patch_size must be a positive integer&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="n">patch_size</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">%</span> <span class="n">patch_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid patch_size. patch_size must be a factor of both width and height of the hsi&quot;</span><span class="p">)</span>

        <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">idx_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">height</span> <span class="o">//</span> <span class="n">patch_size</span> <span class="o">*</span> <span class="n">width</span> <span class="o">//</span> <span class="n">patch_size</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">height</span> <span class="o">//</span> <span class="n">patch_size</span><span class="p">,</span> <span class="n">width</span> <span class="o">//</span> <span class="n">patch_size</span>
        <span class="p">)</span>
        <span class="n">idx_mask</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">idx_mask</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">segmentation_mask</span> <span class="o">*</span> <span class="n">hsi</span><span class="o">.</span><span class="n">spatial_binary_mask</span>
        <span class="c1"># segmentation_mask = torch.repeat_interleave(</span>
        <span class="c1"># torch.unsqueeze(segmentation_mask, dim=hsi.spectral_axis),</span>
        <span class="c1"># repeats=hsi.image.shape[hsi.spectral_axis], dim=hsi.spectral_axis)</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">)</span>

        <span class="n">mask_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">mask_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mask_idx</span><span class="p">):</span>
            <span class="n">segmentation_mask</span><span class="p">[</span><span class="n">segmentation_mask</span> <span class="o">==</span> <span class="n">mask_val</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>

        <span class="k">return</span> <span class="n">segmentation_mask</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.lime.Lime.attribute" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">attribute</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">attribution_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>A wrapper function to attribute the image using the LIME method. It executes either the
<code>get_spatial_attributes</code> or <code>get_spectral_attributes</code> method based on the provided <code>attribution_type</code>. For more
detailed description of the methods, please refer to the respective method documentation.</p>
<p>Additional, nondefault parameters, should be passed as keyword arguments to avoid misalignment of the arguments.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>attribution_type</code></td>
            <td>
                  <code><span title="typing_extensions.Literal">Literal</span>[&#39;spatial&#39;, &#39;spectral&#39;] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An attribution type to be executed. By default None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>hsi</code></td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>an image on which the explanation is performed.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>target</code></td>
            <td>
                  <code>int | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Target output index for the explanation. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="meteors.attr.HSISpectralAttributes">HSISpectralAttributes</span> | <span title="meteors.attr.HSISpatialAttributes">HSISpatialAttributes</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>HSISpectralAttributes | HSISpatialAttributes: An object containing the image, the attributions and additional information. In case the <code>attribution_type</code> is <code>spatial</code>, the object is of type <code>HSISpatialAttributes</code>, otherwise it is of type <code>HSISpectralAttributes</code>.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">948</span>
<span class="normal">949</span>
<span class="normal">950</span>
<span class="normal">951</span>
<span class="normal">952</span>
<span class="normal">953</span>
<span class="normal">954</span>
<span class="normal">955</span>
<span class="normal">956</span>
<span class="normal">957</span>
<span class="normal">958</span>
<span class="normal">959</span>
<span class="normal">960</span>
<span class="normal">961</span>
<span class="normal">962</span>
<span class="normal">963</span>
<span class="normal">964</span>
<span class="normal">965</span>
<span class="normal">966</span>
<span class="normal">967</span>
<span class="normal">968</span>
<span class="normal">969</span>
<span class="normal">970</span>
<span class="normal">971</span>
<span class="normal">972</span>
<span class="normal">973</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">attribution_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;spatial&quot;</span><span class="p">,</span> <span class="s2">&quot;spectral&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSISpectralAttributes</span> <span class="o">|</span> <span class="n">HSISpatialAttributes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A wrapper function to attribute the image using the LIME method. It executes either the</span>
<span class="sd">    `get_spatial_attributes` or `get_spectral_attributes` method based on the provided `attribution_type`. For more</span>
<span class="sd">    detailed description of the methods, please refer to the respective method documentation.</span>

<span class="sd">    Additional, nondefault parameters, should be passed as keyword arguments to avoid misalignment of the arguments.</span>

<span class="sd">    Args:</span>
<span class="sd">        attribution_type (Literal[&quot;spatial&quot;, &quot;spectral&quot;] | None): An attribution type to be executed. By default None.</span>
<span class="sd">        hsi (HSI): an image on which the explanation is performed.</span>
<span class="sd">        target (int | None, optional): Target output index for the explanation. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        HSISpectralAttributes | HSISpatialAttributes: An object containing the image, the attributions and additional information. In case the `attribution_type` is `spatial`, the object is of type `HSISpatialAttributes`, otherwise it is of type `HSISpectralAttributes`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">attribution_type</span> <span class="o">==</span> <span class="s2">&quot;spatial&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spatial_attributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">attribution_type</span> <span class="o">==</span> <span class="s2">&quot;spectral&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spectral_attributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported attribution type: </span><span class="si">{</span><span class="n">attribution_type</span><span class="si">}</span><span class="s2">. Use &#39;spatial&#39; or &#39;spectral&#39;&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.lime.Lime.get_band_mask" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_band_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">band_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">band_wavelengths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">repeat_dimensions</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Generates a band mask based on the provided hsi and band information.</p>
<p>Remember you need to provide either band_names, band_indices, or band_wavelengths to create the band mask.
If you provide more than one, the band mask will be created using only one using the following priority:
band_names &gt; band_wavelengths &gt; band_indices.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>hsi</code></td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The input hyperspectral image.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>band_names</code></td>
            <td>
                  <code>None | list[str | list[str]] | dict[tuple[str, ...] | str, int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The names of the spectral bands to include in the mask. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>band_indices</code></td>
            <td>
                  <code>None | dict[str | tuple[str, ...], list[tuple[int, int]] | tuple[int, int] | list[int]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The indices or ranges of indices of the spectral bands to include in the mask. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>band_wavelengths</code></td>
            <td>
                  <code>None | dict[str | tuple[str, ...], list[tuple[float, float]] | tuple[float, float], list[float], float]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The wavelengths or ranges of wavelengths of the spectral bands to include in the mask. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>device</code></td>
            <td>
                  <code>str | <span title="torch.device">device</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The device to use for computation. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>repeat_dimensions</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to repeat the dimensions of the mask to match the input hsi shape. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple[torch.Tensor, dict[tuple[str, ...] | str, int]]: A tuple containing the band mask tensor and a dictionary</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>dict[tuple[str, ...] | str, int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>mapping band names to segment IDs.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the input hsi is not an instance of the HSI class.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If no band names, indices, or wavelengths are provided.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">hsi</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="n">wavelengths</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_mask</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">mt_lime</span><span class="o">.</span><span class="n">Lime</span><span class="o">.</span><span class="n">get_band_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_names</span><span class="o">=</span><span class="n">band_names</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dict_labels_to_segment_ids</span>
<span class="go">{&quot;R&quot;: 1, &quot;G&quot;: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_indices</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;RGB&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_mask</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">mt_lime</span><span class="o">.</span><span class="n">Lime</span><span class="o">.</span><span class="n">get_band_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_indices</span><span class="o">=</span><span class="n">band_indices</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dict_labels_to_segment_ids</span>
<span class="go">{&quot;RGB&quot;: 1}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_wavelengths</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;RGB&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="mf">462.08</span><span class="p">,</span> <span class="mf">465.27</span><span class="p">),</span> <span class="p">(</span><span class="mf">465.27</span><span class="p">,</span> <span class="mf">468.47</span><span class="p">),</span> <span class="p">(</span><span class="mf">468.47</span><span class="p">,</span> <span class="mf">471.68</span><span class="p">)]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_mask</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">mt_lime</span><span class="o">.</span><span class="n">Lime</span><span class="o">.</span><span class="n">get_band_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_wavelengths</span><span class="o">=</span><span class="n">band_wavelengths</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dict_labels_to_segment_ids</span>
<span class="go">{&quot;RGB&quot;: 1}</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">get_band_mask</span><span class="p">(</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">band_names</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">band_indices</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ListOfWavelengthsIndices</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">band_wavelengths</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ListOfWavelengths</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">repeat_dimensions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates a band mask based on the provided hsi and band information.</span>

<span class="sd">    Remember you need to provide either band_names, band_indices, or band_wavelengths to create the band mask.</span>
<span class="sd">    If you provide more than one, the band mask will be created using only one using the following priority:</span>
<span class="sd">    band_names &gt; band_wavelengths &gt; band_indices.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (HSI): The input hyperspectral image.</span>
<span class="sd">        band_names (None | list[str | list[str]] | dict[tuple[str, ...] | str, int], optional):</span>
<span class="sd">            The names of the spectral bands to include in the mask. Defaults to None.</span>
<span class="sd">        band_indices (None | dict[str | tuple[str, ...], list[tuple[int, int]] | tuple[int, int] | list[int]], optional):</span>
<span class="sd">            The indices or ranges of indices of the spectral bands to include in the mask. Defaults to None.</span>
<span class="sd">        band_wavelengths (None | dict[str | tuple[str, ...], list[tuple[float, float]] | tuple[float, float], list[float], float], optional):</span>
<span class="sd">            The wavelengths or ranges of wavelengths of the spectral bands to include in the mask. Defaults to None.</span>
<span class="sd">        device (str | torch.device | None, optional):</span>
<span class="sd">            The device to use for computation. Defaults to None.</span>
<span class="sd">        repeat_dimensions (bool, optional):</span>
<span class="sd">            Whether to repeat the dimensions of the mask to match the input hsi shape. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[torch.Tensor, dict[tuple[str, ...] | str, int]]: A tuple containing the band mask tensor and a dictionary</span>
<span class="sd">        mapping band names to segment IDs.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the input hsi is not an instance of the HSI class.</span>
<span class="sd">        ValueError: If no band names, indices, or wavelengths are provided.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((len(wavelengths), 10, 10)), wavelengths=wavelengths)</span>
<span class="sd">        &gt;&gt;&gt; band_names = [&quot;R&quot;, &quot;G&quot;]</span>
<span class="sd">        &gt;&gt;&gt; band_mask, dict_labels_to_segment_ids = mt_lime.Lime.get_band_mask(hsi, band_names=band_names)</span>
<span class="sd">        &gt;&gt;&gt; dict_labels_to_segment_ids</span>
<span class="sd">        {&quot;R&quot;: 1, &quot;G&quot;: 2}</span>
<span class="sd">        &gt;&gt;&gt; band_indices = {&quot;RGB&quot;: [0, 1, 2]}</span>
<span class="sd">        &gt;&gt;&gt; band_mask, dict_labels_to_segment_ids = mt_lime.Lime.get_band_mask(hsi, band_indices=band_indices)</span>
<span class="sd">        &gt;&gt;&gt; dict_labels_to_segment_ids</span>
<span class="sd">        {&quot;RGB&quot;: 1}</span>
<span class="sd">        &gt;&gt;&gt; band_wavelengths = {&quot;RGB&quot;: [(462.08, 465.27), (465.27, 468.47), (468.47, 471.68)]}</span>
<span class="sd">        &gt;&gt;&gt; band_mask, dict_labels_to_segment_ids = mt_lime.Lime.get_band_mask(hsi, band_wavelengths=band_wavelengths)</span>
<span class="sd">        &gt;&gt;&gt; dict_labels_to_segment_ids</span>
<span class="sd">        {&quot;RGB&quot;: 1}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;hsi should be an instance of HSI class&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">band_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">band_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="p">),</span> <span class="s2">&quot;No band names, indices, or wavelengths are provided.&quot;</span>

    <span class="c1"># validate types</span>
    <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">band_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting band mask from band names of spectral bands&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">band_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignored_params</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">param</span>
                <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;band_wavelengths&quot;</span><span class="p">,</span> <span class="s2">&quot;band_indices&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">param</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">]</span>
            <span class="n">ignored_params_str</span> <span class="o">=</span> <span class="s2">&quot; and &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ignored_params</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Only the band names will be used to create the band mask. The additional parameters </span><span class="si">{</span><span class="n">ignored_params_str</span><span class="si">}</span><span class="s2"> will be ignored.&quot;</span>
            <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">validate_band_names</span><span class="p">(</span><span class="n">band_names</span><span class="p">)</span>
            <span class="n">band_groups</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_band_wavelengths_indices_from_band_names</span><span class="p">(</span>
                <span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">band_names</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Incorrect band names provided: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
    <span class="k">elif</span> <span class="n">band_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting band mask from band groups given by ranges of wavelengths&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Only the band wavelengths will be used to create the band mask. The band_indices will be ignored.&quot;</span>
            <span class="p">)</span>
        <span class="n">validate_band_format</span><span class="p">(</span><span class="n">band_wavelengths</span><span class="p">,</span> <span class="n">variable_name</span><span class="o">=</span><span class="s2">&quot;band_wavelengths&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">band_groups</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_band_indices_from_band_wavelengths</span><span class="p">(</span>
                <span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span>
                <span class="n">band_wavelengths</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Incorrect band ranges wavelengths provided, please check if provided wavelengths are correct: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
    <span class="k">elif</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting band mask from band groups given by ranges of indices&quot;</span><span class="p">)</span>
        <span class="n">validate_band_format</span><span class="p">(</span><span class="n">band_indices</span><span class="p">,</span> <span class="n">variable_name</span><span class="o">=</span><span class="s2">&quot;band_indices&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">band_groups</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_band_indices_from_input_band_indices</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">band_indices</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Incorrect band ranges indices provided, please check if provided indices are correct: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">return</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_create_tensor_band_mask</span><span class="p">(</span>
        <span class="n">hsi</span><span class="p">,</span>
        <span class="n">band_groups</span><span class="p">,</span>
        <span class="n">dict_labels_to_segment_ids</span><span class="o">=</span><span class="n">dict_labels_to_segment_ids</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">repeat_dimensions</span><span class="o">=</span><span class="n">repeat_dimensions</span><span class="p">,</span>
        <span class="n">return_dict_labels_to_segment_ids</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.lime.Lime.get_segmentation_mask" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_method</span><span class="o">=</span><span class="s1">&#39;slic&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Generates a segmentation mask for the given hsi using the specified segmentation method.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>hsi</code></td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The input hyperspectral image for which the segmentation mask needs to be generated.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>segmentation_method</code></td>
            <td>
                  <code><span title="typing_extensions.Literal">Literal</span>[&#39;patch&#39;, &#39;slic&#39;]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The segmentation method to be used.
Defaults to "slic".</p>
              </div>
            </td>
            <td>
                  <code>&#39;slic&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>**segmentation_method_params</code></td>
            <td>
                  <code><span title="typing_extensions.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional parameters specific to the chosen segmentation method.</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: The segmentation mask as a tensor.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the input hsi is not an instance of the HSI class.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If an unsupported segmentation method is specified.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">hsi</span> <span class="o">=</span> <span class="n">meteors</span><span class="o">.</span><span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">)),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="p">[</span><span class="mf">462.08</span><span class="p">,</span> <span class="mf">465.27</span><span class="p">,</span> <span class="mf">468.47</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">mt_lime</span><span class="o">.</span><span class="n">Lime</span><span class="o">.</span><span class="n">get_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_method</span><span class="o">=</span><span class="s2">&quot;slic&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([1, 240, 240])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">meteors</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">Lime</span><span class="o">.</span><span class="n">get_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_method</span><span class="o">=</span><span class="s2">&quot;patch&quot;</span><span class="p">,</span> <span class="n">patch_size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([1, 240, 240])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">torch.tensor([[1, 1],</span>
<span class="go">              [1, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">torch.tensor([[2, 2],</span>
<span class="go">              [2, 2]])</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">get_segmentation_mask</span><span class="p">(</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">segmentation_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;patch&quot;</span><span class="p">,</span> <span class="s2">&quot;slic&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;slic&quot;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates a segmentation mask for the given hsi using the specified segmentation method.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (HSI): The input hyperspectral image for which the segmentation mask needs to be generated.</span>
<span class="sd">        segmentation_method (Literal[&quot;patch&quot;, &quot;slic&quot;], optional): The segmentation method to be used.</span>
<span class="sd">            Defaults to &quot;slic&quot;.</span>
<span class="sd">        **segmentation_method_params (Any): Additional parameters specific to the chosen segmentation method.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: The segmentation mask as a tensor.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the input hsi is not an instance of the HSI class.</span>
<span class="sd">        ValueError: If an unsupported segmentation method is specified.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; hsi = meteors.HSI(image=torch.ones((3, 240, 240)), wavelengths=[462.08, 465.27, 468.47])</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask = mt_lime.Lime.get_segmentation_mask(hsi, segmentation_method=&quot;slic&quot;)</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask.shape</span>
<span class="sd">        torch.Size([1, 240, 240])</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask = meteors.attr.Lime.get_segmentation_mask(hsi, segmentation_method=&quot;patch&quot;, patch_size=2)</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask.shape</span>
<span class="sd">        torch.Size([1, 240, 240])</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask[0, :2, :2]</span>
<span class="sd">        torch.tensor([[1, 1],</span>
<span class="sd">                      [1, 1]])</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask[0, 2:4, :2]</span>
<span class="sd">        torch.tensor([[2, 2],</span>
<span class="sd">                      [2, 2]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;hsi should be an instance of HSI class&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">segmentation_method</span> <span class="o">==</span> <span class="s2">&quot;slic&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_slick_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">segmentation_method</span> <span class="o">==</span> <span class="s2">&quot;patch&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_patch_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported segmentation method: </span><span class="si">{</span><span class="n">segmentation_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.lime.Lime.get_spatial_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_spatial_attributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">postprocessing_segmentation_output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">segmentation_method</span><span class="o">=</span><span class="s1">&#39;slic&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Get spatial attributes of an hsi image using the LIME method. Based on the provided hsi and segmentation mask
LIME method attributes the <code>superpixels</code> provided by the segmentation mask. Please refer to the original paper
<code>https://arxiv.org/abs/1602.04938</code> for more details or to Christoph Molnar's book
<code>https://christophm.github.io/interpretable-ml-book/lime.html</code>.</p>
<p>This function attributes the hyperspectral image using the LIME (Local Interpretable Model-Agnostic Explanations)
method for spatial data. It returns an <code>HSISpatialAttributes</code> object that contains the hyperspectral image,,
the attributions, the segmentation mask, and the score of the interpretable model used for the explanation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>hsi</code></td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An HSI object for which the attribution is performed.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>segmentation_mask</code></td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span> | <span title="torch.Tensor">Tensor</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A segmentation mask according to which the attribution should be performed.
The segmentation mask should have a 3D shape, which can be broadcastable to the shape of the input image.
The only dimension on which the image and the mask shapes can differ is the spectral dimension, marked with letter <code>C</code> in the <code>image.orientation</code> parameter.
If None, a new segmentation mask is created using the <code>segmentation_method</code>.
    Additional parameters for the segmentation method may be passed as kwargs. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>target</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the model creates more than one output, it analyzes the given target.
Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>n_samples</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of samples to generate/analyze in LIME. The more the better but slower. Defaults to 10.</p>
              </div>
            </td>
            <td>
                  <code>10</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>perturbations_per_eval</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of perturbations to evaluate at once (Simply the inner batch size).
Defaults to 4.</p>
              </div>
            </td>
            <td>
                  <code>4</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>verbose</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to show the progress bar. Defaults to False.
postprocessing_segmentation_output (Callable[[torch.Tensor, torch.Tensor], torch.Tensor] | None): A
segmentation postprocessing function for segmentation problem type. This is required for segmentation problem type as
lime surrogate model needs to be optimized on the 1d output, and the model should be able to modify the model output with
inner lime active region mask as input and return the 1d output (for example number of pixel for each class) and not class mask.
   Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>segmentation_method</code></td>
            <td>
                  <code><span title="typing_extensions.Literal">Literal</span>[&#39;slic&#39;, &#39;patch&#39;]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Segmentation method used only if <code>segmentation_mask</code> is None. Defaults to "slic".</p>
              </div>
            </td>
            <td>
                  <code>&#39;slic&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>**segmentation_method_params</code></td>
            <td>
                  <code><span title="typing_extensions.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional parameters for the segmentation method.</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>HSISpatialAttributes</code></td>            <td>
                  <code><span title="meteors.attr.HSISpatialAttributes">HSISpatialAttributes</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A <code>HSISpatialAttributes</code> object that contains the image, the attributions,
the segmentation mask, and the score of the interpretable model used for the explanation.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the Lime object is not initialized or is not an instance of LimeBase.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>AssertionError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If explainable model type is <code>segmentation</code> and <code>postprocessing_segmentation_output</code> is not provided.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>AssertionError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the hsi is not an instance of the HSI class.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">simple_model</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">)),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="p">[</span><span class="mf">462.08</span><span class="p">,</span> <span class="mf">465.27</span><span class="p">,</span> <span class="mf">468.47</span><span class="p">,</span> <span class="mf">471.68</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lime</span> <span class="o">=</span> <span class="n">meteors</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">Lime</span><span class="p">(</span>
<span class="go">        explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_attribution</span> <span class="o">=</span> <span class="n">lime</span><span class="o">.</span><span class="n">get_spatial_attributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_mask</span><span class="o">=</span><span class="n">segmentation_mask</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_attribution</span><span class="o">.</span><span class="n">hsi</span>
<span class="go">HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_attribution</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([4, 240, 240])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_attribution</span><span class="o">.</span><span class="n">segmentation_mask</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([1, 240, 240])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_attribution</span><span class="o">.</span><span class="n">score</span>
<span class="go">1.0</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_spatial_attributes</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">segmentation_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">perturbations_per_eval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">postprocessing_segmentation_output</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">segmentation_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;slic&quot;</span><span class="p">,</span> <span class="s2">&quot;patch&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;slic&quot;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSISpatialAttributes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get spatial attributes of an hsi image using the LIME method. Based on the provided hsi and segmentation mask</span>
<span class="sd">    LIME method attributes the `superpixels` provided by the segmentation mask. Please refer to the original paper</span>
<span class="sd">    `https://arxiv.org/abs/1602.04938` for more details or to Christoph Molnar&#39;s book</span>
<span class="sd">    `https://christophm.github.io/interpretable-ml-book/lime.html`.</span>

<span class="sd">    This function attributes the hyperspectral image using the LIME (Local Interpretable Model-Agnostic Explanations)</span>
<span class="sd">    method for spatial data. It returns an `HSISpatialAttributes` object that contains the hyperspectral image,,</span>
<span class="sd">    the attributions, the segmentation mask, and the score of the interpretable model used for the explanation.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (HSI): An HSI object for which the attribution is performed.</span>
<span class="sd">        segmentation_mask (np.ndarray | torch.Tensor | None, optional):</span>
<span class="sd">            A segmentation mask according to which the attribution should be performed.</span>
<span class="sd">            The segmentation mask should have a 3D shape, which can be broadcastable to the shape of the input image.</span>
<span class="sd">            The only dimension on which the image and the mask shapes can differ is the spectral dimension, marked with letter `C` in the `image.orientation` parameter.</span>
<span class="sd">            If None, a new segmentation mask is created using the `segmentation_method`.</span>
<span class="sd">                Additional parameters for the segmentation method may be passed as kwargs. Defaults to None.</span>
<span class="sd">        target (int, optional): If the model creates more than one output, it analyzes the given target.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        n_samples (int, optional): The number of samples to generate/analyze in LIME. The more the better but slower. Defaults to 10.</span>
<span class="sd">        perturbations_per_eval (int, optional): The number of perturbations to evaluate at once (Simply the inner batch size).</span>
<span class="sd">            Defaults to 4.</span>
<span class="sd">        verbose (bool, optional): Whether to show the progress bar. Defaults to False.</span>
<span class="sd">            postprocessing_segmentation_output (Callable[[torch.Tensor, torch.Tensor], torch.Tensor] | None): A</span>
<span class="sd">            segmentation postprocessing function for segmentation problem type. This is required for segmentation problem type as</span>
<span class="sd">            lime surrogate model needs to be optimized on the 1d output, and the model should be able to modify the model output with</span>
<span class="sd">            inner lime active region mask as input and return the 1d output (for example number of pixel for each class) and not class mask.</span>
<span class="sd">               Defaults to None.</span>
<span class="sd">        segmentation_method (Literal[&quot;slic&quot;, &quot;patch&quot;], optional):</span>
<span class="sd">            Segmentation method used only if `segmentation_mask` is None. Defaults to &quot;slic&quot;.</span>
<span class="sd">        **segmentation_method_params (Any): Additional parameters for the segmentation method.</span>

<span class="sd">    Returns:</span>
<span class="sd">        HSISpatialAttributes: A `HSISpatialAttributes` object that contains the image, the attributions,</span>
<span class="sd">            the segmentation mask, and the score of the interpretable model used for the explanation.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the Lime object is not initialized or is not an instance of LimeBase.</span>
<span class="sd">        AssertionError: If explainable model type is `segmentation` and `postprocessing_segmentation_output` is not provided.</span>
<span class="sd">        AssertionError: If the hsi is not an instance of the HSI class.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; simple_model = lambda x: torch.rand((x.shape[0], 2))</span>
<span class="sd">        &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask = torch.randint(1, 4, (1, 240, 240))</span>
<span class="sd">        &gt;&gt;&gt; lime = meteors.attr.Lime(</span>
<span class="sd">                explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="sd">            )</span>
<span class="sd">        &gt;&gt;&gt; spatial_attribution = lime.get_spatial_attributes(hsi, segmentation_mask=segmentation_mask, target=0)</span>
<span class="sd">        &gt;&gt;&gt; spatial_attribution.hsi</span>
<span class="sd">        HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="sd">        &gt;&gt;&gt; spatial_attribution.attributes.shape</span>
<span class="sd">        torch.Size([4, 240, 240])</span>
<span class="sd">        &gt;&gt;&gt; spatial_attribution.segmentation_mask.shape</span>
<span class="sd">        torch.Size([1, 240, 240])</span>
<span class="sd">        &gt;&gt;&gt; spatial_attribution.score</span>
<span class="sd">        1.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="p">,</span> <span class="n">LimeBase</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Lime object not initialized&quot;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">),</span> <span class="s2">&quot;hsi should be an instance of HSI class&quot;</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">explainable_model</span><span class="o">.</span><span class="n">problem_type</span> <span class="o">==</span> <span class="s2">&quot;segmentation&quot;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">postprocessing_segmentation_output</span><span class="p">,</span> <span class="p">(</span>
            <span class="s2">&quot;postprocessing_segmentation_output is required for segmentation problem type, please provide &quot;</span>
            <span class="s2">&quot;the `postprocessing_segmentation_output`. For a reference &quot;</span>
            <span class="s2">&quot;we provided an example function to use `agg_segmentation_postprocessing` from `meteors.utils.utils` module&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">postprocessing_segmentation_output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;postprocessing_segmentation_output is provided but the problem is not segmentation, will be ignored&quot;</span>
        <span class="p">)</span>
        <span class="n">postprocessing_segmentation_output</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">segmentation_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_method</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span>
    <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">ensure_torch_tensor</span><span class="p">(</span>
        <span class="n">segmentation_mask</span><span class="p">,</span> <span class="s2">&quot;Segmentation mask should be None, numpy array, or torch tensor&quot;</span>
    <span class="p">)</span>

    <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">validate_mask_shape</span><span class="p">(</span><span class="s2">&quot;segmentation&quot;</span><span class="p">,</span> <span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_mask</span><span class="p">)</span>

    <span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="n">lime_attributes</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
        <span class="n">inputs</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
        <span class="n">feature_mask</span><span class="o">=</span><span class="n">segmentation_mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">n_samples</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
        <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="n">perturbations_per_eval</span><span class="p">,</span>
        <span class="n">model_postprocessing</span><span class="o">=</span><span class="n">postprocessing_segmentation_output</span><span class="p">,</span>
        <span class="n">show_progress</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="n">return_input_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">spatial_attribution</span> <span class="o">=</span> <span class="n">HSISpatialAttributes</span><span class="p">(</span>
        <span class="n">hsi</span><span class="o">=</span><span class="n">hsi</span><span class="p">,</span>
        <span class="n">attributes</span><span class="o">=</span><span class="n">lime_attributes</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">segmentation_mask</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="p">),</span>
        <span class="n">score</span><span class="o">=</span><span class="n">score</span><span class="p">,</span>
        <span class="n">attribution_method</span><span class="o">=</span><span class="s2">&quot;Lime&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">spatial_attribution</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.lime.Lime.get_spectral_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_spectral_attributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">postprocessing_segmentation_output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">band_names</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Attributes the hsi image using LIME method for spectral data. Based on the provided hsi and band mask, the LIME
method attributes the hsi based on <code>superbands</code> (clustered bands) provided by the band mask.
Please refer to the original paper <code>https://arxiv.org/abs/1602.04938</code> for more details or to
Christoph Molnar's book <code>https://christophm.github.io/interpretable-ml-book/lime.html</code>.</p>
<p>The function returns a HSISpectralAttributes object that contains the image, the attributions, the band mask,
the band names, and the score of the interpretable model used for the explanation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>hsi</code></td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An HSI object for which the attribution is performed.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>band_mask</code></td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span> | <span title="torch.Tensor">Tensor</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Band mask that is used for the spectral attribution.
The band mask should have a 3D shape, which can be broadcastable to the shape of the input image.
The only dimensions on which the image and the mask shapes can differ is the height and width dimensions, marked with letters <code>H</code> and <code>W</code> in the <code>image.orientation</code> parameter.
If equals to None, the band mask is created within the function. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>target</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the model creates more than one output, it analyzes the given target.
Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>n_samples</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of samples to generate/analyze in LIME. The more the better but slower. Defaults to 10.</p>
              </div>
            </td>
            <td>
                  <code>10</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>perturbations_per_eval</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of perturbations to evaluate at once (Simply the inner batch size).
Defaults to 4.</p>
              </div>
            </td>
            <td>
                  <code>4</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>verbose</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Specifies whether to show progress during the attribution process. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>postprocessing_segmentation_output</code></td>
            <td>
                  <code><span title="typing_extensions.Callable">Callable</span>[[<span title="torch.Tensor">Tensor</span>, <span title="torch.Tensor">Tensor</span>], <span title="torch.Tensor">Tensor</span>] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>(Callable[[torch.Tensor, torch.Tensor], torch.Tensor] | None):
A segmentation postprocessing function for segmentation problem type. This is required for segmentation problem type as
lime surrogate model needs to be optimized on the 1d output, and the model should be able to modify the model output with
inner lime active region mask as input and return the 1d output (for example number of pixel for each class) and not class mask.
Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>band_names</code></td>
            <td>
                  <code>list[str] | dict[str | tuple[str, ...], int] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Band names. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>HSISpectralAttributes</code></td>            <td>
                  <code><span title="meteors.attr.HSISpectralAttributes">HSISpectralAttributes</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A HSISpectralAttributes object containing the image, the attributions,
the band mask, the band names, and the score of the interpretable model used for the explanation.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the Lime object is not initialized or is not an instance of LimeBase.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>AssertionError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If explainable model type is <code>segmentation</code> and <code>postprocessing_segmentation_output</code> is not provided.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>AssertionError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the hsi is not an instance of the HSI class.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">simple_model</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">)),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="p">[</span><span class="mf">462.08</span><span class="p">,</span> <span class="mf">465.27</span><span class="p">,</span> <span class="mf">468.47</span><span class="p">,</span> <span class="mf">471.68</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lime</span> <span class="o">=</span> <span class="n">meteors</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">Lime</span><span class="p">(</span>
<span class="go">        explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_attribution</span> <span class="o">=</span> <span class="n">lime</span><span class="o">.</span><span class="n">get_spectral_attributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask</span><span class="o">=</span><span class="n">band_mask</span><span class="p">,</span> <span class="n">band_names</span><span class="o">=</span><span class="n">band_names</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_attribution</span><span class="o">.</span><span class="n">hsi</span>
<span class="go">HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_attribution</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([4, 240, 240])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_attribution</span><span class="o">.</span><span class="n">band_mask</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([4, 240, 240])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_attribution</span><span class="o">.</span><span class="n">band_names</span>
<span class="go">[&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_attribution</span><span class="o">.</span><span class="n">score</span>
<span class="go">1.0</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_spectral_attributes</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">band_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">perturbations_per_eval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">postprocessing_segmentation_output</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">band_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSISpectralAttributes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attributes the hsi image using LIME method for spectral data. Based on the provided hsi and band mask, the LIME</span>
<span class="sd">    method attributes the hsi based on `superbands` (clustered bands) provided by the band mask.</span>
<span class="sd">    Please refer to the original paper `https://arxiv.org/abs/1602.04938` for more details or to</span>
<span class="sd">    Christoph Molnar&#39;s book `https://christophm.github.io/interpretable-ml-book/lime.html`.</span>

<span class="sd">    The function returns a HSISpectralAttributes object that contains the image, the attributions, the band mask,</span>
<span class="sd">    the band names, and the score of the interpretable model used for the explanation.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (HSI): An HSI object for which the attribution is performed.</span>
<span class="sd">        band_mask (np.ndarray | torch.Tensor | None, optional): Band mask that is used for the spectral attribution.</span>
<span class="sd">            The band mask should have a 3D shape, which can be broadcastable to the shape of the input image.</span>
<span class="sd">            The only dimensions on which the image and the mask shapes can differ is the height and width dimensions, marked with letters `H` and `W` in the `image.orientation` parameter.</span>
<span class="sd">            If equals to None, the band mask is created within the function. Defaults to None.</span>
<span class="sd">        target (int, optional): If the model creates more than one output, it analyzes the given target.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        n_samples (int, optional): The number of samples to generate/analyze in LIME. The more the better but slower. Defaults to 10.</span>
<span class="sd">        perturbations_per_eval (int, optional): The number of perturbations to evaluate at once (Simply the inner batch size).</span>
<span class="sd">            Defaults to 4.</span>
<span class="sd">        verbose (bool, optional): Specifies whether to show progress during the attribution process. Defaults to False.</span>
<span class="sd">        postprocessing_segmentation_output: (Callable[[torch.Tensor, torch.Tensor], torch.Tensor] | None):</span>
<span class="sd">            A segmentation postprocessing function for segmentation problem type. This is required for segmentation problem type as</span>
<span class="sd">            lime surrogate model needs to be optimized on the 1d output, and the model should be able to modify the model output with</span>
<span class="sd">            inner lime active region mask as input and return the 1d output (for example number of pixel for each class) and not class mask.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        band_names (list[str] | dict[str | tuple[str, ...], int] | None, optional): Band names. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        HSISpectralAttributes: A HSISpectralAttributes object containing the image, the attributions,</span>
<span class="sd">            the band mask, the band names, and the score of the interpretable model used for the explanation.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the Lime object is not initialized or is not an instance of LimeBase.</span>
<span class="sd">        AssertionError: If explainable model type is `segmentation` and `postprocessing_segmentation_output` is not provided.</span>
<span class="sd">        AssertionError: If the hsi is not an instance of the HSI class.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; simple_model = lambda x: torch.rand((x.shape[0], 2))</span>
<span class="sd">        &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">        &gt;&gt;&gt; band_mask = torch.randint(1, 4, (4, 1, 1)).repeat(1, 240, 240)</span>
<span class="sd">        &gt;&gt;&gt; band_names = [&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]</span>
<span class="sd">        &gt;&gt;&gt; lime = meteors.attr.Lime(</span>
<span class="sd">                explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="sd">            )</span>
<span class="sd">        &gt;&gt;&gt; spectral_attribution = lime.get_spectral_attributes(hsi, band_mask=band_mask, band_names=band_names, target=0)</span>
<span class="sd">        &gt;&gt;&gt; spectral_attribution.hsi</span>
<span class="sd">        HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="sd">        &gt;&gt;&gt; spectral_attribution.attributes.shape</span>
<span class="sd">        torch.Size([4, 240, 240])</span>
<span class="sd">        &gt;&gt;&gt; spectral_attribution.band_mask.shape</span>
<span class="sd">        torch.Size([4, 240, 240])</span>
<span class="sd">        &gt;&gt;&gt; spectral_attribution.band_names</span>
<span class="sd">        [&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]</span>
<span class="sd">        &gt;&gt;&gt; spectral_attribution.score</span>
<span class="sd">        1.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="p">,</span> <span class="n">LimeBase</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Lime object not initialized&quot;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">explainable_model</span><span class="o">.</span><span class="n">problem_type</span> <span class="o">==</span> <span class="s2">&quot;segmentation&quot;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">postprocessing_segmentation_output</span><span class="p">,</span> <span class="p">(</span>
            <span class="s2">&quot;postprocessing_segmentation_output is required for segmentation problem type, please provide &quot;</span>
            <span class="s2">&quot;the `postprocessing_segmentation_output`. For a reference &quot;</span>
            <span class="s2">&quot;we provided an example function to use `agg_segmentation_postprocessing` from `meteors.utils.utils` module&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">postprocessing_segmentation_output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;postprocessing_segmentation_output is provided but the problem is not segmentation, will be ignored&quot;</span>
        <span class="p">)</span>
        <span class="n">postprocessing_segmentation_output</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">),</span> <span class="s2">&quot;hsi should be an instance of HSI class&quot;</span>

    <span class="k">if</span> <span class="n">band_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">band_mask</span><span class="p">,</span> <span class="n">band_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_band_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_names</span><span class="p">)</span>
    <span class="n">band_mask</span> <span class="o">=</span> <span class="n">ensure_torch_tensor</span><span class="p">(</span><span class="n">band_mask</span><span class="p">,</span> <span class="s2">&quot;Band mask should be None, numpy array, or torch tensor&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">band_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="n">expand_spectral_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask</span><span class="p">,</span> <span class="n">repeat_dimensions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">band_mask</span> <span class="o">=</span> <span class="n">band_mask</span><span class="o">.</span><span class="n">int</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">band_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">unique_segments</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">band_mask</span><span class="p">)</span>
        <span class="n">band_names</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">segment</span><span class="p">):</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_segments</span><span class="p">)}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># checking consistency of names</span>
        <span class="c1"># unique_segments = torch.unique(band_mask)</span>
        <span class="c1"># if isinstance(band_names, dict):</span>
        <span class="c1">#     assert set(unique_segments).issubset(set(band_names.values())), &quot;Incorrect band names&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Band names are provided and will be used. In the future, there should be an option to validate them.&quot;</span>
        <span class="p">)</span>

    <span class="n">band_mask</span> <span class="o">=</span> <span class="n">validate_mask_shape</span><span class="p">(</span><span class="s2">&quot;band&quot;</span><span class="p">,</span> <span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask</span><span class="p">)</span>

    <span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">band_mask</span> <span class="o">=</span> <span class="n">band_mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="n">lime_attributes</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
        <span class="n">inputs</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
        <span class="n">feature_mask</span><span class="o">=</span><span class="n">band_mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">n_samples</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
        <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="n">perturbations_per_eval</span><span class="p">,</span>
        <span class="n">model_postprocessing</span><span class="o">=</span><span class="n">postprocessing_segmentation_output</span><span class="p">,</span>
        <span class="n">show_progress</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="n">return_input_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">spectral_attribution</span> <span class="o">=</span> <span class="n">HSISpectralAttributes</span><span class="p">(</span>
        <span class="n">hsi</span><span class="o">=</span><span class="n">hsi</span><span class="p">,</span>
        <span class="n">attributes</span><span class="o">=</span><span class="n">lime_attributes</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">band_mask</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="p">),</span>
        <span class="n">band_names</span><span class="o">=</span><span class="n">band_names</span><span class="p">,</span>
        <span class="n">score</span><span class="o">=</span><span class="n">score</span><span class="p">,</span>
        <span class="n">attribution_method</span><span class="o">=</span><span class="s2">&quot;Lime&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">spectral_attribution</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h4 id="lime-base">Lime Base</h4>
<p>The Lime Base class was adapted from the Captum Lime implementation. This adaptation builds upon the original work, extending and customizing it for specific use cases within this project. To see the original implementation, please refer to the <a href="https://captum.ai/api/_modules/captum/attr/_core/lime.html#LimeBase">Captum repository</a>.</p>


<div class="doc doc-object doc-class">



<h3 id="src.meteors.attr.integrated_gradients.IntegratedGradients" class="doc doc-heading">
            <code>IntegratedGradients</code>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="meteors.attr.Explainer">Explainer</span></code></p>


        <p>IntegratedGradients explainer class for generating attributions using the Integrated Gradients method.
The Integrated Gradients method is based on the <a href="https://captum.ai/docs/extension/integrated_gradients"><code>captum</code> implementation</a>
and is an implementation of an idea coming from the <a href="https://arxiv.org/pdf/1703.01365">original paper on Integrated Gradients</a>,
where more details about this method can be found.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.integrated_gradients.IntegratedGradients._attribution_method">_attribution_method</span></code></td>
            <td>
                  <code><span title="captum.attr.IntegratedGradients">IntegratedGradients</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The Integrated Gradients method from the <code>captum</code> library.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/integrated_gradients.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">IntegratedGradients</span><span class="p">(</span><span class="n">Explainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    IntegratedGradients explainer class for generating attributions using the Integrated Gradients method.</span>
<span class="sd">    The Integrated Gradients method is based on the [`captum` implementation](https://captum.ai/docs/extension/integrated_gradients)</span>
<span class="sd">    and is an implementation of an idea coming from the [original paper on Integrated Gradients](https://arxiv.org/pdf/1703.01365),</span>
<span class="sd">    where more details about this method can be found.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        _attribution_method (CaptumIntegratedGradients): The Integrated Gradients method from the `captum` library.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">explainable_model</span><span class="p">:</span> <span class="n">ExplainableModel</span><span class="p">,</span> <span class="n">multiply_by_inputs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">explainable_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="o">=</span> <span class="n">CaptumIntegratedGradients</span><span class="p">(</span>
            <span class="n">explainable_model</span><span class="o">.</span><span class="n">forward_func</span><span class="p">,</span> <span class="n">multiply_by_inputs</span><span class="o">=</span><span class="n">multiply_by_inputs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">baseline</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span>
            <span class="s2">&quot;riemann_right&quot;</span><span class="p">,</span> <span class="s2">&quot;riemann_left&quot;</span><span class="p">,</span> <span class="s2">&quot;riemann_middle&quot;</span><span class="p">,</span> <span class="s2">&quot;riemann_trapezoid&quot;</span><span class="p">,</span> <span class="s2">&quot;gausslegendre&quot;</span>
        <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;gausslegendre&quot;</span><span class="p">,</span>
        <span class="n">return_convergence_delta</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributes</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;IntegratedGradients explainer is not initialized&quot;</span><span class="p">)</span>

        <span class="n">baseline</span> <span class="o">=</span> <span class="n">validate_and_transform_baseline</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="n">hsi</span><span class="p">)</span>

        <span class="n">ig_attributions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
            <span class="n">hsi</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">baselines</span><span class="o">=</span><span class="n">baseline</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">return_convergence_delta</span><span class="o">=</span><span class="n">return_convergence_delta</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">return_convergence_delta</span><span class="p">:</span>
            <span class="n">attributions</span><span class="p">,</span> <span class="n">approximation_error_tensor</span> <span class="o">=</span> <span class="n">ig_attributions</span>

            <span class="c1"># ig_attributions is a tuple of attributions and approximation_error_tensor, where tensor has the same length as the number of example inputs</span>
            <span class="n">approximation_error</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">approximation_error_tensor</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">approximation_error_tensor</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">attributions</span><span class="p">,</span> <span class="n">approximation_error</span> <span class="o">=</span> <span class="n">ig_attributions</span><span class="p">,</span> <span class="kc">None</span>

        <span class="n">attributes</span> <span class="o">=</span> <span class="n">HSIAttributes</span><span class="p">(</span>
            <span class="n">hsi</span><span class="o">=</span><span class="n">hsi</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">attributions</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">score</span><span class="o">=</span><span class="n">approximation_error</span><span class="p">,</span>
            <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">attributes</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.meteors.attr.input_x_gradients.InputXGradient" class="doc doc-heading">
            <code>InputXGradient</code>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="meteors.attr.Explainer">Explainer</span></code></p>


        <p>Initializes the InputXGradient explainer. The InputXGradients method is a straightforward approach to
computing attribution. It simply multiplies the input image with the gradient with respect to the input.
This method is based on the <a href="https://captum.ai/api/input_x_gradient.html"><code>captum</code> implementation</a></p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.input_x_gradients.InputXGradient._attribution_method">_attribution_method</span></code></td>
            <td>
                  <code>CaptumIntegratedGradients</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The InputXGradient method from the <code>captum</code> library.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/input_x_gradients.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">InputXGradient</span><span class="p">(</span><span class="n">Explainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initializes the InputXGradient explainer. The InputXGradients method is a straightforward approach to</span>
<span class="sd">    computing attribution. It simply multiplies the input image with the gradient with respect to the input.</span>
<span class="sd">    This method is based on the [`captum` implementation](https://captum.ai/api/input_x_gradient.html)</span>

<span class="sd">    Attributes:</span>
<span class="sd">        _attribution_method (CaptumIntegratedGradients): The InputXGradient method from the `captum` library.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">explainable_model</span><span class="p">:</span> <span class="n">ExplainableModel</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">explainable_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="o">=</span> <span class="n">CaptumInputXGradient</span><span class="p">(</span><span class="n">explainable_model</span><span class="o">.</span><span class="n">forward_func</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributes</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;InputXGradient explainer is not initialized&quot;</span><span class="p">)</span>

        <span class="n">gradient_attribution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
            <span class="n">hsi</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span>
        <span class="p">)</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="n">HSIAttributes</span><span class="p">(</span>
            <span class="n">hsi</span><span class="o">=</span><span class="n">hsi</span><span class="p">,</span> <span class="n">attributes</span><span class="o">=</span><span class="n">gradient_attribution</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">attributes</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.meteors.attr.occlusion.Occlusion" class="doc doc-heading">
            <code>Occlusion</code>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="meteors.attr.Explainer">Explainer</span></code></p>


        <p>Occlusion explainer class for generating attributions using the Occlusion method.
This attribution method perturbs the input by replacing the contiguous rectangular region
with a given baseline and computing the difference in output.
In our case, features are located in multiple regions, and attribution from different hyper-rectangles is averaged.
The implementation of this method is also based on the <a href="https://captum.ai/api/occlusion.html"><code>captum</code> repository</a>.
More details about this approach can be found in the <a href="https://arxiv.org/abs/1311.2901">original paper</a></p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.occlusion.Occlusion._attribution_method">_attribution_method</span></code></td>
            <td>
                  <code><span title="captum.attr.Occlusion">Occlusion</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The Occlusion method from the <code>captum</code> library.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/occlusion.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Occlusion</span><span class="p">(</span><span class="n">Explainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Occlusion explainer class for generating attributions using the Occlusion method.</span>
<span class="sd">    This attribution method perturbs the input by replacing the contiguous rectangular region</span>
<span class="sd">    with a given baseline and computing the difference in output.</span>
<span class="sd">    In our case, features are located in multiple regions, and attribution from different hyper-rectangles is averaged.</span>
<span class="sd">    The implementation of this method is also based on the [`captum` repository](https://captum.ai/api/occlusion.html).</span>
<span class="sd">    More details about this approach can be found in the [original paper](https://arxiv.org/abs/1311.2901)</span>

<span class="sd">    Attributes:</span>
<span class="sd">        _attribution_method (CaptumOcclusion): The Occlusion method from the `captum` library.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">explainable_model</span><span class="p">:</span> <span class="n">ExplainableModel</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">explainable_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="o">=</span> <span class="n">CaptumOcclusion</span><span class="p">(</span><span class="n">explainable_model</span><span class="o">.</span><span class="n">forward_func</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">sliding_window_shapes</span><span class="p">,</span>
        <span class="n">strides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># TODO add default value</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">baseline</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">perturbations_per_eval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">show_progress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributes</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Occlusion explainer is not initialized&quot;</span><span class="p">)</span>

        <span class="n">baseline</span> <span class="o">=</span> <span class="n">validate_and_transform_baseline</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="n">hsi</span><span class="p">)</span>

        <span class="n">occlusion_attributions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
            <span class="n">hsi</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">sliding_window_shapes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
            <span class="o">+</span> <span class="n">sliding_window_shapes</span><span class="p">,</span>  <span class="c1"># I&#39;am not sure about this scaling method - need to check how exactly occlusion modifies the image shape</span>
            <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">strides</span><span class="p">,</span>
            <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
            <span class="n">baselines</span><span class="o">=</span><span class="n">baseline</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span><span class="p">,</span>
            <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="n">perturbations_per_eval</span><span class="p">,</span>
            <span class="n">show_progress</span><span class="o">=</span><span class="n">show_progress</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">occlusion_attributions</span> <span class="o">=</span> <span class="n">occlusion_attributions</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="n">HSIAttributes</span><span class="p">(</span><span class="n">hsi</span><span class="o">=</span><span class="n">hsi</span><span class="p">,</span> <span class="n">attributes</span><span class="o">=</span><span class="n">occlusion_attributions</span><span class="p">,</span> <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">attributes</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.meteors.attr.saliency.Saliency" class="doc doc-heading">
            <code>Saliency</code>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="meteors.attr.Explainer">Explainer</span></code></p>


        <p>Saliency explainer class for generating attributions using the Saliency method.
This baseline method for computing input attribution calculates gradients with respect to inputs.
It also has an option to return the absolute value of the gradients, which is the default behaviour.
Implementation of this method is based on the <a href="https://captum.ai/api/saliency.html"><code>captum</code> repository</a></p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.saliency.Saliency._attribution_method">_attribution_method</span></code></td>
            <td>
                  <code><span title="captum.attr.Saliency">Saliency</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The Saliency method from the <code>captum</code> library.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/saliency.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Saliency</span><span class="p">(</span><span class="n">Explainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Saliency explainer class for generating attributions using the Saliency method.</span>
<span class="sd">    This baseline method for computing input attribution calculates gradients with respect to inputs.</span>
<span class="sd">    It also has an option to return the absolute value of the gradients, which is the default behaviour.</span>
<span class="sd">    Implementation of this method is based on the [`captum` repository](https://captum.ai/api/saliency.html)</span>

<span class="sd">    Attributes:</span>
<span class="sd">        _attribution_method (CaptumSaliency): The Saliency method from the `captum` library.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">explainable_model</span><span class="p">:</span> <span class="n">ExplainableModel</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">explainable_model</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="o">=</span> <span class="n">CaptumSaliency</span><span class="p">(</span><span class="n">explainable_model</span><span class="o">.</span><span class="n">forward_func</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="nb">abs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributes</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Saliency explainer is not initialized&quot;</span><span class="p">)</span>

        <span class="n">saliency_attributions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
            <span class="n">hsi</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="nb">abs</span><span class="o">=</span><span class="nb">abs</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span>
        <span class="p">)</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="n">HSIAttributes</span><span class="p">(</span>
            <span class="n">hsi</span><span class="o">=</span><span class="n">hsi</span><span class="p">,</span> <span class="n">attributes</span><span class="o">=</span><span class="n">saliency_attributions</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">attributes</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.meteors.attr.noise_tunnel.NoiseTunnel" class="doc doc-heading">
            <code>NoiseTunnel</code>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="meteors.attr.Explainer">Explainer</span></code></p>


        <p>NoiseTunnel explainer class for generating attributions using the Noise Tunnel method.
This attribution method works on top of a different one to better approximate its explanations.
The Noise Tunnel (Smooth Grad) adds Gaussian noise to each input in the batch and applies the given attribution algorithm to each modified sample.
This method is based on the <a href="https://captum.ai/api/noise_tunnel.html"><code>captum</code> implementation</a></p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.noise_tunnel.NoiseTunnel._attribution_method">_attribution_method</span></code></td>
            <td>
                  <code><span title="captum.attr.NoiseTunnel">NoiseTunnel</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The Noise Tunnel method from the <code>captum</code> library.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/noise_tunnel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">NoiseTunnel</span><span class="p">(</span><span class="n">Explainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    NoiseTunnel explainer class for generating attributions using the Noise Tunnel method.</span>
<span class="sd">    This attribution method works on top of a different one to better approximate its explanations.</span>
<span class="sd">    The Noise Tunnel (Smooth Grad) adds Gaussian noise to each input in the batch and applies the given attribution algorithm to each modified sample.</span>
<span class="sd">    This method is based on the [`captum` implementation](https://captum.ai/api/noise_tunnel.html)</span>

<span class="sd">    Attributes:</span>
<span class="sd">        _attribution_method (CaptumNoiseTunnel): The Noise Tunnel method from the `captum` library.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribution_method</span><span class="p">:</span> <span class="n">Explainer</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">attribution_method</span><span class="p">)</span>
        <span class="n">validate_attribution_method_initialization</span><span class="p">(</span><span class="n">attribution_method</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="o">=</span> <span class="n">CaptumNoiseTunnel</span><span class="p">(</span><span class="n">attribution_method</span><span class="o">.</span><span class="n">_attribution_method</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nt_type</span><span class="o">=</span><span class="s2">&quot;smoothgrad&quot;</span><span class="p">,</span>
        <span class="n">nt_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">nt_samples_batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">stdevs</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">draw_baseline_from_distrib</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributes</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;NoiseTunnel explainer is not initialized&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chained_explainer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The attribution method </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chained_explainer</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> is not properly initialized&quot;</span>
            <span class="p">)</span>

        <span class="n">noise_tunnel_attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
            <span class="n">hsi</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
            <span class="n">nt_type</span><span class="o">=</span><span class="n">nt_type</span><span class="p">,</span>
            <span class="n">nt_samples</span><span class="o">=</span><span class="n">nt_samples</span><span class="p">,</span>
            <span class="n">nt_samples_batch_size</span><span class="o">=</span><span class="n">nt_samples_batch_size</span><span class="p">,</span>
            <span class="n">stdevs</span><span class="o">=</span><span class="n">stdevs</span><span class="p">,</span>
            <span class="n">draw_baseline_from_distrib</span><span class="o">=</span><span class="n">draw_baseline_from_distrib</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">attributes</span> <span class="o">=</span> <span class="n">HSIAttributes</span><span class="p">(</span>
            <span class="n">hsi</span><span class="o">=</span><span class="n">hsi</span><span class="p">,</span> <span class="n">attributes</span><span class="o">=</span><span class="n">noise_tunnel_attributes</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">attributes</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div><h3 id="hyper-noise-tunnel">Hyper Noise Tunnel</h3>


<div class="doc doc-object doc-class">



<h4 id="src.meteors.attr.hyper_noise_tunnel.HyperNoiseTunnel" class="doc doc-heading">
            <code>HyperNoiseTunnel</code>


</h4>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="meteors.attr.Explainer">Explainer</span></code></p>


        <p>Hyper Noise Tunnel is our novel method, designed specifically to explain hyperspectral satellite images. It is
inspired by the behaviour of the classical Noise Tunnel (Smooth Grad) method, but instead of sampling noise into the
original image, it randomly removes some of the bands. In the process, the created <em>noised</em> samples are close to the
distribution of the original image yet differ enough to smoothen the produced attribution map.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.hyper_noise_tunnel.HyperNoiseTunnel._attribution_method">_attribution_method</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="src.meteors.attr.hyper_noise_tunnel.BaseHyperNoiseTunnel" href="#src.meteors.attr.hyper_noise_tunnel.BaseHyperNoiseTunnel">BaseHyperNoiseTunnel</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The Hyper Noise Base Tunnel method</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/hyper_noise_tunnel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">HyperNoiseTunnel</span><span class="p">(</span><span class="n">Explainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Hyper Noise Tunnel is our novel method, designed specifically to explain hyperspectral satellite images. It is</span>
<span class="sd">    inspired by the behaviour of the classical Noise Tunnel (Smooth Grad) method, but instead of sampling noise into the</span>
<span class="sd">    original image, it randomly removes some of the bands. In the process, the created _noised_ samples are close to the</span>
<span class="sd">    distribution of the original image yet differ enough to smoothen the produced attribution map.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        _attribution_method (BaseHyperNoiseTunnel): The Hyper Noise Base Tunnel method</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribution_method</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">attribution_method</span><span class="p">)</span>
        <span class="n">validate_attribution_method_initialization</span><span class="p">(</span><span class="n">attribution_method</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="p">:</span> <span class="n">Attribution</span> <span class="o">=</span> <span class="n">BaseHyperNoiseTunnel</span><span class="p">(</span><span class="n">attribution_method</span><span class="o">.</span><span class="n">_attribution_method</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">baselines</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">steps_per_batch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">perturbation_prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">num_perturbed_bands</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;smoothgrad&quot;</span><span class="p">,</span> <span class="s2">&quot;smoothgrad_sq&quot;</span><span class="p">,</span> <span class="s2">&quot;vargrad&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;smoothgrad&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">change_orientation</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">original_orientation</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span> <span class="o">!=</span> <span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">):</span>
            <span class="n">change_orientation</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">original_orientation</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The hsi orientation is </span><span class="si">{</span><span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span><span class="si">}</span><span class="s2">. Switching the orientation to (&#39;C&#39;, &#39;H&#39;, &#39;W&#39;)&quot;</span><span class="p">)</span>
            <span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">change_orientation</span><span class="p">(</span><span class="s2">&quot;CHW&quot;</span><span class="p">)</span>

        <span class="n">baselines</span> <span class="o">=</span> <span class="n">validate_and_transform_baseline</span><span class="p">(</span><span class="n">baselines</span><span class="p">,</span> <span class="n">hsi</span><span class="p">)</span>

        <span class="n">attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
            <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="p">,</span>
            <span class="n">baselines</span><span class="o">=</span><span class="n">baselines</span><span class="p">,</span>
            <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
            <span class="n">n_samples</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
            <span class="n">steps_per_batch</span><span class="o">=</span><span class="n">steps_per_batch</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">perturbation_prob</span><span class="o">=</span><span class="n">perturbation_prob</span><span class="p">,</span>
            <span class="n">num_perturbed_bands</span><span class="o">=</span><span class="n">num_perturbed_bands</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">hsi_attributes</span> <span class="o">=</span> <span class="n">HSIAttributes</span><span class="p">(</span><span class="n">hsi</span><span class="o">=</span><span class="n">hsi</span><span class="p">,</span> <span class="n">attributes</span><span class="o">=</span><span class="n">attributes</span><span class="p">,</span> <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">())</span>

        <span class="c1"># change back the attributes orientation</span>
        <span class="k">if</span> <span class="n">change_orientation</span><span class="p">:</span>
            <span class="n">hsi_attributes</span> <span class="o">=</span> <span class="n">hsi_attributes</span><span class="o">.</span><span class="n">change_orientation</span><span class="p">(</span><span class="n">original_orientation</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">hsi_attributes</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h4 id="src.meteors.attr.hyper_noise_tunnel.BaseHyperNoiseTunnel" class="doc doc-heading">
            <code>BaseHyperNoiseTunnel</code>


</h4>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="captum.attr.Attribution">Attribution</span></code></p>


        <p>Compute the attribution of the given inputs using the hyper noise tunnel method.</p>

              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/hyper_noise_tunnel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">BaseHyperNoiseTunnel</span><span class="p">(</span><span class="n">Attribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the attribution of the given inputs using the hyper noise tunnel method.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">GradientAttribution</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attribute_main</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">attribute</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attribute_main</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;abs&quot;</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attribute_main</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attribute_main</span><span class="p">,</span> <span class="nb">abs</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">perturb_input</span><span class="p">(</span>
        <span class="nb">input</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">perturbation_prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">num_perturbed_bands</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The perturbation function used in the hyper noise tunnel. It randomly selects a subset of the input bands</span>
<span class="sd">        that will be masked out and replaced with the baseline. The parameters `num_perturbed_bands` and</span>
<span class="sd">        `perturbation_prob` control the number of bands that will be perturbed (masked). If `num_perturbed_bands` is</span>
<span class="sd">        set, it will be used as the number of bands to perturb, which will be randomly selected. Otherwise, the number</span>
<span class="sd">        of bands will be drawn from a binomial distribution with `perturbation_prob` as the probability of success.</span>

<span class="sd">        Args:</span>
<span class="sd">            input (torch.Tensor): An input tensor to be perturbed. It should have the shape (C, H, W).</span>
<span class="sd">            baseline (torch.Tensor): A baseline tensor to replace the perturbed bands.</span>
<span class="sd">            n_samples (int): A number of samples to be drawn - number of perturbed inputs to be generated.</span>
<span class="sd">            perturbation_prob (float, optional): A probability that each band will be perturbed intependently. Defaults to 0.5.</span>
<span class="sd">            num_perturbed_bands (int | None, optional): A number of perturbed bands in the whole image. If set to None, the bands are perturbed with probability `perturbation_prob` each. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A perturbed tensor, which contains `n_samples` perturbed inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># validate the baseline against the input</span>
        <span class="k">if</span> <span class="n">baseline</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Baseline shape </span><span class="si">{</span><span class="n">baseline</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> does not match input shape </span><span class="si">{</span><span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n_samples</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of perturbated samples to be generated must be greater than 0&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">perturbation_prob</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">perturbation_prob</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Perturbation probability must be in the range [0, 1]&quot;</span><span class="p">)</span>

        <span class="c1"># the perturbation</span>
        <span class="n">perturbed_input</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># repeat the perturbed_input on the first dimension n_samples times</span>
        <span class="n">perturbed_input</span> <span class="o">=</span> <span class="n">perturbed_input</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">n_samples_x_channels_shape</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">n_samples</span><span class="p">,</span>
            <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">)</span>  <span class="c1"># shape of the tensor containing the perturbed channels for each sample</span>

        <span class="n">channels_to_be_perturbed</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_samples_x_channels_shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">bool</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">num_perturbed_bands</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channel_perturbation_probabilities</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_samples_x_channels_shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">*</span> <span class="n">perturbation_prob</span>
            <span class="p">)</span>
            <span class="n">channels_to_be_perturbed</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">bernoulli</span><span class="p">(</span><span class="n">channel_perturbation_probabilities</span><span class="p">)</span><span class="o">.</span><span class="n">bool</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num_perturbed_bands</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">num_perturbed_bands</span> <span class="o">&gt;</span> <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot perturb </span><span class="si">{</span><span class="n">num_perturbed_bands</span><span class="si">}</span><span class="s2"> bands in the input with </span><span class="si">{</span><span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> channels. The number of perturbed bands must be in the range [0, </span><span class="si">{</span><span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">]&quot;</span>
                <span class="p">)</span>

            <span class="n">channels_to_be_perturbed</span> <span class="o">=</span> <span class="n">torch_random_choice</span><span class="p">(</span>
                <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num_perturbed_bands</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">device</span>
            <span class="p">)</span>

        <span class="c1"># now having chosen the perturbed channels, we can replace them with the baseline</span>

        <span class="n">reshaped_baseline</span> <span class="o">=</span> <span class="n">baseline</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">perturbed_input</span><span class="p">[</span><span class="n">channels_to_be_perturbed</span><span class="p">]</span> <span class="o">=</span> <span class="n">reshaped_baseline</span><span class="p">[</span><span class="n">channels_to_be_perturbed</span><span class="p">]</span>

        <span class="n">perturbed_input</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">perturbed_input</span>

    <span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">baselines</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">steps_per_batch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;smoothgrad&quot;</span><span class="p">,</span>
        <span class="n">perturbation_prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">num_perturbed_bands</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;smoothgrad&quot;</span><span class="p">,</span> <span class="s2">&quot;smoothgrad_sq&quot;</span><span class="p">,</span> <span class="s2">&quot;vargrad&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Method must be one of &#39;smoothgrad&#39;, &#39;smoothgrad_sq&#39;, &#39;vargrad&#39;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inputs</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">inputs</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input must be in the format (N, C, H, W)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baselines</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baselines</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baselines</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Baselines must be a tensor or a scalar&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baselines</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baselines</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">baselines</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">baselines</span>
        <span class="k">elif</span> <span class="n">baselines</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">baselines</span> <span class="o">=</span> <span class="n">baselines</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">baselines</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Baselines must be in the format (C, H, W)&quot;</span><span class="p">)</span>

        <span class="n">attributions</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,)</span> <span class="o">+</span> <span class="n">inputs</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">inputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="nb">input</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">batch</span><span class="p">]</span>
            <span class="n">perturbed_input</span> <span class="o">=</span> <span class="n">BaseHyperNoiseTunnel</span><span class="o">.</span><span class="n">perturb_input</span><span class="p">(</span>
                <span class="nb">input</span><span class="p">,</span> <span class="n">baselines</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">perturbation_prob</span><span class="p">,</span> <span class="n">num_perturbed_bands</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">steps_per_batch</span><span class="p">):</span>
                <span class="n">perturbed_batch</span> <span class="o">=</span> <span class="n">perturbed_input</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">steps_per_batch</span><span class="p">]</span>
                <span class="n">attributions</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">steps_per_batch</span><span class="p">,</span> <span class="n">batch</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attribute_main</span><span class="p">(</span>
                    <span class="n">perturbed_batch</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">steps_left</span> <span class="o">=</span> <span class="n">n_samples</span> <span class="o">%</span> <span class="n">steps_per_batch</span>
                <span class="k">if</span> <span class="n">steps_left</span><span class="p">:</span>
                    <span class="n">perturbed_batch</span> <span class="o">=</span> <span class="n">perturbed_input</span><span class="p">[</span><span class="o">-</span><span class="n">steps_left</span><span class="p">:]</span>
                    <span class="n">attributions</span><span class="p">[</span><span class="o">-</span><span class="n">steps_left</span><span class="p">:,</span> <span class="n">batch</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attribute_main</span><span class="p">(</span>
                        <span class="n">perturbed_batch</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;smoothgrad&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">attributions</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;smoothgrad_sq&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">attributions</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">attributions</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">attributions</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h5 id="src.meteors.attr.hyper_noise_tunnel.BaseHyperNoiseTunnel.perturb_input" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">perturb_input</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">perturbation_prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">num_perturbed_bands</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h5>


    <div class="doc doc-contents ">

        <p>The perturbation function used in the hyper noise tunnel. It randomly selects a subset of the input bands
that will be masked out and replaced with the baseline. The parameters <code>num_perturbed_bands</code> and
<code>perturbation_prob</code> control the number of bands that will be perturbed (masked). If <code>num_perturbed_bands</code> is
set, it will be used as the number of bands to perturb, which will be randomly selected. Otherwise, the number
of bands will be drawn from a binomial distribution with <code>perturbation_prob</code> as the probability of success.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>input</code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An input tensor to be perturbed. It should have the shape (C, H, W).</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>baseline</code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A baseline tensor to replace the perturbed bands.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>n_samples</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A number of samples to be drawn - number of perturbed inputs to be generated.</p>
              </div>
            </td>
            <td>
                  <code>1</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>perturbation_prob</code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A probability that each band will be perturbed intependently. Defaults to 0.5.</p>
              </div>
            </td>
            <td>
                  <code>0.5</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>num_perturbed_bands</code></td>
            <td>
                  <code>int | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A number of perturbed bands in the whole image. If set to None, the bands are perturbed with probability <code>perturbation_prob</code> each. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: A perturbed tensor, which contains <code>n_samples</code> perturbed inputs.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/hyper_noise_tunnel.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">perturb_input</span><span class="p">(</span>
    <span class="nb">input</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">perturbation_prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">num_perturbed_bands</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The perturbation function used in the hyper noise tunnel. It randomly selects a subset of the input bands</span>
<span class="sd">    that will be masked out and replaced with the baseline. The parameters `num_perturbed_bands` and</span>
<span class="sd">    `perturbation_prob` control the number of bands that will be perturbed (masked). If `num_perturbed_bands` is</span>
<span class="sd">    set, it will be used as the number of bands to perturb, which will be randomly selected. Otherwise, the number</span>
<span class="sd">    of bands will be drawn from a binomial distribution with `perturbation_prob` as the probability of success.</span>

<span class="sd">    Args:</span>
<span class="sd">        input (torch.Tensor): An input tensor to be perturbed. It should have the shape (C, H, W).</span>
<span class="sd">        baseline (torch.Tensor): A baseline tensor to replace the perturbed bands.</span>
<span class="sd">        n_samples (int): A number of samples to be drawn - number of perturbed inputs to be generated.</span>
<span class="sd">        perturbation_prob (float, optional): A probability that each band will be perturbed intependently. Defaults to 0.5.</span>
<span class="sd">        num_perturbed_bands (int | None, optional): A number of perturbed bands in the whole image. If set to None, the bands are perturbed with probability `perturbation_prob` each. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: A perturbed tensor, which contains `n_samples` perturbed inputs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># validate the baseline against the input</span>
    <span class="k">if</span> <span class="n">baseline</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Baseline shape </span><span class="si">{</span><span class="n">baseline</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> does not match input shape </span><span class="si">{</span><span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_samples</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of perturbated samples to be generated must be greater than 0&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">perturbation_prob</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">perturbation_prob</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Perturbation probability must be in the range [0, 1]&quot;</span><span class="p">)</span>

    <span class="c1"># the perturbation</span>
    <span class="n">perturbed_input</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># repeat the perturbed_input on the first dimension n_samples times</span>
    <span class="n">perturbed_input</span> <span class="o">=</span> <span class="n">perturbed_input</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">n_samples_x_channels_shape</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">n_samples</span><span class="p">,</span>
        <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">)</span>  <span class="c1"># shape of the tensor containing the perturbed channels for each sample</span>

    <span class="n">channels_to_be_perturbed</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_samples_x_channels_shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">bool</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">num_perturbed_bands</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">channel_perturbation_probabilities</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_samples_x_channels_shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">*</span> <span class="n">perturbation_prob</span>
        <span class="p">)</span>
        <span class="n">channels_to_be_perturbed</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">bernoulli</span><span class="p">(</span><span class="n">channel_perturbation_probabilities</span><span class="p">)</span><span class="o">.</span><span class="n">bool</span><span class="p">()</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num_perturbed_bands</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">num_perturbed_bands</span> <span class="o">&gt;</span> <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot perturb </span><span class="si">{</span><span class="n">num_perturbed_bands</span><span class="si">}</span><span class="s2"> bands in the input with </span><span class="si">{</span><span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> channels. The number of perturbed bands must be in the range [0, </span><span class="si">{</span><span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">]&quot;</span>
            <span class="p">)</span>

        <span class="n">channels_to_be_perturbed</span> <span class="o">=</span> <span class="n">torch_random_choice</span><span class="p">(</span>
            <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num_perturbed_bands</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">device</span>
        <span class="p">)</span>

    <span class="c1"># now having chosen the perturbed channels, we can replace them with the baseline</span>

    <span class="n">reshaped_baseline</span> <span class="o">=</span> <span class="n">baseline</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">perturbed_input</span><span class="p">[</span><span class="n">channels_to_be_perturbed</span><span class="p">]</span> <span class="o">=</span> <span class="n">reshaped_baseline</span><span class="p">[</span><span class="n">channels_to_be_perturbed</span><span class="p">]</span>

    <span class="n">perturbed_input</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">perturbed_input</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"provider": "mike"}}</script>
    
    
      <script src="../assets/javascripts/bundle.56dfad97.min.js"></script>
      
    
  </body>
</html>