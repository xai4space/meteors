
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://xai4space.github.io/meteors/0.2.0/reference/">
      
      
        <link rel="prev" href="../tutorials/segmentation/">
      
      
        <link rel="next" href="../changelog/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.48">
    
    
      
        <title>📖 API Reference - Meteors</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.6f8fc17f.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
      <link rel="stylesheet" href="../stylesheets/extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="custom" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#api-reference" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <div data-md-color-scheme="default" data-md-component="outdated" hidden>
        
      </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Meteors" class="md-header__button md-logo" aria-label="Meteors" data-md-component="logo">
      
  <img src="../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Meteors
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              📖 API Reference
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="custom" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7M9 21v-1h6v1a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1m3-17a5 5 0 0 0-5 5c0 2.05 1.23 3.81 3 4.58V16h4v-2.42c1.77-.77 3-2.53 3-4.58a5 5 0 0 0-5-5"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="custom" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 0-7 7c0 2.38 1.19 4.47 3 5.74V17a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-2.26c1.81-1.27 3-3.36 3-5.74a7 7 0 0 0-7-7M9 21a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-1H9z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/xai4space/meteors" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    xai4space/meteors
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Meteors" class="md-nav__button md-logo" aria-label="Meteors" data-md-component="logo">
      
  <img src="../assets/logo.png" alt="logo">

    </a>
    Meteors
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/xai4space/meteors" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    xai4space/meteors
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    🏠 Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../quickstart/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    🚀 Quickstart
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    📚 Tutorials
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            📚 Tutorials
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/introduction/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    🎓 Introduction
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/lime/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    LIME
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/attr_showcase/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Attribution Methods `attr`
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorials/segmentation/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Segmentation
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    📖 API Reference
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    📖 API Reference
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#hyperspectral-image" class="md-nav__link">
    <span class="md-ellipsis">
      HyperSpectral Image
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HyperSpectral Image">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI" class="md-nav__link">
    <span class="md-ellipsis">
      HSI
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSI">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.spatial_binary_mask" class="md-nav__link">
    <span class="md-ellipsis">
      spatial_binary_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.spectral_axis" class="md-nav__link">
    <span class="md-ellipsis">
      spectral_axis
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.change_orientation" class="md-nav__link">
    <span class="md-ellipsis">
      change_orientation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.extract_band_by_name" class="md-nav__link">
    <span class="md-ellipsis">
      extract_band_by_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.get_image" class="md-nav__link">
    <span class="md-ellipsis">
      get_image
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.get_rgb_image" class="md-nav__link">
    <span class="md-ellipsis">
      get_rgb_image
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.to" class="md-nav__link">
    <span class="md-ellipsis">
      to
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#visualizations" class="md-nav__link">
    <span class="md-ellipsis">
      Visualizations
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Visualizations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.hsi_visualize.visualize_hsi" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_hsi
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize" class="md-nav__link">
    <span class="md-ellipsis">
      attr_visualize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize.visualize_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize.visualize_spatial_aggregated_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_spatial_aggregated_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize.visualize_spectral_aggregated_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_spectral_aggregated_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize.visualize_aggregated_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_aggregated_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize.visualize_spectral_attributes_by_waveband" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_spectral_attributes_by_waveband
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize.visualize_spectral_attributes_by_magnitude" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_spectral_attributes_by_magnitude
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize.visualize_spectral_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_spectral_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize.visualize_spatial_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_spatial_attributes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#attribution-methods" class="md-nav__link">
    <span class="md-ellipsis">
      Attribution Methods
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Attribution Methods">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributes" class="md-nav__link">
    <span class="md-ellipsis">
      HSIAttributes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSIAttributes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributes.flattened_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      flattened_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributes.orientation" class="md-nav__link">
    <span class="md-ellipsis">
      orientation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributes.change_orientation" class="md-nav__link">
    <span class="md-ellipsis">
      change_orientation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributes.to" class="md-nav__link">
    <span class="md-ellipsis">
      to
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributesSpatial" class="md-nav__link">
    <span class="md-ellipsis">
      HSIAttributesSpatial
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSIAttributesSpatial">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributesSpatial.flattened_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      flattened_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributesSpatial.segmentation_mask" class="md-nav__link">
    <span class="md-ellipsis">
      segmentation_mask
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributesSpectral" class="md-nav__link">
    <span class="md-ellipsis">
      HSIAttributesSpectral
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSIAttributesSpectral">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributesSpectral.band_mask" class="md-nav__link">
    <span class="md-ellipsis">
      band_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributesSpectral.flattened_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      flattened_attributes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime" class="md-nav__link">
    <span class="md-ellipsis">
      Lime
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Lime">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime.attribute" class="md-nav__link">
    <span class="md-ellipsis">
      attribute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime.get_band_mask" class="md-nav__link">
    <span class="md-ellipsis">
      get_band_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime.get_segmentation_mask" class="md-nav__link">
    <span class="md-ellipsis">
      get_segmentation_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime.get_spatial_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      get_spatial_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime.get_spectral_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      get_spectral_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lime-base" class="md-nav__link">
    <span class="md-ellipsis">
      Lime Base
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.integrated_gradients.IntegratedGradients" class="md-nav__link">
    <span class="md-ellipsis">
      IntegratedGradients
    </span>
  </a>
  
    <nav class="md-nav" aria-label="IntegratedGradients">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.integrated_gradients.IntegratedGradients.attribute" class="md-nav__link">
    <span class="md-ellipsis">
      attribute
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.input_x_gradients.InputXGradient" class="md-nav__link">
    <span class="md-ellipsis">
      InputXGradient
    </span>
  </a>
  
    <nav class="md-nav" aria-label="InputXGradient">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.input_x_gradients.InputXGradient.attribute" class="md-nav__link">
    <span class="md-ellipsis">
      attribute
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.occlusion.Occlusion" class="md-nav__link">
    <span class="md-ellipsis">
      Occlusion
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Occlusion">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.occlusion.Occlusion.attribute" class="md-nav__link">
    <span class="md-ellipsis">
      attribute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.occlusion.Occlusion.get_spatial_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      get_spatial_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.occlusion.Occlusion.get_spectral_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      get_spectral_attributes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.saliency.Saliency" class="md-nav__link">
    <span class="md-ellipsis">
      Saliency
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Saliency">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.saliency.Saliency.attribute" class="md-nav__link">
    <span class="md-ellipsis">
      attribute
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.noise_tunnel.NoiseTunnel" class="md-nav__link">
    <span class="md-ellipsis">
      NoiseTunnel
    </span>
  </a>
  
    <nav class="md-nav" aria-label="NoiseTunnel">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.noise_tunnel.NoiseTunnel.attribute" class="md-nav__link">
    <span class="md-ellipsis">
      attribute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.noise_tunnel.NoiseTunnel.perturb_input" class="md-nav__link">
    <span class="md-ellipsis">
      perturb_input
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.noise_tunnel.HyperNoiseTunnel" class="md-nav__link">
    <span class="md-ellipsis">
      HyperNoiseTunnel
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HyperNoiseTunnel">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.noise_tunnel.HyperNoiseTunnel.attribute" class="md-nav__link">
    <span class="md-ellipsis">
      attribute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.noise_tunnel.HyperNoiseTunnel.perturb_input" class="md-nav__link">
    <span class="md-ellipsis">
      perturb_input
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../changelog/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    📝 Changelog
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../how-to-guides/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    🤝 How to Contribute
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#hyperspectral-image" class="md-nav__link">
    <span class="md-ellipsis">
      HyperSpectral Image
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HyperSpectral Image">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI" class="md-nav__link">
    <span class="md-ellipsis">
      HSI
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSI">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.spatial_binary_mask" class="md-nav__link">
    <span class="md-ellipsis">
      spatial_binary_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.spectral_axis" class="md-nav__link">
    <span class="md-ellipsis">
      spectral_axis
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.change_orientation" class="md-nav__link">
    <span class="md-ellipsis">
      change_orientation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.extract_band_by_name" class="md-nav__link">
    <span class="md-ellipsis">
      extract_band_by_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.get_image" class="md-nav__link">
    <span class="md-ellipsis">
      get_image
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.get_rgb_image" class="md-nav__link">
    <span class="md-ellipsis">
      get_rgb_image
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.hsi.HSI.to" class="md-nav__link">
    <span class="md-ellipsis">
      to
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#visualizations" class="md-nav__link">
    <span class="md-ellipsis">
      Visualizations
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Visualizations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.hsi_visualize.visualize_hsi" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_hsi
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize" class="md-nav__link">
    <span class="md-ellipsis">
      attr_visualize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize.visualize_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize.visualize_spatial_aggregated_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_spatial_aggregated_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize.visualize_spectral_aggregated_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_spectral_aggregated_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize.visualize_aggregated_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_aggregated_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize.visualize_spectral_attributes_by_waveband" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_spectral_attributes_by_waveband
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize.visualize_spectral_attributes_by_magnitude" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_spectral_attributes_by_magnitude
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize.visualize_spectral_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_spectral_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.visualize.attr_visualize.visualize_spatial_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      visualize_spatial_attributes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#attribution-methods" class="md-nav__link">
    <span class="md-ellipsis">
      Attribution Methods
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Attribution Methods">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributes" class="md-nav__link">
    <span class="md-ellipsis">
      HSIAttributes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSIAttributes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributes.flattened_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      flattened_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributes.orientation" class="md-nav__link">
    <span class="md-ellipsis">
      orientation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributes.change_orientation" class="md-nav__link">
    <span class="md-ellipsis">
      change_orientation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributes.to" class="md-nav__link">
    <span class="md-ellipsis">
      to
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributesSpatial" class="md-nav__link">
    <span class="md-ellipsis">
      HSIAttributesSpatial
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSIAttributesSpatial">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributesSpatial.flattened_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      flattened_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributesSpatial.segmentation_mask" class="md-nav__link">
    <span class="md-ellipsis">
      segmentation_mask
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributesSpectral" class="md-nav__link">
    <span class="md-ellipsis">
      HSIAttributesSpectral
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HSIAttributesSpectral">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributesSpectral.band_mask" class="md-nav__link">
    <span class="md-ellipsis">
      band_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.attributes.HSIAttributesSpectral.flattened_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      flattened_attributes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime" class="md-nav__link">
    <span class="md-ellipsis">
      Lime
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Lime">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime.attribute" class="md-nav__link">
    <span class="md-ellipsis">
      attribute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime.get_band_mask" class="md-nav__link">
    <span class="md-ellipsis">
      get_band_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime.get_segmentation_mask" class="md-nav__link">
    <span class="md-ellipsis">
      get_segmentation_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime.get_spatial_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      get_spatial_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.lime.Lime.get_spectral_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      get_spectral_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lime-base" class="md-nav__link">
    <span class="md-ellipsis">
      Lime Base
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.integrated_gradients.IntegratedGradients" class="md-nav__link">
    <span class="md-ellipsis">
      IntegratedGradients
    </span>
  </a>
  
    <nav class="md-nav" aria-label="IntegratedGradients">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.integrated_gradients.IntegratedGradients.attribute" class="md-nav__link">
    <span class="md-ellipsis">
      attribute
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.input_x_gradients.InputXGradient" class="md-nav__link">
    <span class="md-ellipsis">
      InputXGradient
    </span>
  </a>
  
    <nav class="md-nav" aria-label="InputXGradient">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.input_x_gradients.InputXGradient.attribute" class="md-nav__link">
    <span class="md-ellipsis">
      attribute
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.occlusion.Occlusion" class="md-nav__link">
    <span class="md-ellipsis">
      Occlusion
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Occlusion">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.occlusion.Occlusion.attribute" class="md-nav__link">
    <span class="md-ellipsis">
      attribute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.occlusion.Occlusion.get_spatial_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      get_spatial_attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.occlusion.Occlusion.get_spectral_attributes" class="md-nav__link">
    <span class="md-ellipsis">
      get_spectral_attributes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.saliency.Saliency" class="md-nav__link">
    <span class="md-ellipsis">
      Saliency
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Saliency">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.saliency.Saliency.attribute" class="md-nav__link">
    <span class="md-ellipsis">
      attribute
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.noise_tunnel.NoiseTunnel" class="md-nav__link">
    <span class="md-ellipsis">
      NoiseTunnel
    </span>
  </a>
  
    <nav class="md-nav" aria-label="NoiseTunnel">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.noise_tunnel.NoiseTunnel.attribute" class="md-nav__link">
    <span class="md-ellipsis">
      attribute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.noise_tunnel.NoiseTunnel.perturb_input" class="md-nav__link">
    <span class="md-ellipsis">
      perturb_input
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.noise_tunnel.HyperNoiseTunnel" class="md-nav__link">
    <span class="md-ellipsis">
      HyperNoiseTunnel
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HyperNoiseTunnel">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.noise_tunnel.HyperNoiseTunnel.attribute" class="md-nav__link">
    <span class="md-ellipsis">
      attribute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#src.meteors.attr.noise_tunnel.HyperNoiseTunnel.perturb_input" class="md-nav__link">
    <span class="md-ellipsis">
      perturb_input
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="api-reference">API Reference</h1>
<p>The architecture of the package can be seen on the UML diagram:
<img alt="UML diagram of package structure" src="../assets/UML-attribution-methods.png" /></p>
<h2 id="hyperspectral-image">HyperSpectral Image</h2>


<div class="doc doc-object doc-class">



<h3 id="src.meteors.hsi.HSI" class="doc doc-heading">
            <code>HSI</code>


</h3>


    <div class="doc doc-contents first">


        <p>A dataclass for hyperspectral image data, including the image, wavelengths, and binary mask.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.hsi.HSI.image">image</span></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The hyperspectral image data as a PyTorch tensor.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.hsi.HSI.wavelengths">wavelengths</span></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The wavelengths present in the image.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.hsi.HSI.orientation">orientation</span></code></td>
            <td>
                  <code>tuple[str, str, str]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The orientation of the image data.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.hsi.HSI.device">device</span></code></td>
            <td>
                  <code><span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The device to be used for inference.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.hsi.HSI.binary_mask">binary_mask</span></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A binary mask used to cover unimportant parts of the image.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>






              <details class="quote">
                <summary>Source code in <code>src/meteors/hsi.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">HSI</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A dataclass for hyperspectral image data, including the image, wavelengths, and binary mask.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        image (torch.Tensor): The hyperspectral image data as a PyTorch tensor.</span>
<span class="sd">        wavelengths (torch.Tensor): The wavelengths present in the image.</span>
<span class="sd">        orientation (tuple[str, str, str]): The orientation of the image data.</span>
<span class="sd">        device (torch.device): The device to be used for inference.</span>
<span class="sd">        binary_mask (torch.Tensor): A binary mask used to cover unimportant parts of the image.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">image</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>  <span class="c1"># Should always be a first field</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">PlainValidator</span><span class="p">(</span><span class="n">ensure_image_tensor</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;Hyperspectral image. Converted to torch tensor.&quot;</span><span class="p">),</span>
    <span class="p">]</span>
    <span class="n">wavelengths</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">PlainValidator</span><span class="p">(</span><span class="n">ensure_wavelengths_tensor</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;Wavelengths present in the image. Defaults to None.&quot;</span><span class="p">),</span>
    <span class="p">]</span>
    <span class="n">orientation</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
        <span class="n">PlainValidator</span><span class="p">(</span><span class="n">validate_orientation</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">description</span><span class="o">=</span><span class="p">(</span>
                <span class="s1">&#39;Orientation of the image - sequence of three one-letter strings in any order: &quot;C&quot;, &quot;H&quot;, &quot;W&quot; &#39;</span>
                <span class="s1">&#39;meaning respectively channels, height and width of the image. Defaults to (&quot;C&quot;, &quot;H&quot;, &quot;W&quot;).&#39;</span>
            <span class="p">),</span>
        <span class="p">),</span>
    <span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">)</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
        <span class="n">PlainValidator</span><span class="p">(</span><span class="n">resolve_inference_device_hsi</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">validate_default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Device to be used for inference. If None, the device of the input image will be used. Defaults to None.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">binary_mask</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">PlainValidator</span><span class="p">(</span><span class="n">process_and_validate_binary_mask</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">validate_default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Binary mask used to cover not important parts of the base image, masked parts have values equals to 0. &quot;</span>
                <span class="s2">&quot;Converted to torch tensor. Defaults to None.&quot;</span>
            <span class="p">),</span>
        <span class="p">),</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spectral_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the index of the spectral (wavelength) axis based on the current data orientation.</span>

<span class="sd">        In hyperspectral imaging, the spectral axis represents the dimension along which</span>
<span class="sd">        different spectral bands or wavelengths are arranged. This property dynamically</span>
<span class="sd">        determines the index of this axis based on the current orientation of the data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The index of the spectral axis in the current data structure.</span>
<span class="sd">                - 0 for &#39;CHW&#39; or &#39;CWH&#39; orientations (Channel/Wavelength first)</span>
<span class="sd">                - 2 for &#39;HWC&#39; or &#39;WHC&#39; orientations (Channel/Wavelength last)</span>
<span class="sd">                - 1 for &#39;HCW&#39; or &#39;WCH&#39; orientations (Channel/Wavelength in the middle)</span>

<span class="sd">        Note:</span>
<span class="sd">            The orientation is typically represented as a string where:</span>
<span class="sd">            - &#39;C&#39; represents the spectral/wavelength dimension</span>
<span class="sd">            - &#39;H&#39; represents the height (rows) of the image</span>
<span class="sd">            - &#39;W&#39; represents the width (columns) of the image</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI()</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.orientation = &quot;CHW&quot;</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.spectral_axis</span>
<span class="sd">            0</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.orientation = &quot;HWC&quot;</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.spectral_axis</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">get_channel_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spatial_binary_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a 2D spatial representation of the binary mask.</span>

<span class="sd">        This property extracts a single 2D slice from the 3D binary mask, assuming that</span>
<span class="sd">        the mask is identical across all spectral bands. It handles different data</span>
<span class="sd">        orientations by first ensuring the spectral dimension is the last dimension</span>
<span class="sd">        before extracting the 2D spatial mask.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A 2D tensor representing the spatial binary mask.</span>
<span class="sd">                The shape will be (H, W) where H is height and W is width of the image.</span>

<span class="sd">        Note:</span>
<span class="sd">            - This assumes that the binary mask is consistent across all spectral bands.</span>
<span class="sd">            - The returned mask is always 2D, regardless of the original data orientation.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; # If self.binary_mask has shape (100, 100, 5) with spectral_axis=2:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(binary_mask=torch.rand(100, 100, 5), orientation=(&quot;H&quot;, &quot;W&quot;, &quot;C&quot;))</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.spatial_binary_mask.shape</span>
<span class="sd">            torch.Size([100, 100])</span>
<span class="sd">            &gt;&gt;&gt; If self.binary_mask has shape (5, 100, 100) with spectral_axis=0:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(binary_mask=torch.rand(5, 100, 100), orientation=(&quot;C&quot;, &quot;H&quot;, &quot;W&quot;))</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.spatial_binary_mask.shape</span>
<span class="sd">            torch.Size([100, 100])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mask</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">model_config</span> <span class="o">=</span> <span class="n">ConfigDict</span><span class="p">(</span><span class="n">arbitrary_types_allowed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@model_validator</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;after&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">validate_image_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validates the image data by checking the shape of the wavelengths, image, and spectral_axis.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: The instance of the class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validate_shapes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Moves the image and binary mask (if available) to the specified device.</span>

<span class="sd">        Args:</span>
<span class="sd">            device (str or torch.device): The device to move the image and binary mask to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: The updated HSI object.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; # Create an HSI object</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(10, 10, 10), wavelengths=np.arange(10))</span>
<span class="sd">            &gt;&gt;&gt; # Move the image to cpu</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = hsi_image.to(&quot;cpu&quot;)</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.device</span>
<span class="sd">            device(type=&#39;cpu&#39;)</span>
<span class="sd">            &gt;&gt;&gt; # Move the image to cuda</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = hsi_image.to(&quot;cuda&quot;)</span>
<span class="sd">            &gt;&gt;&gt; hsi_image.device</span>
<span class="sd">            device(type=&#39;cuda&#39;, index=0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">device</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">get_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the hyperspectral image data with optional masking applied.</span>

<span class="sd">        Args:</span>
<span class="sd">            apply_mask (bool, optional): Whether to apply the binary mask to the image.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The hyperspectral image data.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - If apply_mask is True, the binary mask will be applied to the image based on the `binary_mask` attribute.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(10, 100, 100), wavelengths=np.linspace(400, 1000, 10))</span>
<span class="sd">            &gt;&gt;&gt; image = hsi_image.get_image()</span>
<span class="sd">            &gt;&gt;&gt; image.shape</span>
<span class="sd">            torch.Size([10, 100, 100])</span>
<span class="sd">            &gt;&gt;&gt; image = hsi_image.get_image(apply_mask=False)</span>
<span class="sd">            &gt;&gt;&gt; image.shape</span>
<span class="sd">            torch.Size([10, 100, 100])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">apply_mask</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>

    <span class="k">def</span> <span class="nf">get_rgb_image</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">apply_min_cutoff</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">output_channel_axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts an RGB representation from the hyperspectral image data.</span>

<span class="sd">        This method creates a 3-channel RGB image by selecting appropriate bands</span>
<span class="sd">        corresponding to red, green, and blue wavelengths from the hyperspectral data.</span>

<span class="sd">        Args:</span>
<span class="sd">            apply_mask (bool, optional): Whether to apply the binary mask to the image.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            apply_min_cutoff (bool, optional): Whether to apply a minimum intensity</span>
<span class="sd">                cutoff to the image. Defaults to False.</span>
<span class="sd">            output_channel_axis (int | None, optional): The axis where the RGB channels</span>
<span class="sd">                should be placed in the output tensor. If None, uses the current spectral</span>
<span class="sd">                axis of the hyperspectral data. Defaults to None.</span>
<span class="sd">            normalize (bool, optional): Whether to normalize the band values to the [0, 1] range.</span>
<span class="sd">                Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The RGB representation of the hyperspectral image.</span>
<span class="sd">                Shape will be either (H, W, 3), (3, H, W), or (H, 3, W) depending on</span>
<span class="sd">                the specified output_channel_axis, where H is height and W is width.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - The RGB bands are extracted using predefined wavelength ranges for R, G, and B.</span>
<span class="sd">            - Each band is normalized independently before combining into the RGB image.</span>
<span class="sd">            - If apply_mask is True, masked areas will be set to zero in the output.</span>
<span class="sd">            - If apply_min_cutoff is True, a minimum intensity threshold is applied to each band.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(10, 100, 100), wavelengths=np.linspace(400, 1000, 10))</span>
<span class="sd">            &gt;&gt;&gt; rgb_image = hsi_image.get_rgb_image()</span>
<span class="sd">            &gt;&gt;&gt; rgb_image.shape</span>
<span class="sd">            torch.Size([100, 100, 3])</span>

<span class="sd">            &gt;&gt;&gt; rgb_image = hsi_image.get_rgb_image(output_channel_axis=0)</span>
<span class="sd">            &gt;&gt;&gt; rgb_image.shape</span>
<span class="sd">            torch.Size([3, 100, 100])</span>

<span class="sd">            &gt;&gt;&gt; rgb_image = hsi_image.get_rgb_image(apply_mask=False, apply_min_cutoff=True)</span>
<span class="sd">            &gt;&gt;&gt; rgb_image.shape</span>
<span class="sd">            torch.Size([100, 100, 3])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">output_channel_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_channel_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span>

        <span class="n">rgb_img</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">extract_band_by_name</span><span class="p">(</span>
                    <span class="n">band</span><span class="p">,</span> <span class="n">apply_mask</span><span class="o">=</span><span class="n">apply_mask</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="n">apply_min_cutoff</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">rgb_img</span>
            <span class="k">if</span> <span class="n">output_channel_axis</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span>
            <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">rgb_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">output_channel_axis</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_extract_central_slice_from_band</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">band_wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">apply_min_cutoff</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts and processes the central wavelength band from a given range in the hyperspectral image.</span>

<span class="sd">        This method selects the central band from a specified range of wavelengths,</span>
<span class="sd">        applies optional processing steps (masking, normalization, and minimum cutoff),</span>
<span class="sd">        and returns the resulting 2D image slice.</span>

<span class="sd">        Args:</span>
<span class="sd">            band_wavelengths (torch.Tensor): The selected wavelengths that define the whole band</span>
<span class="sd">                from which the central slice will be extracted.</span>
<span class="sd">                All of the passed wavelengths must be present in the image.</span>
<span class="sd">            apply_mask (bool, optional): Whether to apply the binary mask to the extracted band.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            apply_min_cutoff (bool, optional): Whether to apply a minimum intensity cutoff.</span>
<span class="sd">                If True, sets the minimum non-zero value to zero after normalization.</span>
<span class="sd">                Defaults to False.</span>
<span class="sd">            normalize (bool, optional): Whether to normalize the band values to [0, 1] range.</span>
<span class="sd">                Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A 2D tensor representing the processed central wavelength band.</span>
<span class="sd">                Shape will be (H, W), where H is height and W is width of the image.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - The central wavelength is determined as the middle index of the provided wavelengths list.</span>
<span class="sd">            - If normalization is applied, it&#39;s done before masking and cutoff operations.</span>
<span class="sd">            - The binary mask, if applied, is expected to have the same spatial dimensions as the image.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(13, 100, 100), wavelengths=np.linspace(400, 1000, 13))</span>
<span class="sd">            &gt;&gt;&gt; band_wavelengths = torch.tensor([500, 600, 650, 700])</span>
<span class="sd">            &gt;&gt;&gt; central_slice = hsi_image._extract_central_slice_from_band(band_wavelengths)</span>
<span class="sd">            &gt;&gt;&gt; central_slice.shape</span>
<span class="sd">            torch.Size([100, 100])</span>

<span class="sd">            &gt;&gt;&gt; # Extract a slice without normalization or masking</span>
<span class="sd">            &gt;&gt;&gt; raw_band = hsi_image._extract_central_slice_from_band(band_wavelengths, apply_mask=False, normalize=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if all wavelengths from the `band_wavelengths` are present in the image</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">wave</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span> <span class="k">for</span> <span class="n">wave</span> <span class="ow">in</span> <span class="n">band_wavelengths</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All of the passed wavelengths must be present in the image&quot;</span><span class="p">)</span>

        <span class="c1"># sort the `band_wavelengths` to ensure the central band is selected</span>
        <span class="n">band_wavelengths</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">band_wavelengths</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

        <span class="n">start_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span> <span class="o">==</span> <span class="n">band_wavelengths</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">relative_center_band_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_wavelengths</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">central_band_index</span> <span class="o">=</span> <span class="n">start_index</span> <span class="o">+</span> <span class="n">relative_center_band_index</span>

        <span class="c1"># Ensure the spectral dimension is the last</span>
        <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="nb">slice</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">central_band_index</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">apply_min_cutoff</span><span class="p">:</span>
                <span class="n">slice_min</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">[</span><span class="nb">slice</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">slice_min</span> <span class="o">=</span> <span class="nb">slice</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

            <span class="n">slice_max</span> <span class="o">=</span> <span class="nb">slice</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">slice_max</span> <span class="o">&gt;</span> <span class="n">slice_min</span><span class="p">:</span>  <span class="c1"># Avoid division by zero</span>
                <span class="nb">slice</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span> <span class="o">-</span> <span class="n">slice_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">slice_max</span> <span class="o">-</span> <span class="n">slice_min</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">apply_min_cutoff</span><span class="p">:</span>
                <span class="nb">slice</span><span class="p">[</span><span class="nb">slice</span> <span class="o">==</span> <span class="nb">slice</span><span class="o">.</span><span class="n">min</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Set minimum values to zero</span>

        <span class="k">if</span> <span class="n">apply_mask</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="nb">slice</span> <span class="o">=</span> <span class="nb">slice</span> <span class="o">*</span> <span class="n">mask</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">central_band_index</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">slice</span>

    <span class="k">def</span> <span class="nf">extract_band_by_name</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">band_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">selection_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;center&quot;</span><span class="p">,</span>
        <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">apply_min_cutoff</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts a single spectral band from the hyperspectral image based on a standardized band name.</span>

<span class="sd">        This method uses the spyndex library to map standardized band names to wavelength ranges,</span>
<span class="sd">        then extracts the corresponding band from the hyperspectral data.</span>

<span class="sd">        Args:</span>
<span class="sd">            band_name (str): The standardized name of the band to extract (e.g., &quot;Red&quot;, &quot;NIR&quot;, &quot;SWIR1&quot;).</span>
<span class="sd">            selection_method (str, optional): The method to use for selecting the band within the wavelength range.</span>
<span class="sd">                Currently, only &quot;center&quot; is supported, which selects the central wavelength.</span>
<span class="sd">                Defaults to &quot;center&quot;.</span>
<span class="sd">            apply_mask (bool, optional): Whether to apply the binary mask to the extracted band.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            apply_min_cutoff (bool, optional): Whether to apply a minimum intensity cutoff after normalization.</span>
<span class="sd">                If True, sets the minimum non-zero value to zero. Defaults to False.</span>
<span class="sd">            normalize (bool, optional): Whether to normalize the band values to the [0, 1] range.</span>
<span class="sd">                Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A 2D tensor representing the extracted and processed spectral band.</span>
<span class="sd">                Shape will be (H, W), where H is height and W is width of the image.</span>

<span class="sd">        Raises:</span>
<span class="sd">            BandSelectionError: If the specified band name is not found in the spyndex library.</span>
<span class="sd">            NotImplementedError: If a selection method other than &quot;center&quot; is specified.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - The spyndex library is used to map band names to wavelength ranges.</span>
<span class="sd">            - Currently, only the &quot;center&quot; selection method is implemented, which chooses</span>
<span class="sd">            the central wavelength within the specified range.</span>
<span class="sd">            - Processing steps are applied in the order: normalization, cutoff, masking.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(200, 100, 100), wavelengths=np.linspace(400, 2500, 200))</span>
<span class="sd">            &gt;&gt;&gt; red_band = hsi_image.extract_band_by_name(&quot;Red&quot;)</span>
<span class="sd">            &gt;&gt;&gt; red_band.shape</span>
<span class="sd">            torch.Size([100, 100])</span>

<span class="sd">            &gt;&gt;&gt; # Extract NIR band without normalization or masking</span>
<span class="sd">            &gt;&gt;&gt; nir_band = hsi_image.extract_band_by_name(&quot;NIR&quot;, apply_mask=False, normalize=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">band_info</span> <span class="o">=</span> <span class="n">spyndex</span><span class="o">.</span><span class="n">bands</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">band_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">band_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">BandSelectionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Band name &#39;</span><span class="si">{</span><span class="n">band_name</span><span class="si">}</span><span class="s2">&#39; not found in the spyndex library&quot;</span><span class="p">)</span>

        <span class="n">min_wave</span><span class="p">,</span> <span class="n">max_wave</span> <span class="o">=</span> <span class="n">band_info</span><span class="o">.</span><span class="n">min_wavelength</span><span class="p">,</span> <span class="n">band_info</span><span class="o">.</span><span class="n">max_wavelength</span>
        <span class="n">selected_wavelengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span> <span class="o">&gt;=</span> <span class="n">min_wave</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span> <span class="o">&lt;=</span> <span class="n">max_wave</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">selection_method</span> <span class="o">==</span> <span class="s2">&quot;center&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_central_slice_from_band</span><span class="p">(</span>
                <span class="n">selected_wavelengths</span><span class="p">,</span> <span class="n">apply_mask</span><span class="o">=</span><span class="n">apply_mask</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="n">apply_min_cutoff</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Selection method &#39;</span><span class="si">{</span><span class="n">selection_method</span><span class="si">}</span><span class="s2">&#39; is not supported. Only &#39;center&#39; is currently available.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">change_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_orientation</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Changes the orientation of the hsi data to the target orientation.</span>

<span class="sd">        Args:</span>
<span class="sd">            target_orientation (tuple[str, str, str], list[str], str): The target orientation for the hsi data.</span>
<span class="sd">                This should be a tuple of three one-letter strings in any order: &quot;C&quot;, &quot;H&quot;, &quot;W&quot;.</span>
<span class="sd">            inplace (bool, optional): Whether to modify the hsi data in place or return a new object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: The updated HSI object with the new orientation.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the target orientation is not a valid tuple of three one-letter strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target_orientation</span> <span class="o">=</span> <span class="n">validate_orientation</span><span class="p">(</span><span class="n">target_orientation</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">hsi</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hsi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">target_orientation</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hsi</span>

        <span class="n">permute_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">target_orientation</span><span class="p">]</span>

        <span class="c1"># permute the image</span>
        <span class="n">hsi</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">permute_dims</span><span class="p">)</span>

        <span class="c1"># permute the binary mask</span>
        <span class="k">if</span> <span class="n">hsi</span><span class="o">.</span><span class="n">binary_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hsi</span><span class="o">.</span><span class="n">binary_mask</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">binary_mask</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">permute_dims</span><span class="p">)</span>

        <span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">target_orientation</span>

        <span class="k">return</span> <span class="n">hsi</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h4 id="src.meteors.hsi.HSI.spatial_binary_mask" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">spatial_binary_mask</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Returns a 2D spatial representation of the binary mask.</p>
<p>This property extracts a single 2D slice from the 3D binary mask, assuming that
the mask is identical across all spectral bands. It handles different data
orientations by first ensuring the spectral dimension is the last dimension
before extracting the 2D spatial mask.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: A 2D tensor representing the spatial binary mask.
The shape will be (H, W) where H is height and W is width of the image.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="note" open>
  <summary>Note</summary>
  <ul>
<li>This assumes that the binary mask is consistent across all spectral bands.</li>
<li>The returned mask is always 2D, regardless of the original data orientation.</li>
</ul>
</details>

<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># If self.binary_mask has shape (100, 100, 5) with spectral_axis=2:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">binary_mask</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">orientation</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">spatial_binary_mask</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([100, 100])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">If</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="n">has</span> <span class="n">shape</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="k">with</span> <span class="n">spectral_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">binary_mask</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">orientation</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">spatial_binary_mask</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([100, 100])</span>
</code></pre></div>
    </div>

</div>

<div class="doc doc-object doc-attribute">



<h4 id="src.meteors.hsi.HSI.spectral_axis" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">spectral_axis</span><span class="p">:</span> <span class="nb">int</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Returns the index of the spectral (wavelength) axis based on the current data orientation.</p>
<p>In hyperspectral imaging, the spectral axis represents the dimension along which
different spectral bands or wavelengths are arranged. This property dynamically
determines the index of this axis based on the current orientation of the data.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>int</code></td>            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The index of the spectral axis in the current data structure.
- 0 for 'CHW' or 'CWH' orientations (Channel/Wavelength first)
- 2 for 'HWC' or 'WHC' orientations (Channel/Wavelength last)
- 1 for 'HCW' or 'WCH' orientations (Channel/Wavelength in the middle)</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="note" open>
  <summary>Note</summary>
  <p>The orientation is typically represented as a string where:
- 'C' represents the spectral/wavelength dimension
- 'H' represents the height (rows) of the image
- 'W' represents the width (columns) of the image</p>
</details>

<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="s2">&quot;CHW&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">spectral_axis</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="s2">&quot;HWC&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">spectral_axis</span>
<span class="go">2</span>
</code></pre></div>
    </div>

</div>



<div class="doc doc-object doc-function">


<h4 id="src.meteors.hsi.HSI.change_orientation" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">change_orientation</span><span class="p">(</span><span class="n">target_orientation</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Changes the orientation of the hsi data to the target orientation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>target_orientation</code>
            </td>
            <td>
                  <code>(tuple[str, str, str], list[str], str)</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The target orientation for the hsi data.
This should be a tuple of three one-letter strings in any order: "C", "H", "W".</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>inplace</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to modify the hsi data in place or return a new object.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Self</code></td>            <td>
                  <code><span title="typing_extensions.Self">Self</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The updated HSI object with the new orientation.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the target orientation is not a valid tuple of three one-letter strings.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">change_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_orientation</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Changes the orientation of the hsi data to the target orientation.</span>

<span class="sd">    Args:</span>
<span class="sd">        target_orientation (tuple[str, str, str], list[str], str): The target orientation for the hsi data.</span>
<span class="sd">            This should be a tuple of three one-letter strings in any order: &quot;C&quot;, &quot;H&quot;, &quot;W&quot;.</span>
<span class="sd">        inplace (bool, optional): Whether to modify the hsi data in place or return a new object.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Self: The updated HSI object with the new orientation.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the target orientation is not a valid tuple of three one-letter strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">target_orientation</span> <span class="o">=</span> <span class="n">validate_orientation</span><span class="p">(</span><span class="n">target_orientation</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">target_orientation</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hsi</span>

    <span class="n">permute_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">target_orientation</span><span class="p">]</span>

    <span class="c1"># permute the image</span>
    <span class="n">hsi</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">permute_dims</span><span class="p">)</span>

    <span class="c1"># permute the binary mask</span>
    <span class="k">if</span> <span class="n">hsi</span><span class="o">.</span><span class="n">binary_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hsi</span><span class="o">.</span><span class="n">binary_mask</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">binary_mask</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">permute_dims</span><span class="p">)</span>

    <span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">target_orientation</span>

    <span class="k">return</span> <span class="n">hsi</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.hsi.HSI.extract_band_by_name" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">extract_band_by_name</span><span class="p">(</span><span class="n">band_name</span><span class="p">,</span> <span class="n">selection_method</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">apply_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Extracts a single spectral band from the hyperspectral image based on a standardized band name.</p>
<p>This method uses the spyndex library to map standardized band names to wavelength ranges,
then extracts the corresponding band from the hyperspectral data.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>band_name</code>
            </td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The standardized name of the band to extract (e.g., "Red", "NIR", "SWIR1").</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>selection_method</code>
            </td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The method to use for selecting the band within the wavelength range.
Currently, only "center" is supported, which selects the central wavelength.
Defaults to "center".</p>
              </div>
            </td>
            <td>
                  <code>&#39;center&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>apply_mask</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to apply the binary mask to the extracted band.
Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>apply_min_cutoff</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to apply a minimum intensity cutoff after normalization.
If True, sets the minimum non-zero value to zero. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>normalize</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to normalize the band values to the [0, 1] range.
Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: A 2D tensor representing the extracted and processed spectral band.
Shape will be (H, W), where H is height and W is width of the image.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="meteors.exceptions.BandSelectionError">BandSelectionError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the specified band name is not found in the spyndex library.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>NotImplementedError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If a selection method other than "center" is specified.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The spyndex library is used to map band names to wavelength ranges.</li>
<li>Currently, only the "center" selection method is implemented, which chooses
the central wavelength within the specified range.</li>
<li>Processing steps are applied in the order: normalization, cutoff, masking.</li>
</ul>
</details>

<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">2500</span><span class="p">,</span> <span class="mi">200</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">red_band</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">extract_band_by_name</span><span class="p">(</span><span class="s2">&quot;Red&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">red_band</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([100, 100])</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Extract NIR band without normalization or masking</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nir_band</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">extract_band_by_name</span><span class="p">(</span><span class="s2">&quot;NIR&quot;</span><span class="p">,</span> <span class="n">apply_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">extract_band_by_name</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">band_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">selection_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;center&quot;</span><span class="p">,</span>
    <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">apply_min_cutoff</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extracts a single spectral band from the hyperspectral image based on a standardized band name.</span>

<span class="sd">    This method uses the spyndex library to map standardized band names to wavelength ranges,</span>
<span class="sd">    then extracts the corresponding band from the hyperspectral data.</span>

<span class="sd">    Args:</span>
<span class="sd">        band_name (str): The standardized name of the band to extract (e.g., &quot;Red&quot;, &quot;NIR&quot;, &quot;SWIR1&quot;).</span>
<span class="sd">        selection_method (str, optional): The method to use for selecting the band within the wavelength range.</span>
<span class="sd">            Currently, only &quot;center&quot; is supported, which selects the central wavelength.</span>
<span class="sd">            Defaults to &quot;center&quot;.</span>
<span class="sd">        apply_mask (bool, optional): Whether to apply the binary mask to the extracted band.</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">        apply_min_cutoff (bool, optional): Whether to apply a minimum intensity cutoff after normalization.</span>
<span class="sd">            If True, sets the minimum non-zero value to zero. Defaults to False.</span>
<span class="sd">        normalize (bool, optional): Whether to normalize the band values to the [0, 1] range.</span>
<span class="sd">            Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: A 2D tensor representing the extracted and processed spectral band.</span>
<span class="sd">            Shape will be (H, W), where H is height and W is width of the image.</span>

<span class="sd">    Raises:</span>
<span class="sd">        BandSelectionError: If the specified band name is not found in the spyndex library.</span>
<span class="sd">        NotImplementedError: If a selection method other than &quot;center&quot; is specified.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The spyndex library is used to map band names to wavelength ranges.</span>
<span class="sd">        - Currently, only the &quot;center&quot; selection method is implemented, which chooses</span>
<span class="sd">        the central wavelength within the specified range.</span>
<span class="sd">        - Processing steps are applied in the order: normalization, cutoff, masking.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(200, 100, 100), wavelengths=np.linspace(400, 2500, 200))</span>
<span class="sd">        &gt;&gt;&gt; red_band = hsi_image.extract_band_by_name(&quot;Red&quot;)</span>
<span class="sd">        &gt;&gt;&gt; red_band.shape</span>
<span class="sd">        torch.Size([100, 100])</span>

<span class="sd">        &gt;&gt;&gt; # Extract NIR band without normalization or masking</span>
<span class="sd">        &gt;&gt;&gt; nir_band = hsi_image.extract_band_by_name(&quot;NIR&quot;, apply_mask=False, normalize=False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">band_info</span> <span class="o">=</span> <span class="n">spyndex</span><span class="o">.</span><span class="n">bands</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">band_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">band_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">BandSelectionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Band name &#39;</span><span class="si">{</span><span class="n">band_name</span><span class="si">}</span><span class="s2">&#39; not found in the spyndex library&quot;</span><span class="p">)</span>

    <span class="n">min_wave</span><span class="p">,</span> <span class="n">max_wave</span> <span class="o">=</span> <span class="n">band_info</span><span class="o">.</span><span class="n">min_wavelength</span><span class="p">,</span> <span class="n">band_info</span><span class="o">.</span><span class="n">max_wavelength</span>
    <span class="n">selected_wavelengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span> <span class="o">&gt;=</span> <span class="n">min_wave</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span> <span class="o">&lt;=</span> <span class="n">max_wave</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">selection_method</span> <span class="o">==</span> <span class="s2">&quot;center&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_central_slice_from_band</span><span class="p">(</span>
            <span class="n">selected_wavelengths</span><span class="p">,</span> <span class="n">apply_mask</span><span class="o">=</span><span class="n">apply_mask</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="n">apply_min_cutoff</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Selection method &#39;</span><span class="si">{</span><span class="n">selection_method</span><span class="si">}</span><span class="s2">&#39; is not supported. Only &#39;center&#39; is currently available.&quot;</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.hsi.HSI.get_image" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_image</span><span class="p">(</span><span class="n">apply_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Returns the hyperspectral image data with optional masking applied.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>apply_mask</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to apply the binary mask to the image.
Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Returns:
    torch.Tensor: The hyperspectral image data.</p>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>If apply_mask is True, the binary mask will be applied to the image based on the <code>binary_mask</code> attribute.</li>
</ul>
</details>

<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([10, 100, 100])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">get_image</span><span class="p">(</span><span class="n">apply_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([10, 100, 100])</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the hyperspectral image data with optional masking applied.</span>

<span class="sd">    Args:</span>
<span class="sd">        apply_mask (bool, optional): Whether to apply the binary mask to the image.</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: The hyperspectral image data.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - If apply_mask is True, the binary mask will be applied to the image based on the `binary_mask` attribute.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(10, 100, 100), wavelengths=np.linspace(400, 1000, 10))</span>
<span class="sd">        &gt;&gt;&gt; image = hsi_image.get_image()</span>
<span class="sd">        &gt;&gt;&gt; image.shape</span>
<span class="sd">        torch.Size([10, 100, 100])</span>
<span class="sd">        &gt;&gt;&gt; image = hsi_image.get_image(apply_mask=False)</span>
<span class="sd">        &gt;&gt;&gt; image.shape</span>
<span class="sd">        torch.Size([10, 100, 100])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">apply_mask</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.hsi.HSI.get_rgb_image" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_rgb_image</span><span class="p">(</span><span class="n">apply_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_channel_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Extracts an RGB representation from the hyperspectral image data.</p>
<p>This method creates a 3-channel RGB image by selecting appropriate bands
corresponding to red, green, and blue wavelengths from the hyperspectral data.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>apply_mask</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to apply the binary mask to the image.
Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>apply_min_cutoff</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to apply a minimum intensity
cutoff to the image. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>output_channel_axis</code>
            </td>
            <td>
                  <code>int | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The axis where the RGB channels
should be placed in the output tensor. If None, uses the current spectral
axis of the hyperspectral data. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>normalize</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to normalize the band values to the [0, 1] range.
Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: The RGB representation of the hyperspectral image.
Shape will be either (H, W, 3), (3, H, W), or (H, 3, W) depending on
the specified output_channel_axis, where H is height and W is width.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The RGB bands are extracted using predefined wavelength ranges for R, G, and B.</li>
<li>Each band is normalized independently before combining into the RGB image.</li>
<li>If apply_mask is True, masked areas will be set to zero in the output.</li>
<li>If apply_min_cutoff is True, a minimum intensity threshold is applied to each band.</li>
</ul>
</details>

<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb_image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">get_rgb_image</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb_image</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([100, 100, 3])</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">rgb_image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">get_rgb_image</span><span class="p">(</span><span class="n">output_channel_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb_image</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([3, 100, 100])</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">rgb_image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">get_rgb_image</span><span class="p">(</span><span class="n">apply_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb_image</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([100, 100, 3])</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_rgb_image</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">apply_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">apply_min_cutoff</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">output_channel_axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extracts an RGB representation from the hyperspectral image data.</span>

<span class="sd">    This method creates a 3-channel RGB image by selecting appropriate bands</span>
<span class="sd">    corresponding to red, green, and blue wavelengths from the hyperspectral data.</span>

<span class="sd">    Args:</span>
<span class="sd">        apply_mask (bool, optional): Whether to apply the binary mask to the image.</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">        apply_min_cutoff (bool, optional): Whether to apply a minimum intensity</span>
<span class="sd">            cutoff to the image. Defaults to False.</span>
<span class="sd">        output_channel_axis (int | None, optional): The axis where the RGB channels</span>
<span class="sd">            should be placed in the output tensor. If None, uses the current spectral</span>
<span class="sd">            axis of the hyperspectral data. Defaults to None.</span>
<span class="sd">        normalize (bool, optional): Whether to normalize the band values to the [0, 1] range.</span>
<span class="sd">            Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: The RGB representation of the hyperspectral image.</span>
<span class="sd">            Shape will be either (H, W, 3), (3, H, W), or (H, 3, W) depending on</span>
<span class="sd">            the specified output_channel_axis, where H is height and W is width.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The RGB bands are extracted using predefined wavelength ranges for R, G, and B.</span>
<span class="sd">        - Each band is normalized independently before combining into the RGB image.</span>
<span class="sd">        - If apply_mask is True, masked areas will be set to zero in the output.</span>
<span class="sd">        - If apply_min_cutoff is True, a minimum intensity threshold is applied to each band.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(10, 100, 100), wavelengths=np.linspace(400, 1000, 10))</span>
<span class="sd">        &gt;&gt;&gt; rgb_image = hsi_image.get_rgb_image()</span>
<span class="sd">        &gt;&gt;&gt; rgb_image.shape</span>
<span class="sd">        torch.Size([100, 100, 3])</span>

<span class="sd">        &gt;&gt;&gt; rgb_image = hsi_image.get_rgb_image(output_channel_axis=0)</span>
<span class="sd">        &gt;&gt;&gt; rgb_image.shape</span>
<span class="sd">        torch.Size([3, 100, 100])</span>

<span class="sd">        &gt;&gt;&gt; rgb_image = hsi_image.get_rgb_image(apply_mask=False, apply_min_cutoff=True)</span>
<span class="sd">        &gt;&gt;&gt; rgb_image.shape</span>
<span class="sd">        torch.Size([100, 100, 3])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">output_channel_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_channel_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span>

    <span class="n">rgb_img</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extract_band_by_name</span><span class="p">(</span>
                <span class="n">band</span><span class="p">,</span> <span class="n">apply_mask</span><span class="o">=</span><span class="n">apply_mask</span><span class="p">,</span> <span class="n">apply_min_cutoff</span><span class="o">=</span><span class="n">apply_min_cutoff</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">]</span>
        <span class="p">],</span>
        <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">rgb_img</span>
        <span class="k">if</span> <span class="n">output_channel_axis</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span>
        <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">rgb_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">output_channel_axis</span><span class="p">)</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.hsi.HSI.to" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Moves the image and binary mask (if available) to the specified device.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>device</code>
            </td>
            <td>
                  <code>str or <span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The device to move the image and binary mask to.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Self</code></td>            <td>
                  <code><span title="typing_extensions.Self">Self</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The updated HSI object.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create an HSI object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Move the image to cpu</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span>
<span class="go">device(type=&#39;cpu&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Move the image to cuda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span> <span class="o">=</span> <span class="n">hsi_image</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span>
<span class="go">device(type=&#39;cuda&#39;, index=0)</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/hsi.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Moves the image and binary mask (if available) to the specified device.</span>

<span class="sd">    Args:</span>
<span class="sd">        device (str or torch.device): The device to move the image and binary mask to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Self: The updated HSI object.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Create an HSI object</span>
<span class="sd">        &gt;&gt;&gt; hsi_image = HSI(image=torch.rand(10, 10, 10), wavelengths=np.arange(10))</span>
<span class="sd">        &gt;&gt;&gt; # Move the image to cpu</span>
<span class="sd">        &gt;&gt;&gt; hsi_image = hsi_image.to(&quot;cpu&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hsi_image.device</span>
<span class="sd">        device(type=&#39;cpu&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # Move the image to cuda</span>
<span class="sd">        &gt;&gt;&gt; hsi_image = hsi_image.to(&quot;cuda&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hsi_image.device</span>
<span class="sd">        device(type=&#39;cuda&#39;, index=0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">device</span>
    <span class="k">return</span> <span class="bp">self</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h2 id="visualizations">Visualizations</h2>


<div class="doc doc-object doc-function">



<a id="src.meteors.visualize.hsi_visualize.visualize_hsi"></a>
    <div class="doc doc-contents first">

        <p>Visualizes a Hyperspectral image object on the given axes. It uses either the object from HSI class or a field
from the HSIAttributes class.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>hsi_or_attributes</code>
            </td>
            <td>
                  <code><span title="meteors.HSI">HSI</span> | <span title="meteors.attr.HSIAttributes">HSIAttributes</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The hyperspectral image, or the attributes to be visualized.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>ax</code>
            </td>
            <td>
                  <code><span title="matplotlib.axes.Axes">Axes</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The axes on which the image will be plotted.
If None, the current axes will be used.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>use_mask</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to use the image mask if provided for the visualization.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>title</code>
            </td>
            <td>
                  <code>str | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>the title of the plot Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="matplotlib.axes.Axes">Axes</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>matplotlib.figure.Figure | None:
If use_pyplot is False, returns the figure and axes objects.
If use_pyplot is True, returns None.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>TypeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If hsi_or_attributes is not an instance of HSI or HSIAttributes.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/visualize/hsi_visualize.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">visualize_hsi</span><span class="p">(</span>
    <span class="n">hsi_or_attributes</span><span class="p">:</span> <span class="n">HSI</span> <span class="o">|</span> <span class="n">HSIAttributes</span><span class="p">,</span> <span class="n">ax</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">use_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualizes a Hyperspectral image object on the given axes. It uses either the object from HSI class or a field</span>
<span class="sd">    from the HSIAttributes class.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        hsi_or_attributes (HSI | HSIAttributes): The hyperspectral image, or the attributes to be visualized.</span>
<span class="sd">        ax (matplotlib.axes.Axes | None): The axes on which the image will be plotted.</span>
<span class="sd">            If None, the current axes will be used.</span>
<span class="sd">        use_mask (bool): Whether to use the image mask if provided for the visualization.</span>
<span class="sd">        title (str | None): the title of the plot Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        matplotlib.figure.Figure | None:</span>
<span class="sd">            If use_pyplot is False, returns the figure and axes objects.</span>
<span class="sd">            If use_pyplot is True, returns None.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If hsi_or_attributes is not an instance of HSI or HSIAttributes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi_or_attributes</span><span class="p">,</span> <span class="n">HSIAttributes</span><span class="p">):</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi_or_attributes</span><span class="o">.</span><span class="n">hsi</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi_or_attributes</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;hsi_or_attributes must be an instance of HSI or HSIAttributes.&quot;</span><span class="p">)</span>

    <span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">change_orientation</span><span class="p">(</span><span class="s2">&quot;HWC&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">rgb</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">get_rgb_image</span><span class="p">(</span><span class="n">output_channel_axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">apply_mask</span><span class="o">=</span><span class="n">use_mask</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span> <span class="ow">or</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rgb</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">title</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-module">



<a id="src.meteors.visualize.attr_visualize"></a>
    <div class="doc doc-contents first">








  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="src.meteors.visualize.attr_visualize.visualize_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">visualize_attributes</span><span class="p">(</span><span class="n">image_attributes</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_pyplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Visualizes the attributes of an image on the given axes.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>image_attributes</code>
            </td>
            <td>
                  <code><span title="meteors.attr.HSIAttributes">HSIAttributes</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The image attributes to be visualized.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>ax</code>
            </td>
            <td>
                  <code><span title="matplotlib.axes.Axes">Axes</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The axes to visualize the image on. If None, creates a new figure and axes.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>use_pyplot</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, uses pyplot to display the image. If False, returns the figure and axes objects.
if ax is not None, use_pyplot is ignored.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>title</code>
            </td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The title of the chart. If it equals to None, will be replaced with title "HSI Attributes of {method used for explanations}". Defaults to None</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>tuple[<span title="matplotlib.figure.Figure">Figure</span>, <span title="matplotlib.axes.Axes">Axes</span>] | <span title="matplotlib.axes.Axes">Axes</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>matplotlib.figure.Figure | matplotlib.axes.Axes | None: The figure and axes objects.
If use_pyplot is False and ax is None, returns the figure and axes objects.
If use_pyplot is True and ax is None, returns None, and displays the image using pyplot.
if ax is not None, returns the axes object.
If all the attributions are zero, returns None.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the axes have less than 2 rows and 2 columns</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the axes object is not a list of axes objects</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/visualize/attr_visualize.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">visualize_attributes</span><span class="p">(</span>
    <span class="n">image_attributes</span><span class="p">:</span> <span class="n">HSIAttributes</span><span class="p">,</span> <span class="n">ax</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">use_pyplot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]</span> <span class="o">|</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualizes the attributes of an image on the given axes.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        image_attributes (HSIAttributes): The image attributes to be visualized.</span>
<span class="sd">        ax (Axes | None): The axes to visualize the image on. If None, creates a new figure and axes.</span>
<span class="sd">        use_pyplot (bool): If True, uses pyplot to display the image. If False, returns the figure and axes objects.</span>
<span class="sd">            if ax is not None, use_pyplot is ignored.</span>
<span class="sd">        title (str): The title of the chart. If it equals to None, will be replaced with title &quot;HSI Attributes of {method used for explanations}&quot;. Defaults to None</span>

<span class="sd">    Returns:</span>
<span class="sd">        matplotlib.figure.Figure | matplotlib.axes.Axes | None: The figure and axes objects.</span>
<span class="sd">            If use_pyplot is False and ax is None, returns the figure and axes objects.</span>
<span class="sd">            If use_pyplot is True and ax is None, returns None, and displays the image using pyplot.</span>
<span class="sd">            if ax is not None, returns the axes object.</span>
<span class="sd">            If all the attributions are zero, returns None.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the axes have less than 2 rows and 2 columns</span>
<span class="sd">        ValueError: If the axes object is not a list of axes objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">image_attributes</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span> <span class="o">!=</span> <span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The orientation of the image is not (H, W, C): </span><span class="si">{</span><span class="n">image_attributes</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Changing it to (H, W, C) for visualization.&quot;</span>
        <span class="p">)</span>
        <span class="n">rotated_attributes_dataclass</span> <span class="o">=</span> <span class="n">image_attributes</span><span class="o">.</span><span class="n">change_orientation</span><span class="p">(</span><span class="s2">&quot;HWC&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rotated_attributes_dataclass</span> <span class="o">=</span> <span class="n">image_attributes</span>

    <span class="n">rotated_attributes</span> <span class="o">=</span> <span class="n">rotated_attributes_dataclass</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">rotated_attributes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;All the attributions are zero. There is nothing to visualize.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">used_ax</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">used_ax</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Provided ax parameter is only one axes object, but it should be a list of axes objects&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">ax</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">ax</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The axes should have at least 2 rows and 2 columns.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>

    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Attribution Heatmap&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;HSI Attributes of: </span><span class="si">{</span><span class="n">rotated_attributes_dataclass</span><span class="o">.</span><span class="n">attribution_method</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

    <span class="n">_</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">visualize_image_attr</span><span class="p">(</span>
        <span class="n">rotated_attributes</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;heat_map&quot;</span><span class="p">,</span>
        <span class="n">sign</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">plt_fig_axis</span><span class="o">=</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
        <span class="n">show_colorbar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">use_pyplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Attribution Module Values&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>

    <span class="c1"># Attributions module values</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">visualize_image_attr</span><span class="p">(</span>
        <span class="n">rotated_attributes</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;heat_map&quot;</span><span class="p">,</span>
        <span class="n">sign</span><span class="o">=</span><span class="s2">&quot;absolute_value&quot;</span><span class="p">,</span>
        <span class="n">plt_fig_axis</span><span class="o">=</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
        <span class="n">show_colorbar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">use_pyplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">attr_all</span> <span class="o">=</span> <span class="n">rotated_attributes</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">rotated_attributes_dataclass</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">attr_all</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Spectral Attribution&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Wavelength&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Attribution&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">attr_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rotated_attributes</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">rotated_attributes_dataclass</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">attr_abs</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Spectral Attribution Absolute Values&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Wavelength&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Attribution Absolute Value&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">used_ax</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="k">if</span> <span class="n">use_pyplot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># pragma: no cover</span>

    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.visualize.attr_visualize.visualize_spatial_aggregated_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">visualize_spatial_aggregated_attributes</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="n">aggregated_mask</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_pyplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">aggregate_func</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Visualizes the spatial attributes of an hsi object aggregated by a custom mask.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>attributes</code>
            </td>
            <td>
                  <code><span title="meteors.attr.HSIAttributes">HSIAttributes</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The spatial attributes of the hsi object to visualize.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>aggregated_mask</code>
            </td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span> | <span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The mask used to aggregate the spatial attributes.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>ax</code>
            </td>
            <td>
                  <code><span title="matplotlib.axes.Axes">Axes</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The axes object to plot the visualization on. If None, a new axes will be created.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>use_pyplot</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, displays the visualization using pyplot.
If ax is not None, use_pyplot is ignored.
If False, returns the figure and axes objects. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>aggregate_func</code>
            </td>
            <td>
                  <code><span title="typing.Callable">Callable</span>[[<span title="torch.Tensor">Tensor</span>], <span title="torch.Tensor">Tensor</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The aggregation function to be applied.
The function should take a tensor as input and return a tensor as output.
We recommend using torch functions. Defaults to torch.mean.</p>
              </div>
            </td>
            <td>
                  <code><span title="torch.mean">mean</span></code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>title</code>
            </td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The title of the plot. If None will be replaced with "Spatial Attributes Visualization Aggregated". Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ShapeMismatchError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the shape of the aggregated mask does not match the shape of the spatial attributes.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>tuple[<span title="matplotlib.figure.Figure">Figure</span>, <span title="matplotlib.axes.Axes">Axes</span>] | <span title="matplotlib.axes.Axes">Axes</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple[Figure, Axes] | Axes | None: If ax is not None, returns the axes object.
If use_pyplot is True, returns None. If use_pyplot is False, returns the figure and axes objects.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/visualize/attr_visualize.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">visualize_spatial_aggregated_attributes</span><span class="p">(</span>
    <span class="n">attributes</span><span class="p">:</span> <span class="n">HSIAttributes</span><span class="p">,</span>
    <span class="n">aggregated_mask</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">ax</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">use_pyplot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">aggregate_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]</span> <span class="o">|</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualizes the spatial attributes of an hsi object aggregated by a custom mask.</span>

<span class="sd">    Args:</span>
<span class="sd">        attributes (HSIAttributes): The spatial attributes of the hsi object to visualize.</span>
<span class="sd">        aggregated_mask (torch.Tensor | np.ndarray): The mask used to aggregate the spatial attributes.</span>
<span class="sd">        ax (Axes | None, optional): The axes object to plot the visualization on. If None, a new axes will be created.</span>
<span class="sd">        use_pyplot (bool, optional): If True, displays the visualization using pyplot.</span>
<span class="sd">            If ax is not None, use_pyplot is ignored.</span>
<span class="sd">            If False, returns the figure and axes objects. Defaults to False.</span>
<span class="sd">        aggregate_func (Callable[[torch.Tensor], torch.Tensor], optional): The aggregation function to be applied.</span>
<span class="sd">            The function should take a tensor as input and return a tensor as output.</span>
<span class="sd">            We recommend using torch functions. Defaults to torch.mean.</span>
<span class="sd">        title (str, optional): The title of the plot. If None will be replaced with &quot;Spatial Attributes Visualization Aggregated&quot;. Defaults to None.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ShapeMismatchError: If the shape of the aggregated mask does not match the shape of the spatial attributes.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[Figure, Axes] | Axes | None: If ax is not None, returns the axes object.</span>
<span class="sd">            If use_pyplot is True, returns None. If use_pyplot is False, returns the figure and axes objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aggregated_mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">aggregated_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">aggregated_mask</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">aggregated_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="n">aggregated_mask</span> <span class="o">=</span> <span class="n">aggregated_mask</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">attributes</span><span class="o">.</span><span class="n">attributes</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;Spatial Attributes Visualization Aggregated&quot;</span>

    <span class="n">new_attrs</span> <span class="o">=</span> <span class="n">aggregate_by_mask</span><span class="p">(</span><span class="n">attributes</span><span class="o">.</span><span class="n">attributes</span><span class="p">,</span> <span class="n">aggregated_mask</span><span class="p">,</span> <span class="n">aggregate_func</span><span class="p">)</span>

    <span class="n">new_spatial_attributes</span> <span class="o">=</span> <span class="n">HSIAttributesSpatial</span><span class="p">(</span>
        <span class="n">hsi</span><span class="o">=</span><span class="n">attributes</span><span class="o">.</span><span class="n">hsi</span><span class="p">,</span>
        <span class="n">attributes</span><span class="o">=</span><span class="n">new_attrs</span><span class="p">,</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">aggregated_mask</span><span class="p">,</span>
        <span class="n">score</span><span class="o">=</span><span class="n">attributes</span><span class="o">.</span><span class="n">score</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">visualize_spatial_attributes</span><span class="p">(</span><span class="n">new_spatial_attributes</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">use_pyplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">out</span>  <span class="c1"># type: ignore</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">use_pyplot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># pragma: no cover</span>

    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.visualize.attr_visualize.visualize_spectral_aggregated_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">visualize_spectral_aggregated_attributes</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="n">band_names</span><span class="p">,</span> <span class="n">band_mask</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_pyplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">color_palette</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_not_included</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">aggregate_func</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Visualizes the spectral attributes of an hsi object aggregated by a custom band mask.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>attributes</code>
            </td>
            <td>
                  <code><span title="meteors.attr.HSIAttributes">HSIAttributes</span> | list[<span title="meteors.attr.HSIAttributes">HSIAttributes</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The spectral attributes of the hsi object to visualize.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>band_names</code>
            </td>
            <td>
                  <code>dict[str | tuple[str, ...], int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A dictionary mapping band names to their indices.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>band_mask</code>
            </td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span> | <span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The mask used to aggregate the spectral attributes.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>ax</code>
            </td>
            <td>
                  <code><span title="matplotlib.axes.Axes">Axes</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The axes object to plot the visualization on. If None, a new axes will be created.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>use_pyplot</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, displays the visualization using pyplot.
If ax is not None, use_pyplot is ignored. If False, returns the figure and axes objects. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>color_palette</code>
            </td>
            <td>
                  <code>list[str] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The color palette to use for visualizing different spectral bands.
If None, a default color palette is used. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>show_not_included</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, includes the spectral bands that are not included in the visualization.
If False, only includes the spectral bands that are included in the visualization. Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>aggregate_func</code>
            </td>
            <td>
                  <code><span title="typing.Callable">Callable</span>[[<span title="torch.Tensor">Tensor</span>], <span title="torch.Tensor">Tensor</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The aggregation function to be applied.
The function should take a tensor as input and return a tensor as output.
We recommend using torch functions. Defaults to torch.mean.</p>
              </div>
            </td>
            <td>
                  <code><span title="torch.mean">mean</span></code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>title</code>
            </td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The title of the plot. If None, "Spectral Attributes Visualization" will be used. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ShapeMismatchError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the shape of the band mask does not match the shape of the spectral attributes.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>tuple[<span title="matplotlib.figure.Figure">Figure</span>, <span title="matplotlib.axes.Axes">Axes</span>] | <span title="matplotlib.axes.Axes">Axes</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple[Figure, Axes] | Axes | None: If ax is not None, returns the axes object.
If use_pyplot is True, returns None. If use_pyplot is False, returns the figure and axes objects</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/visualize/attr_visualize.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">visualize_spectral_aggregated_attributes</span><span class="p">(</span>
    <span class="n">attributes</span><span class="p">:</span> <span class="n">HSIAttributes</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributes</span><span class="p">],</span>
    <span class="n">band_names</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">band_mask</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">ax</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">use_pyplot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">color_palette</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">show_not_included</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">aggregate_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]</span> <span class="o">|</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualizes the spectral attributes of an hsi object aggregated by a custom band mask.</span>

<span class="sd">    Args:</span>
<span class="sd">        attributes (HSIAttributes | list[HSIAttributes]): The spectral attributes of the hsi object to visualize.</span>
<span class="sd">        band_names (dict[str | tuple[str, ...], int]): A dictionary mapping band names to their indices.</span>
<span class="sd">        band_mask (torch.Tensor | np.ndarray): The mask used to aggregate the spectral attributes.</span>
<span class="sd">        ax (Axes | None, optional): The axes object to plot the visualization on. If None, a new axes will be created.</span>
<span class="sd">        use_pyplot (bool, optional): If True, displays the visualization using pyplot.</span>
<span class="sd">            If ax is not None, use_pyplot is ignored. If False, returns the figure and axes objects. Defaults to False.</span>
<span class="sd">        color_palette (list[str] | None, optional): The color palette to use for visualizing different spectral bands.</span>
<span class="sd">            If None, a default color palette is used. Defaults to None.</span>
<span class="sd">        show_not_included (bool, optional): If True, includes the spectral bands that are not included in the visualization.</span>
<span class="sd">            If False, only includes the spectral bands that are included in the visualization. Defaults to True.</span>
<span class="sd">        aggregate_func (Callable[[torch.Tensor], torch.Tensor], optional): The aggregation function to be applied.</span>
<span class="sd">            The function should take a tensor as input and return a tensor as output.</span>
<span class="sd">            We recommend using torch functions. Defaults to torch.mean.</span>
<span class="sd">        title (str, optional): The title of the plot. If None, &quot;Spectral Attributes Visualization&quot; will be used. Defaults to None.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ShapeMismatchError: If the shape of the band mask does not match the shape of the spectral attributes.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[Figure, Axes] | Axes | None: If ax is not None, returns the axes object.</span>
<span class="sd">            If use_pyplot is True, returns None. If use_pyplot is False, returns the figure and axes objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attributes_example</span> <span class="o">=</span> <span class="n">attributes</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="n">HSIAttributes</span><span class="p">)</span> <span class="k">else</span> <span class="n">attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">band_mask</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">band_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">attributes_example</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="n">expand_spectral_mask</span><span class="p">(</span><span class="n">attributes_example</span><span class="o">.</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask</span><span class="p">,</span> <span class="n">repeat_dimensions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">band_names</span> <span class="o">=</span> <span class="n">align_band_names_with_mask</span><span class="p">(</span><span class="n">band_names</span><span class="p">,</span> <span class="n">band_mask</span><span class="p">)</span>

    <span class="n">new_attrs</span> <span class="o">=</span> <span class="n">aggregate_by_mask</span><span class="p">(</span><span class="n">attributes_example</span><span class="o">.</span><span class="n">attributes</span><span class="p">,</span> <span class="n">band_mask</span><span class="p">,</span> <span class="n">aggregate_func</span><span class="p">)</span>

    <span class="n">new_spectral_attributes</span><span class="p">:</span> <span class="n">HSIAttributesSpectral</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributesSpectral</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="n">HSIAttributes</span><span class="p">):</span>
        <span class="n">new_spectral_attributes</span> <span class="o">=</span> <span class="n">HSIAttributesSpectral</span><span class="p">(</span>
            <span class="n">hsi</span><span class="o">=</span><span class="n">attributes</span><span class="o">.</span><span class="n">hsi</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">new_attrs</span><span class="p">,</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">band_mask</span><span class="p">,</span>
            <span class="n">band_names</span><span class="o">=</span><span class="n">band_names</span><span class="p">,</span>
            <span class="n">score</span><span class="o">=</span><span class="n">attributes</span><span class="o">.</span><span class="n">score</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_spectral_attributes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">HSIAttributesSpectral</span><span class="p">(</span>
                <span class="n">hsi</span><span class="o">=</span><span class="n">attr</span><span class="o">.</span><span class="n">hsi</span><span class="p">,</span>
                <span class="n">attributes</span><span class="o">=</span><span class="n">new_attrs</span><span class="p">,</span>
                <span class="n">mask</span><span class="o">=</span><span class="n">band_mask</span><span class="p">,</span>
                <span class="n">band_names</span><span class="o">=</span><span class="n">band_names</span><span class="p">,</span>
                <span class="n">score</span><span class="o">=</span><span class="n">attr</span><span class="o">.</span><span class="n">score</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attributes</span>
        <span class="p">]</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">visualize_spectral_attributes</span><span class="p">(</span>
        <span class="n">new_spectral_attributes</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
        <span class="n">use_pyplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">color_palette</span><span class="o">=</span><span class="n">color_palette</span><span class="p">,</span>
        <span class="n">show_not_included</span><span class="o">=</span><span class="n">show_not_included</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
    <span class="p">)</span>  <span class="c1"># type: ignore</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">if</span> <span class="n">use_pyplot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># pragma: no cover</span>

    <span class="k">return</span> <span class="n">out</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.visualize.attr_visualize.visualize_aggregated_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">visualize_aggregated_attributes</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">band_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_pyplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">color_palette</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_not_included</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">aggregate_func</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Visualizes the aggregated attributes of an hsi object.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>attributes</code>
            </td>
            <td>
                  <code><span title="meteors.attr.HSIAttributes">HSIAttributes</span> | list[<span title="meteors.attr.HSIAttributes">HSIAttributes</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The attributes of the hsi object to visualize.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>mask</code>
            </td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span> | <span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The mask used to aggregate the attributes.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>band_names</code>
            </td>
            <td>
                  <code>dict[str | tuple[str, ...], int] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A dictionary mapping band names to their indices.
If None, the visualization will be spatially aggregated. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>ax</code>
            </td>
            <td>
                  <code><span title="matplotlib.axes.Axes">Axes</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The axes object to plot the visualization on. If None, a new axes will be created.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>use_pyplot</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, displays the visualization using pyplot.
If ax is not None, use_pyplot is ignored. If False, returns the figure and axes objects. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>color_palette</code>
            </td>
            <td>
                  <code>list[str] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The color palette to use for visualizing different spectral bands.
If None, a default color palette is used. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>show_not_included</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, includes the spectral bands that are not included in the visualization.
If False, only includes the spectral bands that are included in the visualization. Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>aggregate_func</code>
            </td>
            <td>
                  <code><span title="typing.Callable">Callable</span>[[<span title="torch.Tensor">Tensor</span>], <span title="torch.Tensor">Tensor</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The aggregation function to be applied.
The function should take a tensor as input and return a tensor as output.
We recommend using torch functions. Defaults to torch.mean.</p>
              </div>
            </td>
            <td>
                  <code><span title="torch.mean">mean</span></code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>title</code>
            </td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The title of the plot. If None the default of the underlying figure will be used. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the shape of the mask does not match the shape of the attributes.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>AssertionError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If band_names is None and attributes is a list of HSIAttributes objects.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>tuple[<span title="matplotlib.figure.Figure">Figure</span>, <span title="matplotlib.axes.Axes">Axes</span>] | <span title="matplotlib.axes.Axes">Axes</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple[Figure, Axes] | Axes | None: If ax is not None, returns the axes object.
If use_pyplot is True, returns None. If use_pyplot is False, returns the figure and axes objects.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/visualize/attr_visualize.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">visualize_aggregated_attributes</span><span class="p">(</span>
    <span class="n">attributes</span><span class="p">:</span> <span class="n">HSIAttributes</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributes</span><span class="p">],</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">band_names</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ax</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">use_pyplot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">color_palette</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">show_not_included</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">aggregate_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]</span> <span class="o">|</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualizes the aggregated attributes of an hsi object.</span>

<span class="sd">    Args:</span>
<span class="sd">        attributes (HSIAttributes | list[HSIAttributes]): The attributes of the hsi object to visualize.</span>
<span class="sd">        mask (torch.Tensor | np.ndarray): The mask used to aggregate the attributes.</span>
<span class="sd">        band_names (dict[str | tuple[str, ...], int] | None, optional): A dictionary mapping band names to their indices.</span>
<span class="sd">            If None, the visualization will be spatially aggregated. Defaults to None.</span>
<span class="sd">        ax (Axes | None, optional): The axes object to plot the visualization on. If None, a new axes will be created.</span>
<span class="sd">        use_pyplot (bool, optional): If True, displays the visualization using pyplot.</span>
<span class="sd">            If ax is not None, use_pyplot is ignored. If False, returns the figure and axes objects. Defaults to False.</span>
<span class="sd">        color_palette (list[str] | None, optional): The color palette to use for visualizing different spectral bands.</span>
<span class="sd">            If None, a default color palette is used. Defaults to None.</span>
<span class="sd">        show_not_included (bool, optional): If True, includes the spectral bands that are not included in the visualization.</span>
<span class="sd">            If False, only includes the spectral bands that are included in the visualization. Defaults to True.</span>
<span class="sd">        aggregate_func (Callable[[torch.Tensor], torch.Tensor], optional): The aggregation function to be applied.</span>
<span class="sd">            The function should take a tensor as input and return a tensor as output.</span>
<span class="sd">            We recommend using torch functions. Defaults to torch.mean.</span>
<span class="sd">        title (str, optional): The title of the plot. If None the default of the underlying figure will be used. Defaults to None.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the shape of the mask does not match the shape of the attributes.</span>
<span class="sd">        AssertionError: If band_names is None and attributes is a list of HSIAttributes objects.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[Figure, Axes] | Axes | None: If ax is not None, returns the axes object.</span>
<span class="sd">            If use_pyplot is True, returns None. If use_pyplot is False, returns the figure and axes objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">agg</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="n">HSIAttributes</span><span class="p">)</span> <span class="k">else</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">band_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Band names not provided. Using Spatial Analysis.&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">agg</span><span class="p">,</span> <span class="s2">&quot;In Spatial Analysis, attributes must be a single HSIAttributes object.&quot;</span>
        <span class="k">return</span> <span class="n">visualize_spatial_aggregated_attributes</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">use_pyplot</span><span class="p">,</span> <span class="n">aggregate_func</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Band names provided. Using Spectral Analysis.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">visualize_spectral_aggregated_attributes</span><span class="p">(</span>
            <span class="n">attributes</span><span class="p">,</span> <span class="n">band_names</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">use_pyplot</span><span class="p">,</span> <span class="n">color_palette</span><span class="p">,</span> <span class="n">show_not_included</span><span class="p">,</span> <span class="n">aggregate_func</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.visualize.attr_visualize.visualize_spectral_attributes_by_waveband" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">visualize_spectral_attributes_by_waveband</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">color_palette</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_not_included</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_legend</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Visualizes spectral attributes by waveband.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>spectral_attributes</code>
            </td>
            <td>
                  <code><span title="meteors.attr.HSIAttributesSpectral">HSIAttributesSpectral</span> | list[<span title="meteors.attr.HSIAttributesSpectral">HSIAttributesSpectral</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The spectral attributes to visualize.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>ax</code>
            </td>
            <td>
                  <code><span title="matplotlib.axes.Axes">Axes</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The matplotlib axes to plot the visualization on.
If None, a new axes will be created.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>color_palette</code>
            </td>
            <td>
                  <code>list[str] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The color palette to use for plotting.
If None, a default color palette will be used.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>show_not_included</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to show the "not_included" band in the visualization.
Default is True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>show_legend</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to show the legend in the visualization.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Axes</code></td>            <td>
                  <code><span title="matplotlib.axes.Axes">Axes</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The matplotlib axes object containing the visualization.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Raises:
    TypeError: If the spectral attributes are not an HSIAttributesSpectral object or a list of HSIAttributesSpectral objects.</p>

            <details class="quote">
              <summary>Source code in <code>src/meteors/visualize/attr_visualize.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">visualize_spectral_attributes_by_waveband</span><span class="p">(</span>
    <span class="n">spectral_attributes</span><span class="p">:</span> <span class="n">HSIAttributesSpectral</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributesSpectral</span><span class="p">],</span>
    <span class="n">ax</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">color_palette</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">show_not_included</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">show_legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualizes spectral attributes by waveband.</span>

<span class="sd">    Args:</span>
<span class="sd">        spectral_attributes (HSIAttributesSpectral | list[HSIAttributesSpectral]):</span>
<span class="sd">            The spectral attributes to visualize.</span>
<span class="sd">        ax (Axes | None): The matplotlib axes to plot the visualization on.</span>
<span class="sd">            If None, a new axes will be created.</span>
<span class="sd">        color_palette (list[str] | None): The color palette to use for plotting.</span>
<span class="sd">            If None, a default color palette will be used.</span>
<span class="sd">        show_not_included (bool): Whether to show the &quot;not_included&quot; band in the visualization.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        show_legend (bool): Whether to show the legend in the visualization.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Axes: The matplotlib axes object containing the visualization.</span>
<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the spectral attributes are not an HSIAttributesSpectral object or a list of HSIAttributesSpectral objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">,</span> <span class="n">HSIAttributesSpectral</span><span class="p">):</span>
        <span class="n">spectral_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="n">spectral_attributes</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">HSIAttributesSpectral</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">spectral_attributes</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;spectral_attributes parameter must be an HSIAttributesSpectral object or a list of HSIAttributesSpectral objects.&quot;</span>
        <span class="p">)</span>

    <span class="n">aggregate_results</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">True</span>
    <span class="n">band_names</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">band_names</span><span class="p">)</span>
    <span class="n">wavelengths</span> <span class="o">=</span> <span class="n">spectral_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span>
    <span class="n">validate_consistent_band_and_wavelengths</span><span class="p">(</span><span class="n">band_names</span><span class="p">,</span> <span class="n">wavelengths</span><span class="p">,</span> <span class="n">spectral_attributes</span><span class="p">)</span>

    <span class="n">ax</span> <span class="o">=</span> <span class="n">setup_visualization</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s2">&quot;Attributions by Waveband&quot;</span><span class="p">,</span> <span class="s2">&quot;Wavelength (nm)&quot;</span><span class="p">,</span> <span class="s2">&quot;Correlation with Output&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">show_not_included</span> <span class="ow">and</span> <span class="n">band_names</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;not_included&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">band_names</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;not_included&quot;</span><span class="p">)</span>

    <span class="n">band_names</span> <span class="o">=</span> <span class="n">_merge_band_names_segments</span><span class="p">(</span><span class="n">band_names</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

    <span class="k">if</span> <span class="n">color_palette</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">color_palette</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s2">&quot;hsv&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_names</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

    <span class="n">band_mask</span> <span class="o">=</span> <span class="n">spectral_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">band_mask</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
    <span class="n">attribution_map</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">attr</span><span class="o">.</span><span class="n">flattened_attributes</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">spectral_attributes</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">band_name</span><span class="p">,</span> <span class="n">segment_id</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">band_names</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="n">current_wavelengths</span> <span class="o">=</span> <span class="n">wavelengths</span><span class="p">[</span><span class="n">band_mask</span> <span class="o">==</span> <span class="n">segment_id</span><span class="p">]</span>
        <span class="n">current_attribution_map</span> <span class="o">=</span> <span class="n">attribution_map</span><span class="p">[:,</span> <span class="n">band_mask</span> <span class="o">==</span> <span class="n">segment_id</span><span class="p">]</span>

        <span class="n">current_mean</span> <span class="o">=</span> <span class="n">current_attribution_map</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">aggregate_results</span><span class="p">:</span>
            <span class="n">lolims</span> <span class="o">=</span> <span class="n">current_attribution_map</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">uplims</span> <span class="o">=</span> <span class="n">current_attribution_map</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span>
                <span class="n">current_wavelengths</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span>
                <span class="n">current_mean</span><span class="p">,</span>
                <span class="n">yerr</span><span class="o">=</span><span class="p">[</span><span class="n">current_mean</span> <span class="o">-</span> <span class="n">lolims</span><span class="p">,</span> <span class="n">uplims</span> <span class="o">-</span> <span class="n">current_mean</span><span class="p">],</span>
                <span class="n">label</span><span class="o">=</span><span class="n">band_name</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="n">color_palette</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span>
                <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
                <span class="n">markersize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="n">current_wavelengths</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span>
                <span class="n">current_mean</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="n">band_name</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="n">color_palette</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">show_legend</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">&quot;SuperBand&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.visualize.attr_visualize.visualize_spectral_attributes_by_magnitude" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">visualize_spectral_attributes_by_magnitude</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">color_palette</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">annotate_bars</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_not_included</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Visualizes the spectral attributes by magnitude.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>spectral_attributes</code>
            </td>
            <td>
                  <code><span title="meteors.attr.HSIAttributesSpectral">HSIAttributesSpectral</span> | list[<span title="meteors.attr.HSIAttributesSpectral">HSIAttributesSpectral</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The spectral attributes to visualize.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>ax</code>
            </td>
            <td>
                  <code><span title="matplotlib.axes.Axes">Axes</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The matplotlib Axes object to plot the visualization on.
If None, a new Axes object will be created.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>color_palette</code>
            </td>
            <td>
                  <code>list[str] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The color palette to use for the visualization.
If None, a default color palette will be used.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>annotate_bars</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to annotate the bars with their magnitudes.
Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>show_not_included</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to show the 'not_included' band in the visualization.
Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Axes</code></td>            <td>
                  <code><span title="matplotlib.axes.Axes">Axes</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The matplotlib Axes object containing the visualization.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Raises:
    TypeError: If the spectral attributes are not an HSIAttributesSpectral object or a list of HSIAttributesSpectral objects.</p>

            <details class="quote">
              <summary>Source code in <code>src/meteors/visualize/attr_visualize.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">visualize_spectral_attributes_by_magnitude</span><span class="p">(</span>
    <span class="n">spectral_attributes</span><span class="p">:</span> <span class="n">HSIAttributesSpectral</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributesSpectral</span><span class="p">],</span>
    <span class="n">ax</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">color_palette</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">annotate_bars</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">show_not_included</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualizes the spectral attributes by magnitude.</span>

<span class="sd">    Args:</span>
<span class="sd">        spectral_attributes (HSIAttributesSpectral | list[HSIAttributesSpectral]):</span>
<span class="sd">            The spectral attributes to visualize.</span>
<span class="sd">        ax (Axes | None): The matplotlib Axes object to plot the visualization on.</span>
<span class="sd">            If None, a new Axes object will be created.</span>
<span class="sd">        color_palette (list[str] | None): The color palette to use for the visualization.</span>
<span class="sd">            If None, a default color palette will be used.</span>
<span class="sd">        annotate_bars (bool): Whether to annotate the bars with their magnitudes.</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">        show_not_included (bool): Whether to show the &#39;not_included&#39; band in the visualization.</span>
<span class="sd">            Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Axes: The matplotlib Axes object containing the visualization.</span>
<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the spectral attributes are not an HSIAttributesSpectral object or a list of HSIAttributesSpectral objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">,</span> <span class="n">HSIAttributesSpectral</span><span class="p">):</span>
        <span class="n">spectral_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="n">spectral_attributes</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">HSIAttributesSpectral</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">spectral_attributes</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;spectral_attributes parameter must be an HSIAttributesSpectral object or a list of HSIAttributesSpectral objects.&quot;</span>
        <span class="p">)</span>

    <span class="n">aggregate_results</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">True</span>
    <span class="n">band_names</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">band_names</span><span class="p">)</span>
    <span class="n">wavelengths</span> <span class="o">=</span> <span class="n">spectral_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span>
    <span class="n">validate_consistent_band_and_wavelengths</span><span class="p">(</span><span class="n">band_names</span><span class="p">,</span> <span class="n">wavelengths</span><span class="p">,</span> <span class="n">spectral_attributes</span><span class="p">)</span>

    <span class="n">ax</span> <span class="o">=</span> <span class="n">setup_visualization</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s2">&quot;Attributions by Magnitude&quot;</span><span class="p">,</span> <span class="s2">&quot;Group&quot;</span><span class="p">,</span> <span class="s2">&quot;Average Attribution Magnitude&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">)</span>

    <span class="n">band_names</span> <span class="o">=</span> <span class="n">_merge_band_names_segments</span><span class="p">(</span><span class="n">band_names</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">band_names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">show_not_included</span> <span class="ow">and</span> <span class="n">band_names</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;not_included&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">band_names</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;not_included&quot;</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">band_names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">color_palette</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">color_palette</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s2">&quot;hsv&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_names</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

    <span class="n">band_mask</span> <span class="o">=</span> <span class="n">spectral_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">band_mask</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
    <span class="n">attribution_map</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">attr</span><span class="o">.</span><span class="n">flattened_attributes</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">spectral_attributes</span><span class="p">])</span>
    <span class="n">avg_magnitudes</span> <span class="o">=</span> <span class="n">calculate_average_magnitudes</span><span class="p">(</span><span class="n">band_names</span><span class="p">,</span> <span class="n">band_mask</span><span class="p">,</span> <span class="n">attribution_map</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">aggregate_results</span><span class="p">:</span>
        <span class="n">boxplot</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">boxplot</span><span class="p">(</span><span class="n">avg_magnitudes</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">patch_artist</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">patch</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">boxplot</span><span class="p">[</span><span class="s2">&quot;boxes&quot;</span><span class="p">],</span> <span class="n">color_palette</span><span class="p">):</span>
            <span class="n">patch</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">bars</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">avg_magnitudes</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color_palette</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">annotate_bars</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">bar</span> <span class="ow">in</span> <span class="n">bars</span><span class="p">:</span>
                <span class="n">height</span> <span class="o">=</span> <span class="n">bar</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">height</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">get_x</span><span class="p">()</span> <span class="o">+</span> <span class="n">bar</span><span class="o">.</span><span class="n">get_width</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span>
                    <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>  <span class="c1"># 3 points vertical offset</span>
                    <span class="n">textcoords</span><span class="o">=</span><span class="s2">&quot;offset points&quot;</span><span class="p">,</span>
                    <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
                    <span class="n">va</span><span class="o">=</span><span class="s2">&quot;bottom&quot;</span><span class="p">,</span>
                <span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.visualize.attr_visualize.visualize_spectral_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">visualize_spectral_attributes</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_pyplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">color_palette</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_not_included</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Visualizes the spectral attributes of an hsi object or a list of hsi objects.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>spectral_attributes</code>
            </td>
            <td>
                  <code><span title="meteors.attr.HSIAttributesSpectral">HSIAttributesSpectral</span> | list[<span title="meteors.attr.HSIAttributesSpectral">HSIAttributesSpectral</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The spectral attributes of the image object to visualize.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>ax</code>
            </td>
            <td>
                  <code><span title="matplotlib.axes.Axes">Axes</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The axes object to plot the visualization on. If None, a new axes will be created.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>use_pyplot</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If ax is not None, use_pyplot is ignored.
If True, displays the visualization using pyplot.
If False, returns the figure and axes objects. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>color_palette</code>
            </td>
            <td>
                  <code>list[str] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The color palette to use for visualizing different spectral bands.
If None, a default color palette is used.
Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>show_not_included</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, includes the spectral bands that are not included in the visualization.
If False, only includes the spectral bands that are included in the visualization.
Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>title</code>
            </td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The title of the plot. If None, the title will be set to "Spectral Attributes Visualization". Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>tuple[<span title="matplotlib.figure.Figure">Figure</span>, <span title="matplotlib.axes.Axes">Axes</span>] | <span title="matplotlib.axes.Axes">Axes</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple[matplotlib.figure.Figure, matplotlib.axes.Axes] | matplotlib.axes.Axes | None:
If ax is not None, returns the axes object.
If use_pyplot is True, returns None.
If use_pyplot is False, returns the figure and axes objects.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If ax is provided as a single axes object and not a list of axes objects.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If agg is True and the axes have less than 3 rows or 3 columns.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If agg is False and the axes have less than 2 rows or 2 columns.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/visualize/attr_visualize.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">visualize_spectral_attributes</span><span class="p">(</span>
    <span class="n">spectral_attributes</span><span class="p">:</span> <span class="n">HSIAttributesSpectral</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributesSpectral</span><span class="p">],</span>
    <span class="n">ax</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">use_pyplot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">color_palette</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">show_not_included</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]</span> <span class="o">|</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualizes the spectral attributes of an hsi object or a list of hsi objects.</span>

<span class="sd">    Args:</span>
<span class="sd">        spectral_attributes (HSIAttributesSpectral | list[HSIAttributesSpectral]):</span>
<span class="sd">            The spectral attributes of the image object to visualize.</span>
<span class="sd">        ax (Axes | None, optional):</span>
<span class="sd">            The axes object to plot the visualization on. If None, a new axes will be created.</span>
<span class="sd">        use_pyplot (bool, optional):</span>
<span class="sd">            If ax is not None, use_pyplot is ignored.</span>
<span class="sd">            If True, displays the visualization using pyplot.</span>
<span class="sd">            If False, returns the figure and axes objects. Defaults to False.</span>
<span class="sd">        color_palette (list[str] | None, optional):</span>
<span class="sd">            The color palette to use for visualizing different spectral bands.</span>
<span class="sd">            If None, a default color palette is used.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        show_not_included (bool, optional):</span>
<span class="sd">            If True, includes the spectral bands that are not included in the visualization.</span>
<span class="sd">            If False, only includes the spectral bands that are included in the visualization.</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">        title (str, optional): The title of the plot. If None, the title will be set to &quot;Spectral Attributes Visualization&quot;. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[matplotlib.figure.Figure, matplotlib.axes.Axes] | matplotlib.axes.Axes | None:</span>
<span class="sd">            If ax is not None, returns the axes object.</span>
<span class="sd">            If use_pyplot is True, returns None.</span>
<span class="sd">            If use_pyplot is False, returns the figure and axes objects.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If ax is provided as a single axes object and not a list of axes objects.</span>
<span class="sd">        ValueError: If agg is True and the axes have less than 3 rows or 3 columns.</span>
<span class="sd">        ValueError: If agg is False and the axes have less than 2 rows or 2 columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">agg</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="n">band_names</span> <span class="o">=</span> <span class="n">spectral_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">band_names</span> <span class="k">if</span> <span class="n">agg</span> <span class="k">else</span> <span class="n">spectral_attributes</span><span class="o">.</span><span class="n">band_names</span>  <span class="c1"># type: ignore</span>

    <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;Spectral Attributes Visualization&quot;</span>

    <span class="n">color_palette</span> <span class="o">=</span> <span class="n">color_palette</span> <span class="ow">or</span> <span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s2">&quot;hsv&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_names</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

    <span class="n">use_ax</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">use_ax</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="k">if</span> <span class="n">agg</span> <span class="k">else</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Provided as is one axes object, but it should be a list of axes objects&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">agg</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">ax</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The axes should have at least 3 rows or 3 columns if agg is True&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">agg</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">ax</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The axes should have at least 2 rows or 2 columns if agg is False&quot;</span><span class="p">)</span>

    <span class="n">visualize_spectral_attributes_by_waveband</span><span class="p">(</span>
        <span class="n">spectral_attributes</span><span class="p">,</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">color_palette</span><span class="o">=</span><span class="n">color_palette</span><span class="p">,</span>
        <span class="n">show_not_included</span><span class="o">=</span><span class="n">show_not_included</span><span class="p">,</span>
        <span class="n">show_legend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">visualize_spectral_attributes_by_magnitude</span><span class="p">(</span>
        <span class="n">spectral_attributes</span><span class="p">,</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">color_palette</span><span class="o">=</span><span class="n">color_palette</span><span class="p">,</span>
        <span class="n">show_not_included</span><span class="o">=</span><span class="n">show_not_included</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">agg</span><span class="p">:</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">attr</span><span class="o">.</span><span class="n">score</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">spectral_attributes</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
        <span class="n">mean_score</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;steelblue&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">mean_score</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;darkred&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span><span class="p">)</span>

        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Distribution of Score Values&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Score&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Frequency&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">use_ax</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="k">if</span> <span class="n">use_pyplot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># pragma: no cover</span>

    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="src.meteors.visualize.attr_visualize.visualize_spatial_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">visualize_spatial_attributes</span><span class="p">(</span><span class="n">spatial_attributes</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_pyplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Visualizes the spatial attributes of an hsi using Lime attribution.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>spatial_attributes</code>
            </td>
            <td>
                  <code><span title="meteors.attr.HSIAttributesSpatial">HSIAttributesSpatial</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The spatial attributes of the image object to visualize.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>ax</code>
            </td>
            <td>
                  <code><span title="matplotlib.axes.Axes">Axes</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The axes object to plot the visualization on. If None, a new axes will be created.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>use_pyplot</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to use pyplot for visualization. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>title</code>
            </td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The title of the plot. If None will be set to "Spatial Attributes Visualization", Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>tuple[<span title="matplotlib.figure.Figure">Figure</span>, <span title="matplotlib.axes.Axes">Axes</span>] | <span title="matplotlib.axes.Axes">Axes</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple[matplotlib.figure.Figure, matplotlib.axes.Axes] | matplotlib.axes.Axes | None:
If ax is not None, returns the axes object.
If use_pyplot is True, returns None.
If use_pyplot is False, returns the figure and axes objects.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the axes have less 3 rows or 3 columns with mask</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the axes have less 2 rows or 2 columns without mask</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the axes is a 2d object not 1d</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the axes object is not a list of axes objects</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/visualize/attr_visualize.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">visualize_spatial_attributes</span><span class="p">(</span>
    <span class="n">spatial_attributes</span><span class="p">:</span> <span class="n">HSIAttributesSpatial</span><span class="p">,</span>
    <span class="n">ax</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">use_pyplot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Figure</span><span class="p">,</span> <span class="n">Axes</span><span class="p">]</span> <span class="o">|</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualizes the spatial attributes of an hsi using Lime attribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        spatial_attributes (HSIAttributesSpatial):</span>
<span class="sd">            The spatial attributes of the image object to visualize.</span>
<span class="sd">        ax (Axes | None, optional):</span>
<span class="sd">            The axes object to plot the visualization on. If None, a new axes will be created.</span>
<span class="sd">        use_pyplot (bool, optional):</span>
<span class="sd">            Whether to use pyplot for visualization. Defaults to False.</span>
<span class="sd">        title (str, optional): The title of the plot. If None will be set to &quot;Spatial Attributes Visualization&quot;, Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[matplotlib.figure.Figure, matplotlib.axes.Axes] | matplotlib.axes.Axes | None:</span>
<span class="sd">            If ax is not None, returns the axes object.</span>
<span class="sd">            If use_pyplot is True, returns None.</span>
<span class="sd">            If use_pyplot is False, returns the figure and axes objects.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the axes have less 3 rows or 3 columns with mask</span>
<span class="sd">        ValueError: If the axes have less 2 rows or 2 columns without mask</span>
<span class="sd">        ValueError: If the axes is a 2d object not 1d</span>
<span class="sd">        ValueError: If the axes object is not a list of axes objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask_enabled</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">spatial_attributes</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="n">use_ax</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">use_ax</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="k">if</span> <span class="n">mask_enabled</span> <span class="k">else</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="k">if</span> <span class="n">mask_enabled</span> <span class="k">else</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Provided as is one axes object, but it should be a list of axes objects&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mask_enabled</span> <span class="ow">and</span> <span class="n">ax</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The axes should have at least 3 rows or 3 columns&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">mask_enabled</span> <span class="ow">and</span> <span class="n">ax</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The axes should have at least 2 rows or 2 columns&quot;</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The axes are 2d please provide 1d axes&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;Spatial Attributes Visualization&quot;</span>

    <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

    <span class="n">spatial_attributes</span> <span class="o">=</span> <span class="n">spatial_attributes</span><span class="o">.</span><span class="n">change_orientation</span><span class="p">(</span><span class="s2">&quot;HWC&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mask_enabled</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">spatial_attributes</span><span class="o">.</span><span class="n">segmentation_mask</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>

        <span class="n">group_names</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s2">&quot;hsv&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">group_names</span><span class="p">))</span>
        <span class="n">color_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">group_names</span><span class="p">,</span> <span class="n">colors</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">unique</span> <span class="ow">in</span> <span class="n">group_names</span><span class="p">:</span>
            <span class="n">segment_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">unique</span><span class="p">)</span>

            <span class="n">y_center</span><span class="p">,</span> <span class="n">x_center</span> <span class="o">=</span> <span class="n">segment_indices</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x_center</span><span class="p">,</span> <span class="n">y_center</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">unique</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="n">color_map</span><span class="p">[</span><span class="n">unique</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x_center</span><span class="p">,</span> <span class="n">y_center</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">unique</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="n">color_map</span><span class="p">[</span><span class="n">unique</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">)</span>

        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="o">/</span> <span class="n">mask</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Mask&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>

    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">spatial_attributes</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">get_rgb_image</span><span class="p">(</span><span class="n">output_channel_axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Original image&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>

    <span class="n">attrs</span> <span class="o">=</span> <span class="n">spatial_attributes</span><span class="o">.</span><span class="n">flattened_attributes</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">attrs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;All spatial attributes are zero.&quot;</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">LinearSegmentedColormap</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span><span class="s2">&quot;RdWhGn&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="s2">&quot;white&quot;</span><span class="p">,</span> <span class="s2">&quot;green&quot;</span><span class="p">])</span>
        <span class="n">heat_map</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">attrs</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">axis_separator</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">colorbar_axis</span> <span class="o">=</span> <span class="n">axis_separator</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;bottom&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">heat_map</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;horizontal&quot;</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">colorbar_axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">viz</span><span class="o">.</span><span class="n">visualize_image_attr</span><span class="p">(</span>
            <span class="n">attrs</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;heat_map&quot;</span><span class="p">,</span>
            <span class="n">sign</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
            <span class="n">plt_fig_axis</span><span class="o">=</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">show_colorbar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">use_pyplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Attribution Map&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">use_ax</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="k">if</span> <span class="n">use_pyplot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># pragma: no cover</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h2 id="attribution-methods">Attribution Methods</h2>


<div class="doc doc-object doc-class">



<h3 id="src.meteors.attr.attributes.HSIAttributes" class="doc doc-heading">
            <code>HSIAttributes</code>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="pydantic.BaseModel">BaseModel</span></code></p>


        <p>Represents an object that contains Hyperspectral image attributes and explanations.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributes.hsi">hsi</span></code></td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Hyperspectral image object for which the explanations were created.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributes.attributes">attributes</span></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Attributions (explanations) for the hsi.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributes.score">score</span></code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The score provided by the interpretable model. Can be None if method don't provide one.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributes.device">device</span></code></td>
            <td>
                  <code><span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Device to be used for inference. If None, the device of the input hsi will be used.
Defaults to None.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributes.attribution_method">attribution_method</span></code></td>
            <td>
                  <code>str | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The method used to generate the explanation. Defaults to None.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>






              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/attributes.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">HSIAttributes</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents an object that contains Hyperspectral image attributes and explanations.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        hsi (HSI): Hyperspectral image object for which the explanations were created.</span>
<span class="sd">        attributes (torch.Tensor): Attributions (explanations) for the hsi.</span>
<span class="sd">        score (float): The score provided by the interpretable model. Can be None if method don&#39;t provide one.</span>
<span class="sd">        device (torch.device): Device to be used for inference. If None, the device of the input hsi will be used.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        attribution_method (str | None): The method used to generate the explanation. Defaults to None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">hsi</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">HSI</span><span class="p">,</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Hyperspectral image object for which the explanations were created.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span>
    <span class="n">attributes</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">BeforeValidator</span><span class="p">(</span><span class="n">validate_and_convert_attributes</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Attributions (explanations) for the hsi.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span>
    <span class="n">attribution_method</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">AfterValidator</span><span class="p">(</span><span class="n">validate_attribution_method</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The method used to generate the explanation.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">score</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">validate_default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The score provided by the interpretable model. Can be None if method don&#39;t provide one.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">BeforeValidator</span><span class="p">(</span><span class="n">validate_and_convert_mask</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;`superpixel` or `superband` mask used for the explanation.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
        <span class="n">BeforeValidator</span><span class="p">(</span><span class="n">resolve_inference_device_attributes</span><span class="p">),</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">validate_default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Device to be used for inference. If None, the device of the input hsi will be used. &quot;</span>
                <span class="s2">&quot;Defaults to None.&quot;</span>
            <span class="p">),</span>
        <span class="p">),</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flattened_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a flattened tensor of attributes.</span>

<span class="sd">        This method should be implemented in the subclass.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A flattened tensor of attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The `flattened_attributes` property must be implemented in the subclass&quot;</span><span class="p">)</span>

    <span class="n">model_config</span> <span class="o">=</span> <span class="n">ConfigDict</span><span class="p">(</span><span class="n">arbitrary_types_allowed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the orientation of the hsi.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[str, str, str]: The orientation of the hsi corresponding to the attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">orientation</span>

    <span class="k">def</span> <span class="nf">_validate_hsi_attributions_and_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validates the hsi attributions and performs necessary operations to ensure compatibility with the device.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the shapes of the attributes and hsi tensors do not match.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validate_shapes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">validate_shapes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="nd">@model_validator</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;after&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">validate_hsi_attributions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validates the hsi attributions.</span>

<span class="sd">        This method performs validation on the hsi attributions to ensure they are correct.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: The current instance of the class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_hsi_attributions_and_mask</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move the hsi and attributes tensors to the specified device.</span>

<span class="sd">        Args:</span>
<span class="sd">            device (str or torch.device): The device to move the tensors to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: The modified object with tensors moved to the specified device.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; attrs = HSIAttributes(hsi, attributes, score=0.5)</span>
<span class="sd">            &gt;&gt;&gt; attrs.to(&quot;cpu&quot;)</span>
<span class="sd">            &gt;&gt;&gt; attrs.hsi.device</span>
<span class="sd">            device(type=&#39;cpu&#39;)</span>
<span class="sd">            &gt;&gt;&gt; attrs.attributes.device</span>
<span class="sd">            device(type=&#39;cpu&#39;)</span>
<span class="sd">            &gt;&gt;&gt; attrs.to(&quot;cuda&quot;)</span>
<span class="sd">            &gt;&gt;&gt; attrs.hsi.device</span>
<span class="sd">            device(type=&#39;cuda&#39;)</span>
<span class="sd">            &gt;&gt;&gt; attrs.attributes.device</span>
<span class="sd">            device(type=&#39;cuda&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">device</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">change_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_orientation</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Changes the orientation of the image data along with the attributions to the target orientation.</span>

<span class="sd">        Args:</span>
<span class="sd">            target_orientation (tuple[str, str, str] | list[str] | str): The target orientation for the attribution data.</span>
<span class="sd">                This should be a tuple of three one-letter strings in any order: &quot;C&quot;, &quot;H&quot;, &quot;W&quot;.</span>
<span class="sd">            inplace (bool, optional): Whether to modify the data in place or return a new object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: The updated Image object with the new orientation.</span>

<span class="sd">        Raises:</span>
<span class="sd">            OrientationError: If the target orientation is not a valid tuple of three one-letter strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current_orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">change_orientation</span><span class="p">(</span><span class="n">target_orientation</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_copy</span><span class="p">()</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi</span>

        <span class="c1"># now change the orientation of the attributes</span>
        <span class="k">if</span> <span class="n">current_orientation</span> <span class="o">==</span> <span class="n">target_orientation</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">attrs</span>

        <span class="n">permute_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">target_orientation</span><span class="p">]</span>

        <span class="n">attrs</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">permute_dims</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">attrs</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">permute_dims</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">attrs</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h4 id="src.meteors.attr.attributes.HSIAttributes.flattened_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">flattened_attributes</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Returns a flattened tensor of attributes.</p>
<p>This method should be implemented in the subclass.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: A flattened tensor of attributes.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
    </div>

</div>

<div class="doc doc-object doc-attribute">



<h4 id="src.meteors.attr.attributes.HSIAttributes.orientation" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">orientation</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Returns the orientation of the hsi.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>tuple[str, str, str]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple[str, str, str]: The orientation of the hsi corresponding to the attributes.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
    </div>

</div>



<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.attributes.HSIAttributes.change_orientation" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">change_orientation</span><span class="p">(</span><span class="n">target_orientation</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Changes the orientation of the image data along with the attributions to the target orientation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>target_orientation</code>
            </td>
            <td>
                  <code>tuple[str, str, str] | list[str] | str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The target orientation for the attribution data.
This should be a tuple of three one-letter strings in any order: "C", "H", "W".</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>inplace</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to modify the data in place or return a new object.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Self</code></td>            <td>
                  <code><span title="typing_extensions.Self">Self</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The updated Image object with the new orientation.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>OrientationError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the target orientation is not a valid tuple of three one-letter strings.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/attributes.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">change_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_orientation</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Changes the orientation of the image data along with the attributions to the target orientation.</span>

<span class="sd">    Args:</span>
<span class="sd">        target_orientation (tuple[str, str, str] | list[str] | str): The target orientation for the attribution data.</span>
<span class="sd">            This should be a tuple of three one-letter strings in any order: &quot;C&quot;, &quot;H&quot;, &quot;W&quot;.</span>
<span class="sd">        inplace (bool, optional): Whether to modify the data in place or return a new object.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Self: The updated Image object with the new orientation.</span>

<span class="sd">    Raises:</span>
<span class="sd">        OrientationError: If the target orientation is not a valid tuple of three one-letter strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">current_orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span>
    <span class="n">hsi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">change_orientation</span><span class="p">(</span><span class="n">target_orientation</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_copy</span><span class="p">()</span>
        <span class="n">attrs</span><span class="o">.</span><span class="n">hsi</span> <span class="o">=</span> <span class="n">hsi</span>

    <span class="c1"># now change the orientation of the attributes</span>
    <span class="k">if</span> <span class="n">current_orientation</span> <span class="o">==</span> <span class="n">target_orientation</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">attrs</span>

    <span class="n">permute_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_orientation</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">target_orientation</span><span class="p">]</span>

    <span class="n">attrs</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">permute_dims</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">attrs</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">attrs</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">permute_dims</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">attrs</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.attributes.HSIAttributes.to" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Move the hsi and attributes tensors to the specified device.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>device</code>
            </td>
            <td>
                  <code>str or <span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The device to move the tensors to.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Self</code></td>            <td>
                  <code><span title="typing_extensions.Self">Self</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The modified object with tensors moved to the specified device.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span> <span class="o">=</span> <span class="n">HSIAttributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">score</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">device</span>
<span class="go">device(type=&#39;cpu&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">device</span>
<span class="go">device(type=&#39;cpu&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">device</span>
<span class="go">device(type=&#39;cuda&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">device</span>
<span class="go">device(type=&#39;cuda&#39;)</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/attributes.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Move the hsi and attributes tensors to the specified device.</span>

<span class="sd">    Args:</span>
<span class="sd">        device (str or torch.device): The device to move the tensors to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Self: The modified object with tensors moved to the specified device.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; attrs = HSIAttributes(hsi, attributes, score=0.5)</span>
<span class="sd">        &gt;&gt;&gt; attrs.to(&quot;cpu&quot;)</span>
<span class="sd">        &gt;&gt;&gt; attrs.hsi.device</span>
<span class="sd">        device(type=&#39;cpu&#39;)</span>
<span class="sd">        &gt;&gt;&gt; attrs.attributes.device</span>
<span class="sd">        device(type=&#39;cpu&#39;)</span>
<span class="sd">        &gt;&gt;&gt; attrs.to(&quot;cuda&quot;)</span>
<span class="sd">        &gt;&gt;&gt; attrs.hsi.device</span>
<span class="sd">        device(type=&#39;cuda&#39;)</span>
<span class="sd">        &gt;&gt;&gt; attrs.attributes.device</span>
<span class="sd">        device(type=&#39;cuda&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">device</span>
    <span class="k">return</span> <span class="bp">self</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.meteors.attr.attributes.HSIAttributesSpatial" class="doc doc-heading">
            <code>HSIAttributesSpatial</code>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributes" href="#src.meteors.attr.attributes.HSIAttributes">HSIAttributes</a></code></p>


        <p>Represents spatial attributes of an hsi used for explanation.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributesSpatial.hsi">hsi</span></code></td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Hyperspectral image object for which the explanations were created.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributesSpatial.attributes">attributes</span></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Attributions (explanations) for the hsi.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributesSpatial.score">score</span></code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The score provided by the interpretable model. Can be None if method don't provide one.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributesSpatial.device">device</span></code></td>
            <td>
                  <code><span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Device to be used for inference. If None, the device of the input hsi will be used.
Defaults to None.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributesSpatial.attribution_method">attribution_method</span></code></td>
            <td>
                  <code>str | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The method used to generate the explanation. Defaults to None.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributesSpatial.segmentation_mask" href="#src.meteors.attr.attributes.HSIAttributesSpatial.segmentation_mask">segmentation_mask</a></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Spatial (Segmentation) mask used for the explanation.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributesSpatial.flattened_attributes" href="#src.meteors.attr.attributes.HSIAttributesSpatial.flattened_attributes">flattened_attributes</a></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Spatial 2D attribution map.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>






              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/attributes.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">HSIAttributesSpatial</span><span class="p">(</span><span class="n">HSIAttributes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents spatial attributes of an hsi used for explanation.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        hsi (HSI): Hyperspectral image object for which the explanations were created.</span>
<span class="sd">        attributes (torch.Tensor): Attributions (explanations) for the hsi.</span>
<span class="sd">        score (float): The score provided by the interpretable model. Can be None if method don&#39;t provide one.</span>
<span class="sd">        device (torch.device): Device to be used for inference. If None, the device of the input hsi will be used.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        attribution_method (str | None): The method used to generate the explanation. Defaults to None.</span>
<span class="sd">        segmentation_mask (torch.Tensor): Spatial (Segmentation) mask used for the explanation.</span>
<span class="sd">        flattened_attributes (torch.Tensor): Spatial 2D attribution map.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">segmentation_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the 2D spatial segmentation mask that has the same size as the hsi image.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The segmentation mask tensor.</span>

<span class="sd">        Raises:</span>
<span class="sd">            HSIAttributesError: If the segmentation mask is not provided in the attributes object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="s2">&quot;Segmentation mask is not provided in the attributes object&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flattened_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a flattened tensor of attributes, with removed repeated dimensions.</span>

<span class="sd">        In the case of spatial attributes, the flattened attributes are 2D spatial attributes of shape (rows, columns) and the spectral dimension is removed.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask = torch.zeros((3, 2, 2))</span>
<span class="sd">            &gt;&gt;&gt; attrs = HSIAttributesSpatial(hsi, attributes, score=0.5, segmentation_mask=segmentation_mask)</span>
<span class="sd">            &gt;&gt;&gt; attrs.flattened_attributes</span>
<span class="sd">                tensor([[0., 0.],</span>
<span class="sd">                        [0., 0.]])</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A flattened tensor of attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_hsi_attributions_and_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validates the hsi attributions and performs necessary operations to ensure compatibility with the device.</span>

<span class="sd">        Raises:</span>
<span class="sd">            HSIAttributesError: If the segmentation mask is not provided in the attributes object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_validate_hsi_attributions_and_mask</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h4 id="src.meteors.attr.attributes.HSIAttributesSpatial.flattened_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">flattened_attributes</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Returns a flattened tensor of attributes, with removed repeated dimensions.</p>
<p>In the case of spatial attributes, the flattened attributes are 2D spatial attributes of shape (rows, columns) and the spectral dimension is removed.</p>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span> <span class="o">=</span> <span class="n">HSIAttributesSpatial</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">score</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">segmentation_mask</span><span class="o">=</span><span class="n">segmentation_mask</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">flattened_attributes</span>
<span class="go">    tensor([[0., 0.],</span>
<span class="go">            [0., 0.]])</span>
</code></pre></div>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: A flattened tensor of attributes.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
    </div>

</div>

<div class="doc doc-object doc-attribute">



<h4 id="src.meteors.attr.attributes.HSIAttributesSpatial.segmentation_mask" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">segmentation_mask</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Returns the 2D spatial segmentation mask that has the same size as the hsi image.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: The segmentation mask tensor.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="meteors.exceptions.HSIAttributesError">HSIAttributesError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the segmentation mask is not provided in the attributes object.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
    </div>

</div>





  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.meteors.attr.attributes.HSIAttributesSpectral" class="doc doc-heading">
            <code>HSIAttributesSpectral</code>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributes" href="#src.meteors.attr.attributes.HSIAttributes">HSIAttributes</a></code></p>


        <p>Represents an hsi with spectral attributes used for explanation.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributesSpectral.hsi">hsi</span></code></td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Hyperspectral hsi object for which the explanations were created.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributesSpectral.attributes">attributes</span></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Attributions (explanations) for the hsi.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributesSpectral.score">score</span></code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>R^2 score of interpretable model used for the explanation.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributesSpectral.device">device</span></code></td>
            <td>
                  <code><span title="torch.device">device</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Device to be used for inference. If None, the device of the input hsi will be used.
Defaults to None.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributesSpectral.attribution_method">attribution_method</span></code></td>
            <td>
                  <code>str | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The method used to generate the explanation. Defaults to None.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributesSpectral.band_mask" href="#src.meteors.attr.attributes.HSIAttributesSpectral.band_mask">band_mask</a></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Band mask used for the explanation.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.attributes.HSIAttributesSpectral.band_names">band_names</span></code></td>
            <td>
                  <code>dict[str | tuple[str, ...], int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dictionary that translates the band names into the band segment ids.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributesSpectral.flattened_attributes" href="#src.meteors.attr.attributes.HSIAttributesSpectral.flattened_attributes">flattened_attributes</a></code></td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Spectral 1D attribution map.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>






              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/attributes.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">HSIAttributesSpectral</span><span class="p">(</span><span class="n">HSIAttributes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents an hsi with spectral attributes used for explanation.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        hsi (HSI): Hyperspectral hsi object for which the explanations were created.</span>
<span class="sd">        attributes (torch.Tensor): Attributions (explanations) for the hsi.</span>
<span class="sd">        score (float): R^2 score of interpretable model used for the explanation.</span>
<span class="sd">        device (torch.device): Device to be used for inference. If None, the device of the input hsi will be used.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        attribution_method (str | None): The method used to generate the explanation. Defaults to None.</span>
<span class="sd">        band_mask (torch.Tensor): Band mask used for the explanation.</span>
<span class="sd">        band_names (dict[str | tuple[str, ...], int]): Dictionary that translates the band names into the band segment ids.</span>
<span class="sd">        flattened_attributes (torch.Tensor): Spectral 1D attribution map.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">band_names</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span>
        <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">Field</span><span class="p">(</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Dictionary that translates the band names into the band segment ids.&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">band_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a 1D band mask - a band mask with removed repeated dimensions (num_bands, ),</span>
<span class="sd">        where num_bands is the number of bands in the hsi image.</span>

<span class="sd">        The method selects the appropriate dimensions from the `band_mask` tensor</span>
<span class="sd">        based on the `axis_to_select` and returns a flattened version of the selected</span>
<span class="sd">        tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The flattened band mask tensor.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; band_names = {&quot;R&quot;: 0, &quot;G&quot;: 1, &quot;B&quot;: 2}</span>
<span class="sd">            &gt;&gt;&gt; attrs = HSIAttributesSpectral(hsi, attributes, score=0.5, mask=band_mask)</span>
<span class="sd">            &gt;&gt;&gt; attrs.flattened_band_mask</span>
<span class="sd">            torch.tensor([0, 1, 2])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Band mask is not provided&quot;</span><span class="p">)</span>
        <span class="n">axis_to_select</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">axis_to_select</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">axis_to_select</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flattened_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a flattened tensor of attributes with removed repeated dimensions.</span>

<span class="sd">        In the case of spectral attributes, the flattened attributes are 1D tensor of shape (num_bands, ), where num_bands is the number of bands in the hsi image.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A flattened tensor of attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_hsi_attributions_and_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validates the hsi attributions and performs necessary operations to ensure compatibility with the device.</span>

<span class="sd">        Raises:</span>
<span class="sd">            HSIAttributesError: If the band mask is not provided in the attributes object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_validate_hsi_attributions_and_mask</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="s2">&quot;Band mask is not provided in the attributes object&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span> <span class="o">=</span> <span class="n">align_band_names_with_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">band_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h4 id="src.meteors.attr.attributes.HSIAttributesSpectral.band_mask" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">band_mask</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Returns a 1D band mask - a band mask with removed repeated dimensions (num_bands, ),
where num_bands is the number of bands in the hsi image.</p>
<p>The method selects the appropriate dimensions from the <code>band_mask</code> tensor
based on the <code>axis_to_select</code> and returns a flattened version of the selected
tensor.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: The flattened band mask tensor.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">band_names</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;R&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span> <span class="o">=</span> <span class="n">HSIAttributesSpectral</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">score</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">band_mask</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attrs</span><span class="o">.</span><span class="n">flattened_band_mask</span>
<span class="go">torch.tensor([0, 1, 2])</span>
</code></pre></div>
    </div>

</div>

<div class="doc doc-object doc-attribute">



<h4 id="src.meteors.attr.attributes.HSIAttributesSpectral.flattened_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">flattened_attributes</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Returns a flattened tensor of attributes with removed repeated dimensions.</p>
<p>In the case of spectral attributes, the flattened attributes are 1D tensor of shape (num_bands, ), where num_bands is the number of bands in the hsi image.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: A flattened tensor of attributes.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
    </div>

</div>





  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.meteors.attr.lime.Lime" class="doc doc-heading">
            <code>Lime</code>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="src.meteors.attr.explainer.Explainer">Explainer</span></code></p>


        <p>Lime class is a subclass of Explainer and represents the Lime explainer. Lime is an interpretable model-agnostic
explanation method that explains the predictions of a black-box model by approximating it with a simpler
interpretable model. The Lime method is based on the <a href="https://captum.ai/api/lime.html"><code>captum</code> implementation</a>
and is an implementation of an idea coming from the <a href="https://arxiv.org/abs/1602.04938">original paper on Lime</a>,
where more details about this method can be found.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>explainable_model</code>
            </td>
            <td>
                  <code><span title="meteors.models.ExplainableModel">ExplainableModel</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The explainable model to be explained.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>interpretable_model</code>
            </td>
            <td>
                  <code><span title="meteors.models.InterpretableModel">InterpretableModel</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The interpretable model used to approximate the black-box model.
Defaults to <code>SkLearnLasso</code> with alpha parameter set to 0.08.</p>
              </div>
            </td>
            <td>
                  <code><span title="meteors.models.SkLearnLasso">SkLearnLasso</span>(alpha=0.08)</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>similarity_func</code>
            </td>
            <td>
                  <code><span title="typing_extensions.Callable">Callable</span>[[<span title="torch.Tensor">Tensor</span>], <span title="torch.Tensor">Tensor</span>] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The similarity function used by Lime.
Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>perturb_func</code>
            </td>
            <td>
                  <code><span title="typing_extensions.Callable">Callable</span>[[<span title="torch.Tensor">Tensor</span>], <span title="torch.Tensor">Tensor</span>] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The perturbation function used by Lime.
Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>






              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/lime.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 303</span>
<span class="normal"> 304</span>
<span class="normal"> 305</span>
<span class="normal"> 306</span>
<span class="normal"> 307</span>
<span class="normal"> 308</span>
<span class="normal"> 309</span>
<span class="normal"> 310</span>
<span class="normal"> 311</span>
<span class="normal"> 312</span>
<span class="normal"> 313</span>
<span class="normal"> 314</span>
<span class="normal"> 315</span>
<span class="normal"> 316</span>
<span class="normal"> 317</span>
<span class="normal"> 318</span>
<span class="normal"> 319</span>
<span class="normal"> 320</span>
<span class="normal"> 321</span>
<span class="normal"> 322</span>
<span class="normal"> 323</span>
<span class="normal"> 324</span>
<span class="normal"> 325</span>
<span class="normal"> 326</span>
<span class="normal"> 327</span>
<span class="normal"> 328</span>
<span class="normal"> 329</span>
<span class="normal"> 330</span>
<span class="normal"> 331</span>
<span class="normal"> 332</span>
<span class="normal"> 333</span>
<span class="normal"> 334</span>
<span class="normal"> 335</span>
<span class="normal"> 336</span>
<span class="normal"> 337</span>
<span class="normal"> 338</span>
<span class="normal"> 339</span>
<span class="normal"> 340</span>
<span class="normal"> 341</span>
<span class="normal"> 342</span>
<span class="normal"> 343</span>
<span class="normal"> 344</span>
<span class="normal"> 345</span>
<span class="normal"> 346</span>
<span class="normal"> 347</span>
<span class="normal"> 348</span>
<span class="normal"> 349</span>
<span class="normal"> 350</span>
<span class="normal"> 351</span>
<span class="normal"> 352</span>
<span class="normal"> 353</span>
<span class="normal"> 354</span>
<span class="normal"> 355</span>
<span class="normal"> 356</span>
<span class="normal"> 357</span>
<span class="normal"> 358</span>
<span class="normal"> 359</span>
<span class="normal"> 360</span>
<span class="normal"> 361</span>
<span class="normal"> 362</span>
<span class="normal"> 363</span>
<span class="normal"> 364</span>
<span class="normal"> 365</span>
<span class="normal"> 366</span>
<span class="normal"> 367</span>
<span class="normal"> 368</span>
<span class="normal"> 369</span>
<span class="normal"> 370</span>
<span class="normal"> 371</span>
<span class="normal"> 372</span>
<span class="normal"> 373</span>
<span class="normal"> 374</span>
<span class="normal"> 375</span>
<span class="normal"> 376</span>
<span class="normal"> 377</span>
<span class="normal"> 378</span>
<span class="normal"> 379</span>
<span class="normal"> 380</span>
<span class="normal"> 381</span>
<span class="normal"> 382</span>
<span class="normal"> 383</span>
<span class="normal"> 384</span>
<span class="normal"> 385</span>
<span class="normal"> 386</span>
<span class="normal"> 387</span>
<span class="normal"> 388</span>
<span class="normal"> 389</span>
<span class="normal"> 390</span>
<span class="normal"> 391</span>
<span class="normal"> 392</span>
<span class="normal"> 393</span>
<span class="normal"> 394</span>
<span class="normal"> 395</span>
<span class="normal"> 396</span>
<span class="normal"> 397</span>
<span class="normal"> 398</span>
<span class="normal"> 399</span>
<span class="normal"> 400</span>
<span class="normal"> 401</span>
<span class="normal"> 402</span>
<span class="normal"> 403</span>
<span class="normal"> 404</span>
<span class="normal"> 405</span>
<span class="normal"> 406</span>
<span class="normal"> 407</span>
<span class="normal"> 408</span>
<span class="normal"> 409</span>
<span class="normal"> 410</span>
<span class="normal"> 411</span>
<span class="normal"> 412</span>
<span class="normal"> 413</span>
<span class="normal"> 414</span>
<span class="normal"> 415</span>
<span class="normal"> 416</span>
<span class="normal"> 417</span>
<span class="normal"> 418</span>
<span class="normal"> 419</span>
<span class="normal"> 420</span>
<span class="normal"> 421</span>
<span class="normal"> 422</span>
<span class="normal"> 423</span>
<span class="normal"> 424</span>
<span class="normal"> 425</span>
<span class="normal"> 426</span>
<span class="normal"> 427</span>
<span class="normal"> 428</span>
<span class="normal"> 429</span>
<span class="normal"> 430</span>
<span class="normal"> 431</span>
<span class="normal"> 432</span>
<span class="normal"> 433</span>
<span class="normal"> 434</span>
<span class="normal"> 435</span>
<span class="normal"> 436</span>
<span class="normal"> 437</span>
<span class="normal"> 438</span>
<span class="normal"> 439</span>
<span class="normal"> 440</span>
<span class="normal"> 441</span>
<span class="normal"> 442</span>
<span class="normal"> 443</span>
<span class="normal"> 444</span>
<span class="normal"> 445</span>
<span class="normal"> 446</span>
<span class="normal"> 447</span>
<span class="normal"> 448</span>
<span class="normal"> 449</span>
<span class="normal"> 450</span>
<span class="normal"> 451</span>
<span class="normal"> 452</span>
<span class="normal"> 453</span>
<span class="normal"> 454</span>
<span class="normal"> 455</span>
<span class="normal"> 456</span>
<span class="normal"> 457</span>
<span class="normal"> 458</span>
<span class="normal"> 459</span>
<span class="normal"> 460</span>
<span class="normal"> 461</span>
<span class="normal"> 462</span>
<span class="normal"> 463</span>
<span class="normal"> 464</span>
<span class="normal"> 465</span>
<span class="normal"> 466</span>
<span class="normal"> 467</span>
<span class="normal"> 468</span>
<span class="normal"> 469</span>
<span class="normal"> 470</span>
<span class="normal"> 471</span>
<span class="normal"> 472</span>
<span class="normal"> 473</span>
<span class="normal"> 474</span>
<span class="normal"> 475</span>
<span class="normal"> 476</span>
<span class="normal"> 477</span>
<span class="normal"> 478</span>
<span class="normal"> 479</span>
<span class="normal"> 480</span>
<span class="normal"> 481</span>
<span class="normal"> 482</span>
<span class="normal"> 483</span>
<span class="normal"> 484</span>
<span class="normal"> 485</span>
<span class="normal"> 486</span>
<span class="normal"> 487</span>
<span class="normal"> 488</span>
<span class="normal"> 489</span>
<span class="normal"> 490</span>
<span class="normal"> 491</span>
<span class="normal"> 492</span>
<span class="normal"> 493</span>
<span class="normal"> 494</span>
<span class="normal"> 495</span>
<span class="normal"> 496</span>
<span class="normal"> 497</span>
<span class="normal"> 498</span>
<span class="normal"> 499</span>
<span class="normal"> 500</span>
<span class="normal"> 501</span>
<span class="normal"> 502</span>
<span class="normal"> 503</span>
<span class="normal"> 504</span>
<span class="normal"> 505</span>
<span class="normal"> 506</span>
<span class="normal"> 507</span>
<span class="normal"> 508</span>
<span class="normal"> 509</span>
<span class="normal"> 510</span>
<span class="normal"> 511</span>
<span class="normal"> 512</span>
<span class="normal"> 513</span>
<span class="normal"> 514</span>
<span class="normal"> 515</span>
<span class="normal"> 516</span>
<span class="normal"> 517</span>
<span class="normal"> 518</span>
<span class="normal"> 519</span>
<span class="normal"> 520</span>
<span class="normal"> 521</span>
<span class="normal"> 522</span>
<span class="normal"> 523</span>
<span class="normal"> 524</span>
<span class="normal"> 525</span>
<span class="normal"> 526</span>
<span class="normal"> 527</span>
<span class="normal"> 528</span>
<span class="normal"> 529</span>
<span class="normal"> 530</span>
<span class="normal"> 531</span>
<span class="normal"> 532</span>
<span class="normal"> 533</span>
<span class="normal"> 534</span>
<span class="normal"> 535</span>
<span class="normal"> 536</span>
<span class="normal"> 537</span>
<span class="normal"> 538</span>
<span class="normal"> 539</span>
<span class="normal"> 540</span>
<span class="normal"> 541</span>
<span class="normal"> 542</span>
<span class="normal"> 543</span>
<span class="normal"> 544</span>
<span class="normal"> 545</span>
<span class="normal"> 546</span>
<span class="normal"> 547</span>
<span class="normal"> 548</span>
<span class="normal"> 549</span>
<span class="normal"> 550</span>
<span class="normal"> 551</span>
<span class="normal"> 552</span>
<span class="normal"> 553</span>
<span class="normal"> 554</span>
<span class="normal"> 555</span>
<span class="normal"> 556</span>
<span class="normal"> 557</span>
<span class="normal"> 558</span>
<span class="normal"> 559</span>
<span class="normal"> 560</span>
<span class="normal"> 561</span>
<span class="normal"> 562</span>
<span class="normal"> 563</span>
<span class="normal"> 564</span>
<span class="normal"> 565</span>
<span class="normal"> 566</span>
<span class="normal"> 567</span>
<span class="normal"> 568</span>
<span class="normal"> 569</span>
<span class="normal"> 570</span>
<span class="normal"> 571</span>
<span class="normal"> 572</span>
<span class="normal"> 573</span>
<span class="normal"> 574</span>
<span class="normal"> 575</span>
<span class="normal"> 576</span>
<span class="normal"> 577</span>
<span class="normal"> 578</span>
<span class="normal"> 579</span>
<span class="normal"> 580</span>
<span class="normal"> 581</span>
<span class="normal"> 582</span>
<span class="normal"> 583</span>
<span class="normal"> 584</span>
<span class="normal"> 585</span>
<span class="normal"> 586</span>
<span class="normal"> 587</span>
<span class="normal"> 588</span>
<span class="normal"> 589</span>
<span class="normal"> 590</span>
<span class="normal"> 591</span>
<span class="normal"> 592</span>
<span class="normal"> 593</span>
<span class="normal"> 594</span>
<span class="normal"> 595</span>
<span class="normal"> 596</span>
<span class="normal"> 597</span>
<span class="normal"> 598</span>
<span class="normal"> 599</span>
<span class="normal"> 600</span>
<span class="normal"> 601</span>
<span class="normal"> 602</span>
<span class="normal"> 603</span>
<span class="normal"> 604</span>
<span class="normal"> 605</span>
<span class="normal"> 606</span>
<span class="normal"> 607</span>
<span class="normal"> 608</span>
<span class="normal"> 609</span>
<span class="normal"> 610</span>
<span class="normal"> 611</span>
<span class="normal"> 612</span>
<span class="normal"> 613</span>
<span class="normal"> 614</span>
<span class="normal"> 615</span>
<span class="normal"> 616</span>
<span class="normal"> 617</span>
<span class="normal"> 618</span>
<span class="normal"> 619</span>
<span class="normal"> 620</span>
<span class="normal"> 621</span>
<span class="normal"> 622</span>
<span class="normal"> 623</span>
<span class="normal"> 624</span>
<span class="normal"> 625</span>
<span class="normal"> 626</span>
<span class="normal"> 627</span>
<span class="normal"> 628</span>
<span class="normal"> 629</span>
<span class="normal"> 630</span>
<span class="normal"> 631</span>
<span class="normal"> 632</span>
<span class="normal"> 633</span>
<span class="normal"> 634</span>
<span class="normal"> 635</span>
<span class="normal"> 636</span>
<span class="normal"> 637</span>
<span class="normal"> 638</span>
<span class="normal"> 639</span>
<span class="normal"> 640</span>
<span class="normal"> 641</span>
<span class="normal"> 642</span>
<span class="normal"> 643</span>
<span class="normal"> 644</span>
<span class="normal"> 645</span>
<span class="normal"> 646</span>
<span class="normal"> 647</span>
<span class="normal"> 648</span>
<span class="normal"> 649</span>
<span class="normal"> 650</span>
<span class="normal"> 651</span>
<span class="normal"> 652</span>
<span class="normal"> 653</span>
<span class="normal"> 654</span>
<span class="normal"> 655</span>
<span class="normal"> 656</span>
<span class="normal"> 657</span>
<span class="normal"> 658</span>
<span class="normal"> 659</span>
<span class="normal"> 660</span>
<span class="normal"> 661</span>
<span class="normal"> 662</span>
<span class="normal"> 663</span>
<span class="normal"> 664</span>
<span class="normal"> 665</span>
<span class="normal"> 666</span>
<span class="normal"> 667</span>
<span class="normal"> 668</span>
<span class="normal"> 669</span>
<span class="normal"> 670</span>
<span class="normal"> 671</span>
<span class="normal"> 672</span>
<span class="normal"> 673</span>
<span class="normal"> 674</span>
<span class="normal"> 675</span>
<span class="normal"> 676</span>
<span class="normal"> 677</span>
<span class="normal"> 678</span>
<span class="normal"> 679</span>
<span class="normal"> 680</span>
<span class="normal"> 681</span>
<span class="normal"> 682</span>
<span class="normal"> 683</span>
<span class="normal"> 684</span>
<span class="normal"> 685</span>
<span class="normal"> 686</span>
<span class="normal"> 687</span>
<span class="normal"> 688</span>
<span class="normal"> 689</span>
<span class="normal"> 690</span>
<span class="normal"> 691</span>
<span class="normal"> 692</span>
<span class="normal"> 693</span>
<span class="normal"> 694</span>
<span class="normal"> 695</span>
<span class="normal"> 696</span>
<span class="normal"> 697</span>
<span class="normal"> 698</span>
<span class="normal"> 699</span>
<span class="normal"> 700</span>
<span class="normal"> 701</span>
<span class="normal"> 702</span>
<span class="normal"> 703</span>
<span class="normal"> 704</span>
<span class="normal"> 705</span>
<span class="normal"> 706</span>
<span class="normal"> 707</span>
<span class="normal"> 708</span>
<span class="normal"> 709</span>
<span class="normal"> 710</span>
<span class="normal"> 711</span>
<span class="normal"> 712</span>
<span class="normal"> 713</span>
<span class="normal"> 714</span>
<span class="normal"> 715</span>
<span class="normal"> 716</span>
<span class="normal"> 717</span>
<span class="normal"> 718</span>
<span class="normal"> 719</span>
<span class="normal"> 720</span>
<span class="normal"> 721</span>
<span class="normal"> 722</span>
<span class="normal"> 723</span>
<span class="normal"> 724</span>
<span class="normal"> 725</span>
<span class="normal"> 726</span>
<span class="normal"> 727</span>
<span class="normal"> 728</span>
<span class="normal"> 729</span>
<span class="normal"> 730</span>
<span class="normal"> 731</span>
<span class="normal"> 732</span>
<span class="normal"> 733</span>
<span class="normal"> 734</span>
<span class="normal"> 735</span>
<span class="normal"> 736</span>
<span class="normal"> 737</span>
<span class="normal"> 738</span>
<span class="normal"> 739</span>
<span class="normal"> 740</span>
<span class="normal"> 741</span>
<span class="normal"> 742</span>
<span class="normal"> 743</span>
<span class="normal"> 744</span>
<span class="normal"> 745</span>
<span class="normal"> 746</span>
<span class="normal"> 747</span>
<span class="normal"> 748</span>
<span class="normal"> 749</span>
<span class="normal"> 750</span>
<span class="normal"> 751</span>
<span class="normal"> 752</span>
<span class="normal"> 753</span>
<span class="normal"> 754</span>
<span class="normal"> 755</span>
<span class="normal"> 756</span>
<span class="normal"> 757</span>
<span class="normal"> 758</span>
<span class="normal"> 759</span>
<span class="normal"> 760</span>
<span class="normal"> 761</span>
<span class="normal"> 762</span>
<span class="normal"> 763</span>
<span class="normal"> 764</span>
<span class="normal"> 765</span>
<span class="normal"> 766</span>
<span class="normal"> 767</span>
<span class="normal"> 768</span>
<span class="normal"> 769</span>
<span class="normal"> 770</span>
<span class="normal"> 771</span>
<span class="normal"> 772</span>
<span class="normal"> 773</span>
<span class="normal"> 774</span>
<span class="normal"> 775</span>
<span class="normal"> 776</span>
<span class="normal"> 777</span>
<span class="normal"> 778</span>
<span class="normal"> 779</span>
<span class="normal"> 780</span>
<span class="normal"> 781</span>
<span class="normal"> 782</span>
<span class="normal"> 783</span>
<span class="normal"> 784</span>
<span class="normal"> 785</span>
<span class="normal"> 786</span>
<span class="normal"> 787</span>
<span class="normal"> 788</span>
<span class="normal"> 789</span>
<span class="normal"> 790</span>
<span class="normal"> 791</span>
<span class="normal"> 792</span>
<span class="normal"> 793</span>
<span class="normal"> 794</span>
<span class="normal"> 795</span>
<span class="normal"> 796</span>
<span class="normal"> 797</span>
<span class="normal"> 798</span>
<span class="normal"> 799</span>
<span class="normal"> 800</span>
<span class="normal"> 801</span>
<span class="normal"> 802</span>
<span class="normal"> 803</span>
<span class="normal"> 804</span>
<span class="normal"> 805</span>
<span class="normal"> 806</span>
<span class="normal"> 807</span>
<span class="normal"> 808</span>
<span class="normal"> 809</span>
<span class="normal"> 810</span>
<span class="normal"> 811</span>
<span class="normal"> 812</span>
<span class="normal"> 813</span>
<span class="normal"> 814</span>
<span class="normal"> 815</span>
<span class="normal"> 816</span>
<span class="normal"> 817</span>
<span class="normal"> 818</span>
<span class="normal"> 819</span>
<span class="normal"> 820</span>
<span class="normal"> 821</span>
<span class="normal"> 822</span>
<span class="normal"> 823</span>
<span class="normal"> 824</span>
<span class="normal"> 825</span>
<span class="normal"> 826</span>
<span class="normal"> 827</span>
<span class="normal"> 828</span>
<span class="normal"> 829</span>
<span class="normal"> 830</span>
<span class="normal"> 831</span>
<span class="normal"> 832</span>
<span class="normal"> 833</span>
<span class="normal"> 834</span>
<span class="normal"> 835</span>
<span class="normal"> 836</span>
<span class="normal"> 837</span>
<span class="normal"> 838</span>
<span class="normal"> 839</span>
<span class="normal"> 840</span>
<span class="normal"> 841</span>
<span class="normal"> 842</span>
<span class="normal"> 843</span>
<span class="normal"> 844</span>
<span class="normal"> 845</span>
<span class="normal"> 846</span>
<span class="normal"> 847</span>
<span class="normal"> 848</span>
<span class="normal"> 849</span>
<span class="normal"> 850</span>
<span class="normal"> 851</span>
<span class="normal"> 852</span>
<span class="normal"> 853</span>
<span class="normal"> 854</span>
<span class="normal"> 855</span>
<span class="normal"> 856</span>
<span class="normal"> 857</span>
<span class="normal"> 858</span>
<span class="normal"> 859</span>
<span class="normal"> 860</span>
<span class="normal"> 861</span>
<span class="normal"> 862</span>
<span class="normal"> 863</span>
<span class="normal"> 864</span>
<span class="normal"> 865</span>
<span class="normal"> 866</span>
<span class="normal"> 867</span>
<span class="normal"> 868</span>
<span class="normal"> 869</span>
<span class="normal"> 870</span>
<span class="normal"> 871</span>
<span class="normal"> 872</span>
<span class="normal"> 873</span>
<span class="normal"> 874</span>
<span class="normal"> 875</span>
<span class="normal"> 876</span>
<span class="normal"> 877</span>
<span class="normal"> 878</span>
<span class="normal"> 879</span>
<span class="normal"> 880</span>
<span class="normal"> 881</span>
<span class="normal"> 882</span>
<span class="normal"> 883</span>
<span class="normal"> 884</span>
<span class="normal"> 885</span>
<span class="normal"> 886</span>
<span class="normal"> 887</span>
<span class="normal"> 888</span>
<span class="normal"> 889</span>
<span class="normal"> 890</span>
<span class="normal"> 891</span>
<span class="normal"> 892</span>
<span class="normal"> 893</span>
<span class="normal"> 894</span>
<span class="normal"> 895</span>
<span class="normal"> 896</span>
<span class="normal"> 897</span>
<span class="normal"> 898</span>
<span class="normal"> 899</span>
<span class="normal"> 900</span>
<span class="normal"> 901</span>
<span class="normal"> 902</span>
<span class="normal"> 903</span>
<span class="normal"> 904</span>
<span class="normal"> 905</span>
<span class="normal"> 906</span>
<span class="normal"> 907</span>
<span class="normal"> 908</span>
<span class="normal"> 909</span>
<span class="normal"> 910</span>
<span class="normal"> 911</span>
<span class="normal"> 912</span>
<span class="normal"> 913</span>
<span class="normal"> 914</span>
<span class="normal"> 915</span>
<span class="normal"> 916</span>
<span class="normal"> 917</span>
<span class="normal"> 918</span>
<span class="normal"> 919</span>
<span class="normal"> 920</span>
<span class="normal"> 921</span>
<span class="normal"> 922</span>
<span class="normal"> 923</span>
<span class="normal"> 924</span>
<span class="normal"> 925</span>
<span class="normal"> 926</span>
<span class="normal"> 927</span>
<span class="normal"> 928</span>
<span class="normal"> 929</span>
<span class="normal"> 930</span>
<span class="normal"> 931</span>
<span class="normal"> 932</span>
<span class="normal"> 933</span>
<span class="normal"> 934</span>
<span class="normal"> 935</span>
<span class="normal"> 936</span>
<span class="normal"> 937</span>
<span class="normal"> 938</span>
<span class="normal"> 939</span>
<span class="normal"> 940</span>
<span class="normal"> 941</span>
<span class="normal"> 942</span>
<span class="normal"> 943</span>
<span class="normal"> 944</span>
<span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span>
<span class="normal">1299</span>
<span class="normal">1300</span>
<span class="normal">1301</span>
<span class="normal">1302</span>
<span class="normal">1303</span>
<span class="normal">1304</span>
<span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span>
<span class="normal">1310</span>
<span class="normal">1311</span>
<span class="normal">1312</span>
<span class="normal">1313</span>
<span class="normal">1314</span>
<span class="normal">1315</span>
<span class="normal">1316</span>
<span class="normal">1317</span>
<span class="normal">1318</span>
<span class="normal">1319</span>
<span class="normal">1320</span>
<span class="normal">1321</span>
<span class="normal">1322</span>
<span class="normal">1323</span>
<span class="normal">1324</span>
<span class="normal">1325</span>
<span class="normal">1326</span>
<span class="normal">1327</span>
<span class="normal">1328</span>
<span class="normal">1329</span>
<span class="normal">1330</span>
<span class="normal">1331</span>
<span class="normal">1332</span>
<span class="normal">1333</span>
<span class="normal">1334</span>
<span class="normal">1335</span>
<span class="normal">1336</span>
<span class="normal">1337</span>
<span class="normal">1338</span>
<span class="normal">1339</span>
<span class="normal">1340</span>
<span class="normal">1341</span>
<span class="normal">1342</span>
<span class="normal">1343</span>
<span class="normal">1344</span>
<span class="normal">1345</span>
<span class="normal">1346</span>
<span class="normal">1347</span>
<span class="normal">1348</span>
<span class="normal">1349</span>
<span class="normal">1350</span>
<span class="normal">1351</span>
<span class="normal">1352</span>
<span class="normal">1353</span>
<span class="normal">1354</span>
<span class="normal">1355</span>
<span class="normal">1356</span>
<span class="normal">1357</span>
<span class="normal">1358</span>
<span class="normal">1359</span>
<span class="normal">1360</span>
<span class="normal">1361</span>
<span class="normal">1362</span>
<span class="normal">1363</span>
<span class="normal">1364</span>
<span class="normal">1365</span>
<span class="normal">1366</span>
<span class="normal">1367</span>
<span class="normal">1368</span>
<span class="normal">1369</span>
<span class="normal">1370</span>
<span class="normal">1371</span>
<span class="normal">1372</span>
<span class="normal">1373</span>
<span class="normal">1374</span>
<span class="normal">1375</span>
<span class="normal">1376</span>
<span class="normal">1377</span>
<span class="normal">1378</span>
<span class="normal">1379</span>
<span class="normal">1380</span>
<span class="normal">1381</span>
<span class="normal">1382</span>
<span class="normal">1383</span>
<span class="normal">1384</span>
<span class="normal">1385</span>
<span class="normal">1386</span>
<span class="normal">1387</span>
<span class="normal">1388</span>
<span class="normal">1389</span>
<span class="normal">1390</span>
<span class="normal">1391</span>
<span class="normal">1392</span>
<span class="normal">1393</span>
<span class="normal">1394</span>
<span class="normal">1395</span>
<span class="normal">1396</span>
<span class="normal">1397</span>
<span class="normal">1398</span>
<span class="normal">1399</span>
<span class="normal">1400</span>
<span class="normal">1401</span>
<span class="normal">1402</span>
<span class="normal">1403</span>
<span class="normal">1404</span>
<span class="normal">1405</span>
<span class="normal">1406</span>
<span class="normal">1407</span>
<span class="normal">1408</span>
<span class="normal">1409</span>
<span class="normal">1410</span>
<span class="normal">1411</span>
<span class="normal">1412</span>
<span class="normal">1413</span>
<span class="normal">1414</span>
<span class="normal">1415</span>
<span class="normal">1416</span>
<span class="normal">1417</span>
<span class="normal">1418</span>
<span class="normal">1419</span>
<span class="normal">1420</span>
<span class="normal">1421</span>
<span class="normal">1422</span>
<span class="normal">1423</span>
<span class="normal">1424</span>
<span class="normal">1425</span>
<span class="normal">1426</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Lime</span><span class="p">(</span><span class="n">Explainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Lime class is a subclass of Explainer and represents the Lime explainer. Lime is an interpretable model-agnostic</span>
<span class="sd">    explanation method that explains the predictions of a black-box model by approximating it with a simpler</span>
<span class="sd">    interpretable model. The Lime method is based on the [`captum` implementation](https://captum.ai/api/lime.html)</span>
<span class="sd">    and is an implementation of an idea coming from the [original paper on Lime](https://arxiv.org/abs/1602.04938),</span>
<span class="sd">    where more details about this method can be found.</span>

<span class="sd">    Args:</span>
<span class="sd">        explainable_model (ExplainableModel): The explainable model to be explained.</span>
<span class="sd">        interpretable_model (InterpretableModel): The interpretable model used to approximate the black-box model.</span>
<span class="sd">            Defaults to `SkLearnLasso` with alpha parameter set to 0.08.</span>
<span class="sd">        similarity_func (Callable[[torch.Tensor], torch.Tensor] | None, optional): The similarity function used by Lime.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        perturb_func (Callable[[torch.Tensor], torch.Tensor] | None, optional): The perturbation function used by Lime.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">explainable_model</span><span class="p">:</span> <span class="n">ExplainableModel</span><span class="p">,</span>
        <span class="n">interpretable_model</span><span class="p">:</span> <span class="n">InterpretableModel</span> <span class="o">=</span> <span class="n">SkLearnLasso</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.08</span><span class="p">),</span>
        <span class="n">similarity_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">perturb_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">explainable_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpretable_model</span> <span class="o">=</span> <span class="n">interpretable_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="p">:</span> <span class="n">LimeBase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_lime</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">explainable_model</span><span class="o">.</span><span class="n">forward_func</span><span class="p">,</span> <span class="n">interpretable_model</span><span class="p">,</span> <span class="n">similarity_func</span><span class="p">,</span> <span class="n">perturb_func</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_construct_lime</span><span class="p">(</span>
        <span class="n">forward_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
        <span class="n">interpretable_model</span><span class="p">:</span> <span class="n">InterpretableModel</span><span class="p">,</span>
        <span class="n">similarity_func</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">perturb_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LimeBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructs the LimeBase object.</span>

<span class="sd">        Args:</span>
<span class="sd">            forward_func (Callable[[torch.Tensor], torch.Tensor]): The forward function of the explainable model.</span>
<span class="sd">            interpretable_model (InterpretableModel): The interpretable model used to approximate the black-box model.</span>
<span class="sd">            similarity_func (Callable | None): The similarity function used by Lime.</span>
<span class="sd">            perturb_func (Callable[[torch.Tensor], torch.Tensor] | None): The perturbation function used by Lime.</span>

<span class="sd">        Returns:</span>
<span class="sd">            LimeBase: The constructed LimeBase object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">LimeBase</span><span class="p">(</span>
            <span class="n">forward_func</span><span class="o">=</span><span class="n">forward_func</span><span class="p">,</span>
            <span class="n">interpretable_model</span><span class="o">=</span><span class="n">interpretable_model</span><span class="p">,</span>
            <span class="n">similarity_func</span><span class="o">=</span><span class="n">similarity_func</span><span class="p">,</span>
            <span class="n">perturb_func</span><span class="o">=</span><span class="n">perturb_func</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_segmentation_mask</span><span class="p">(</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">segmentation_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;patch&quot;</span><span class="p">,</span> <span class="s2">&quot;slic&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;slic&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generates a segmentation mask for the given hsi using the specified segmentation method.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): The input hyperspectral image for which the segmentation mask needs to be generated.</span>
<span class="sd">            segmentation_method (Literal[&quot;patch&quot;, &quot;slic&quot;], optional): The segmentation method to be used.</span>
<span class="sd">                Defaults to &quot;slic&quot;.</span>
<span class="sd">            **segmentation_method_params (Any): Additional parameters specific to the chosen segmentation method.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The segmentation mask as a tensor.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If the input hsi is not an instance of the HSI class.</span>
<span class="sd">            ValueError: If an unsupported segmentation method is specified.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi = meteors.HSI(image=torch.ones((3, 240, 240)), wavelengths=[462.08, 465.27, 468.47])</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask = mt_lime.Lime.get_segmentation_mask(hsi, segmentation_method=&quot;slic&quot;)</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask.shape</span>
<span class="sd">            torch.Size([1, 240, 240])</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask = meteors.attr.Lime.get_segmentation_mask(hsi, segmentation_method=&quot;patch&quot;, patch_size=2)</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask.shape</span>
<span class="sd">            torch.Size([1, 240, 240])</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask[0, :2, :2]</span>
<span class="sd">            torch.tensor([[1, 1],</span>
<span class="sd">                          [1, 1]])</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask[0, 2:4, :2]</span>
<span class="sd">            torch.tensor([[2, 2],</span>
<span class="sd">                          [2, 2]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;hsi should be an instance of HSI class&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">segmentation_method</span> <span class="o">==</span> <span class="s2">&quot;slic&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_slic_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">segmentation_method</span> <span class="o">==</span> <span class="s2">&quot;patch&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_patch_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported segmentation method: </span><span class="si">{</span><span class="n">segmentation_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MaskCreationError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error creating segmentation mask using method </span><span class="si">{</span><span class="n">segmentation_method</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_band_mask</span><span class="p">(</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">band_names</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">band_indices</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ListOfWavelengthsIndices</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">band_wavelengths</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ListOfWavelengths</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">repeat_dimensions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generates a band mask based on the provided hsi and band information.</span>

<span class="sd">        Remember you need to provide either band_names, band_indices, or band_wavelengths to create the band mask.</span>
<span class="sd">        If you provide more than one, the band mask will be created using only one using the following priority:</span>
<span class="sd">        band_names &gt; band_wavelengths &gt; band_indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): The input hyperspectral image.</span>
<span class="sd">            band_names (None | list[str | list[str]] | dict[tuple[str, ...] | str, int], optional):</span>
<span class="sd">                The names of the spectral bands to include in the mask. Defaults to None.</span>
<span class="sd">            band_indices (None | dict[str | tuple[str, ...], list[tuple[int, int]] | tuple[int, int] | list[int]], optional):</span>
<span class="sd">                The indices or ranges of indices of the spectral bands to include in the mask. Defaults to None.</span>
<span class="sd">            band_wavelengths (None | dict[str | tuple[str, ...], list[tuple[float, float]] | tuple[float, float], list[float], float], optional):</span>
<span class="sd">                The wavelengths or ranges of wavelengths of the spectral bands to include in the mask. Defaults to None.</span>
<span class="sd">            device (str | torch.device | None, optional):</span>
<span class="sd">                The device to use for computation. Defaults to None.</span>
<span class="sd">            repeat_dimensions (bool, optional):</span>
<span class="sd">                Whether to repeat the dimensions of the mask to match the input hsi shape. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[torch.Tensor, dict[tuple[str, ...] | str, int]]: A tuple containing the band mask tensor and a dictionary</span>
<span class="sd">            mapping band names to segment IDs.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If the input hsi is not an instance of the HSI class.</span>
<span class="sd">            ValueError: If no band names, indices, or wavelengths are provided.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((len(wavelengths), 10, 10)), wavelengths=wavelengths)</span>
<span class="sd">            &gt;&gt;&gt; band_names = [&quot;R&quot;, &quot;G&quot;]</span>
<span class="sd">            &gt;&gt;&gt; band_mask, dict_labels_to_segment_ids = mt_lime.Lime.get_band_mask(hsi, band_names=band_names)</span>
<span class="sd">            &gt;&gt;&gt; dict_labels_to_segment_ids</span>
<span class="sd">            {&quot;R&quot;: 1, &quot;G&quot;: 2}</span>
<span class="sd">            &gt;&gt;&gt; band_indices = {&quot;RGB&quot;: [0, 1, 2]}</span>
<span class="sd">            &gt;&gt;&gt; band_mask, dict_labels_to_segment_ids = mt_lime.Lime.get_band_mask(hsi, band_indices=band_indices)</span>
<span class="sd">            &gt;&gt;&gt; dict_labels_to_segment_ids</span>
<span class="sd">            {&quot;RGB&quot;: 1}</span>
<span class="sd">            &gt;&gt;&gt; band_wavelengths = {&quot;RGB&quot;: [(462.08, 465.27), (465.27, 468.47), (468.47, 471.68)]}</span>
<span class="sd">            &gt;&gt;&gt; band_mask, dict_labels_to_segment_ids = mt_lime.Lime.get_band_mask(hsi, band_wavelengths=band_wavelengths)</span>
<span class="sd">            &gt;&gt;&gt; dict_labels_to_segment_ids</span>
<span class="sd">            {&quot;RGB&quot;: 1}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;hsi should be an instance of HSI class&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">band_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">band_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No band names, indices, or wavelengths are provided.&quot;</span><span class="p">)</span>

            <span class="c1"># validate types</span>
            <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">band_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting band mask from band names of spectral bands&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">band_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ignored_params</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">param</span>
                        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;band_wavelengths&quot;</span><span class="p">,</span> <span class="s2">&quot;band_indices&quot;</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">param</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="p">]</span>
                    <span class="n">ignored_params_str</span> <span class="o">=</span> <span class="s2">&quot; and &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ignored_params</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Only the band names will be used to create the band mask. The additional parameters </span><span class="si">{</span><span class="n">ignored_params_str</span><span class="si">}</span><span class="s2"> will be ignored.&quot;</span>
                    <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">validate_band_names</span><span class="p">(</span><span class="n">band_names</span><span class="p">)</span>
                    <span class="n">band_groups</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_band_wavelengths_indices_from_band_names</span><span class="p">(</span>
                        <span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">band_names</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">BandSelectionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Incorrect band names provided: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
            <span class="k">elif</span> <span class="n">band_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting band mask from band groups given by ranges of wavelengths&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="s2">&quot;Only the band wavelengths will be used to create the band mask. The band_indices will be ignored.&quot;</span>
                    <span class="p">)</span>
                <span class="n">validate_band_format</span><span class="p">(</span><span class="n">band_wavelengths</span><span class="p">,</span> <span class="n">variable_name</span><span class="o">=</span><span class="s2">&quot;band_wavelengths&quot;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">band_groups</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_band_indices_from_band_wavelengths</span><span class="p">(</span>
                        <span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span>
                        <span class="n">band_wavelengths</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Incorrect band ranges wavelengths provided, please check if provided wavelengths are correct: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
            <span class="k">elif</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting band mask from band groups given by ranges of indices&quot;</span><span class="p">)</span>
                <span class="n">validate_band_format</span><span class="p">(</span><span class="n">band_indices</span><span class="p">,</span> <span class="n">variable_name</span><span class="o">=</span><span class="s2">&quot;band_indices&quot;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">band_groups</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_band_indices_from_input_band_indices</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">band_indices</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Incorrect band ranges indices provided, please check if provided indices are correct: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

            <span class="k">return</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_create_tensor_band_mask</span><span class="p">(</span>
                <span class="n">hsi</span><span class="p">,</span>
                <span class="n">band_groups</span><span class="p">,</span>
                <span class="n">dict_labels_to_segment_ids</span><span class="o">=</span><span class="n">dict_labels_to_segment_ids</span><span class="p">,</span>
                <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
                <span class="n">repeat_dimensions</span><span class="o">=</span><span class="n">repeat_dimensions</span><span class="p">,</span>
                <span class="n">return_dict_labels_to_segment_ids</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MaskCreationError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error creating band mask: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_make_band_names_indexable</span><span class="p">(</span><span class="n">segment_name</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts a list of strings into a tuple of strings if necessary to make it indexable.</span>

<span class="sd">        Args:</span>
<span class="sd">            segment_name (list[str] | tuple[str, ...] | str): The segment name to be converted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[str, ...] | str: The converted segment name.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If the segment_name is not of type list or string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment_name</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">subitem</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">subitem</span> <span class="ow">in</span> <span class="n">segment_name</span><span class="p">)</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">segment_name</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">subitem</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">subitem</span> <span class="ow">in</span> <span class="n">segment_name</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">segment_name</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Incorrect segment </span><span class="si">{</span><span class="n">segment_name</span><span class="si">}</span><span class="s2"> type. Should be either a list or string&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="c1"># @lru_cache(maxsize=32) Can&#39;t use with lists as they are not hashable</span>
    <span class="k">def</span> <span class="nf">_extract_bands_from_spyndex</span><span class="p">(</span><span class="n">segment_name</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts bands from the given segment name.</span>

<span class="sd">        Args:</span>
<span class="sd">            segment_name (list[str] | tuple[str, ...] | str): The name of the segment.</span>
<span class="sd">                Users may pass either band names or indices names, as in the spyndex library.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[str, ...] | str: A tuple of band names if multiple bands are extracted,</span>
<span class="sd">                or a single band name if only one band is extracted.</span>

<span class="sd">        Raises:</span>
<span class="sd">            BandSelectionError: If the provided band name is invalid.</span>
<span class="sd">                The band name must be either in `spyndex.indices` or `spyndex.bands`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">segment_name</span> <span class="o">=</span> <span class="p">(</span><span class="n">segment_name</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">segment_name</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">segment_name</span><span class="p">)</span>

        <span class="n">band_names_segment</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="n">segment_name</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="n">spyndex</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
                <span class="n">band_names_segment</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spyndex</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">bands</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="n">spyndex</span><span class="o">.</span><span class="n">bands</span><span class="p">:</span>
                <span class="n">band_names_segment</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">band_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">BandSelectionError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Invalid band name </span><span class="si">{</span><span class="n">band_name</span><span class="si">}</span><span class="s2">, band name must be either in `spyndex.indices` or `spyndex.bands`&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">band_names_segment</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_names_segment</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">band_names_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_indices_from_wavelength_indices_range</span><span class="p">(</span>
        <span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">ranges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts wavelength indices ranges to list indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            wavelengths (torch.Tensor): The tensor containing the wavelengths.</span>
<span class="sd">            ranges (list[tuple[int, int]] | tuple[int, int]): The wavelength indices ranges.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[int]: The indices of bands corresponding to the wavelength indices ranges.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validated_ranges_list</span> <span class="o">=</span> <span class="n">validate_segment_format</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span>
        <span class="n">validated_ranges_list</span> <span class="o">=</span> <span class="n">adjust_and_validate_segment_ranges</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">validated_ranges_list</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span>
                <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">validated_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">validated_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span> <span class="k">for</span> <span class="n">validated_range</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_band_wavelengths_indices_from_band_names</span><span class="p">(</span>
        <span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">band_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts band wavelengths indices from the given band names.</span>

<span class="sd">        This function takes a list or dictionary of band names or segments and extracts the list of wavelengths indices</span>
<span class="sd">        associated with each segment. It returns a tuple containing a dictionary with mapping segment labels into</span>
<span class="sd">        wavelength indices and a dictionary mapping segment labels into segment ids.</span>

<span class="sd">        Args:</span>
<span class="sd">            wavelengths (torch.Tensor): The tensor containing the wavelengths.</span>
<span class="sd">            band_names (list[str | list[str]] | dict[tuple[str, ...] | str, int]):</span>
<span class="sd">                A list or dictionary with band names or segments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[dict[tuple[str, ...] | str, list[int]], dict[tuple[str, ...] | str, int]]:</span>
<span class="sd">                A tuple containing the dictionary with mapping segment labels into wavelength indices and the mapping</span>
<span class="sd">                from segment labels into segment ids.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If the band names are not in the correct format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">band_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">band_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;band_names is a list of segments, creating a dictionary of segments&quot;</span><span class="p">)</span>
            <span class="n">band_names_hashed</span> <span class="o">=</span> <span class="p">[</span><span class="n">Lime</span><span class="o">.</span><span class="n">_make_band_names_indexable</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span> <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">band_names</span><span class="p">]</span>
            <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="p">{</span><span class="n">segment</span><span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">band_names_hashed</span><span class="p">)}</span>
            <span class="n">segments_list</span> <span class="o">=</span> <span class="n">band_names_hashed</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_names</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">band_names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">segments_list</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">band_names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>  <span class="c1"># type: ignore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Incorrect band_names type. It should be a dict or a list&quot;</span><span class="p">)</span>
        <span class="n">segments_list_after_mapping</span> <span class="o">=</span> <span class="p">[</span><span class="n">Lime</span><span class="o">.</span><span class="n">_extract_bands_from_spyndex</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span> <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments_list</span><span class="p">]</span>
        <span class="n">band_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">original_segment</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">segments_list</span><span class="p">,</span> <span class="n">segments_list_after_mapping</span><span class="p">):</span>
            <span class="n">segment_indices_ranges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">segment</span> <span class="o">=</span> <span class="p">(</span><span class="n">segment</span><span class="p">,)</span>
            <span class="k">for</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="n">segment</span><span class="p">:</span>
                <span class="n">min_wavelength</span> <span class="o">=</span> <span class="n">spyndex</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">min_wavelength</span>
                <span class="n">max_wavelength</span> <span class="o">=</span> <span class="n">spyndex</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">max_wavelength</span>

                <span class="k">if</span> <span class="n">min_wavelength</span> <span class="o">&gt;</span> <span class="n">wavelengths</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="ow">or</span> <span class="n">max_wavelength</span> <span class="o">&lt;</span> <span class="n">wavelengths</span><span class="o">.</span><span class="n">min</span><span class="p">():</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Band </span><span class="si">{</span><span class="n">band_name</span><span class="si">}</span><span class="s2"> is not present in the given wavelengths. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Band ranges from </span><span class="si">{</span><span class="n">min_wavelength</span><span class="si">}</span><span class="s2"> nm to </span><span class="si">{</span><span class="n">max_wavelength</span><span class="si">}</span><span class="s2"> nm and the HSI wavelengths &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;range from </span><span class="si">{</span><span class="n">wavelengths</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> nm to </span><span class="si">{</span><span class="n">wavelengths</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> nm. The given band will be skipped&quot;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">segment_indices_ranges</span> <span class="o">+=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_convert_wavelengths_to_indices</span><span class="p">(</span>
                        <span class="n">wavelengths</span><span class="p">,</span>
                        <span class="p">(</span><span class="n">spyndex</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">min_wavelength</span><span class="p">,</span> <span class="n">spyndex</span><span class="o">.</span><span class="n">bands</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">max_wavelength</span><span class="p">),</span>
                    <span class="p">)</span>

            <span class="n">segment_list</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_indices_from_wavelength_indices_range</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">segment_indices_ranges</span><span class="p">)</span>
            <span class="n">band_indices</span><span class="p">[</span><span class="n">original_segment</span><span class="p">]</span> <span class="o">=</span> <span class="n">segment_list</span>
        <span class="k">return</span> <span class="n">band_indices</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_convert_wavelengths_to_indices</span><span class="p">(</span>
        <span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">ranges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts wavelength ranges to index ranges.</span>

<span class="sd">        Args:</span>
<span class="sd">            wavelengths (torch.Tensor): The tensor containing the wavelengths.</span>
<span class="sd">            ranges (list[tuple[float, float]] | tuple[float, float]): The wavelength ranges.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[tuple[int, int]]: The index ranges corresponding to the wavelength ranges.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ranges</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">ranges</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="n">start_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
            <span class="n">end_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start_idx</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">end_idx</span><span class="o">.</span><span class="n">item</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">indices</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_band_indices_from_band_wavelengths</span><span class="p">(</span>
        <span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">band_wavelengths</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ListOfWavelengths</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts the ranges or list of wavelengths into indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            wavelengths (torch.Tensor): The tensor containing the wavelengths.</span>
<span class="sd">            band_wavelengths (dict): A dictionary mapping segment labels to wavelength list or ranges.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: A dictionary mapping segment labels to index ranges.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If band_wavelengths is not a dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_wavelengths</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;band_wavelengths should be a dictionary&quot;</span><span class="p">)</span>

        <span class="n">band_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">segment_label</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">band_wavelengths</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch_dtype_to_python_dtype</span><span class="p">(</span><span class="n">wavelengths</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                    <span class="n">segment</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtype</span><span class="p">(</span><span class="n">segment</span><span class="p">)]</span>  <span class="c1"># type: ignore</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">segment</span><span class="p">):</span>
                    <span class="n">segment_dtype</span> <span class="o">=</span> <span class="n">change_dtype_of_list</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_convert_wavelengths_list_to_indices</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">segment_dtype</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">segment_dtype</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="nb">tuple</span><span class="p">(</span><span class="n">change_dtype_of_list</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ranges</span><span class="p">),</span> <span class="n">dtype</span><span class="p">))</span>  <span class="c1"># type: ignore</span>
                            <span class="k">for</span> <span class="n">ranges</span> <span class="ow">in</span> <span class="n">segment</span>
                        <span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">segment_dtype</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">change_dtype_of_list</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">dtype</span><span class="p">))</span>

                    <span class="n">valid_segment_range</span> <span class="o">=</span> <span class="n">validate_segment_format</span><span class="p">(</span><span class="n">segment_dtype</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
                    <span class="n">range_indices</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_convert_wavelengths_to_indices</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">valid_segment_range</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                    <span class="n">valid_indices_format</span> <span class="o">=</span> <span class="n">validate_segment_format</span><span class="p">(</span><span class="n">range_indices</span><span class="p">)</span>
                    <span class="n">valid_range_indices</span> <span class="o">=</span> <span class="n">adjust_and_validate_segment_ranges</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">valid_indices_format</span><span class="p">)</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_indices_from_wavelength_indices_range</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">valid_range_indices</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Problem with segment </span><span class="si">{</span><span class="n">segment_label</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

            <span class="n">band_indices</span><span class="p">[</span><span class="n">segment_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>

        <span class="k">return</span> <span class="n">band_indices</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_convert_wavelengths_list_to_indices</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">ranges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts a list of wavelengths into indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            wavelengths (torch.Tensor): The tensor containing the wavelengths.</span>
<span class="sd">            ranges (list[float]): The list of wavelengths.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[int]: The indices corresponding to the wavelengths.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">wavelength</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">wavelengths</span> <span class="o">==</span> <span class="n">wavelength</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">as_tuple</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">number_of_elements</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">numel</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">number_of_elements</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">number_of_elements</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Couldn&#39;t find wavelength of value </span><span class="si">{</span><span class="n">wavelength</span><span class="si">}</span><span class="s2"> in list of wavelength&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Wavelength of value </span><span class="si">{</span><span class="n">wavelength</span><span class="si">}</span><span class="s2"> was present more than once in list of wavelength&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">indices</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_band_indices_from_input_band_indices</span><span class="p">(</span>
        <span class="n">wavelengths</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">input_band_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ListOfWavelengthsIndices</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get band indices from band list or ranges indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            wavelengths (torch.Tensor): The tensor containing the wavelengths.</span>
<span class="sd">            band_indices (dict[str | tuple[str, ...], ListOfWavelengthsIndices]):</span>
<span class="sd">                A dictionary mapping segment labels to a list of wavelength indices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict[str | tuple[str, ...], list[int]]: A dictionary mapping segment labels to a list of band indices.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If `band_indices` is not a dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_band_indices</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;band_indices should be a dictionary&quot;</span><span class="p">)</span>

        <span class="n">band_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">segment_label</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">input_band_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">indices</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">):</span>
                    <span class="n">indices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>  <span class="c1"># type: ignore</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">valid_indices_format</span> <span class="o">=</span> <span class="n">validate_segment_format</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                    <span class="n">valid_range_indices</span> <span class="o">=</span> <span class="n">adjust_and_validate_segment_ranges</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">valid_indices_format</span><span class="p">)</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_indices_from_wavelength_indices_range</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">valid_range_indices</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

                <span class="n">band_indices</span><span class="p">[</span><span class="n">segment_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>  <span class="c1"># type: ignore</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Problem with segment </span><span class="si">{</span><span class="n">segment_label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">return</span> <span class="n">band_indices</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_overlapping_segments</span><span class="p">(</span><span class="n">dict_labels_to_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check for overlapping segments.</span>

<span class="sd">        Args:</span>
<span class="sd">            dict_labels_to_indices (dict[str | tuple[str, ...], list[int]]):</span>
<span class="sd">                A dictionary mapping segment labels to indices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">overlapping_segments</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dict_labels_to_indices</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">segment_label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">second_label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">dict_labels_to_indices</span><span class="p">[</span><span class="n">segment_label</span><span class="p">]</span>
                <span class="n">second_indices</span> <span class="o">=</span> <span class="n">dict_labels_to_indices</span><span class="p">[</span><span class="n">second_label</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">second_indices</span><span class="p">):</span>
                    <span class="n">overlapping_segments</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">segment_label</span><span class="p">,</span> <span class="n">second_label</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">label_first</span><span class="p">,</span> <span class="n">label_second</span> <span class="ow">in</span> <span class="n">overlapping_segments</span><span class="p">:</span>
            <span class="n">label_first_str</span> <span class="o">=</span> <span class="n">label_first</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label_first</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">label_first</span><span class="p">)</span>
            <span class="n">label_second_str</span> <span class="o">=</span> <span class="n">label_second</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label_second</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">label_second</span><span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Segments </span><span class="si">{</span><span class="n">label_first_str</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">label_second_str</span><span class="si">}</span><span class="s2"> are overlapping,&quot;</span>
                <span class="s2">&quot; overlapping wavelengths will be assigned to only one&quot;</span>
            <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_validate_and_create_dict_labels_to_segment_ids</span><span class="p">(</span>
        <span class="n">dict_labels_to_segment_ids</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">segment_labels</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validates and creates a dictionary mapping segment labels to segment IDs.</span>

<span class="sd">        Args:</span>
<span class="sd">            dict_labels_to_segment_ids (dict[str | tuple[str, ...], int] | None):</span>
<span class="sd">                The existing mapping from segment labels to segment IDs, or None if it doesn&#39;t exist.</span>
<span class="sd">            segment_labels (list[str | tuple[str, ...]]): The list of segment labels.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict[str | tuple[str, ...], int]: A tuple containing the validated dictionary mapping segment</span>
<span class="sd">            labels to segment IDs and a boolean flag indicating whether the segment labels are hashed.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the length of `dict_labels_to_segment_ids` doesn&#39;t match the length of `segment_labels`.</span>
<span class="sd">            ValueError: If a segment label is not present in `dict_labels_to_segment_ids`.</span>
<span class="sd">            ValueError: If there are non-unique segment IDs in `dict_labels_to_segment_ids`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dict_labels_to_segment_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Creating mapping from segment labels into ids&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">segment</span><span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segment_labels</span><span class="p">)}</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Using existing mapping from segment labels into segment ids&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dict_labels_to_segment_ids</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment_labels</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Incorrect dict_labels_to_segment_ids - length mismatch. Expected: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">segment_labels</span><span class="p">)</span><span class="si">}</span><span class="s2">, Actual: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dict_labels_to_segment_ids</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">unique_segment_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dict_labels_to_segment_ids</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_segment_ids</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment_labels</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Non unique segment ids in the dict_labels_to_segment_ids&quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Passed mapping is correct&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dict_labels_to_segment_ids</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_single_dim_band_mask</span><span class="p">(</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">dict_labels_to_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
        <span class="n">dict_labels_to_segment_ids</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a one-dimensional band mask based on the given image, labels, and segment IDs.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): The input hsi.</span>
<span class="sd">            dict_labels_to_indices (dict[str | tuple[str, ...], list[int]]):</span>
<span class="sd">                A dictionary mapping labels or label tuples to lists of indices.</span>
<span class="sd">            dict_labels_to_segment_ids (dict[str | tuple[str, ...], int]):</span>
<span class="sd">                A dictionary mapping labels or label tuples to segment IDs.</span>
<span class="sd">            device (torch.device): The device to use for the tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: The one-dimensional band mask tensor.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the indices for a segment are out of bounds for the one-dimensional band mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">band_mask_single_dim</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

        <span class="n">segment_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dict_labels_to_segment_ids</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">segment_label</span> <span class="ow">in</span> <span class="n">segment_labels</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">segment_indices</span> <span class="o">=</span> <span class="n">dict_labels_to_indices</span><span class="p">[</span><span class="n">segment_label</span><span class="p">]</span>
            <span class="n">segment_id</span> <span class="o">=</span> <span class="n">dict_labels_to_segment_ids</span><span class="p">[</span><span class="n">segment_label</span><span class="p">]</span>
            <span class="n">are_indices_valid</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">band_mask_single_dim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">segment_indices</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">are_indices_valid</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Indices for segment </span><span class="si">{</span><span class="n">segment_label</span><span class="si">}</span><span class="s2"> are out of bounds for the one-dimensional band mask&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;of shape </span><span class="si">{</span><span class="n">band_mask_single_dim</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">band_mask_single_dim</span><span class="p">[</span><span class="n">segment_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">segment_id</span>

        <span class="k">return</span> <span class="n">band_mask_single_dim</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_tensor_band_mask</span><span class="p">(</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">dict_labels_to_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
        <span class="n">dict_labels_to_segment_ids</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">repeat_dimensions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_dict_labels_to_segment_ids</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a tensor band mask from dictionaries. The band mask is created based on the given hsi, labels, and</span>
<span class="sd">        segment IDs. The band mask is a tensor with the same shape as the input hsi and contains segment IDs, where each</span>
<span class="sd">        segment is represented by a unique ID. The band mask will be used to attribute the hsi using the LIME method.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): The input hsi.</span>
<span class="sd">            dict_labels_to_indices (dict[str | tuple[str, ...], list[int]]): A dictionary mapping labels to indices.</span>
<span class="sd">            dict_labels_to_segment_ids (dict[str | tuple[str, ...], int] | None, optional):</span>
<span class="sd">                A dictionary mapping labels to segment IDs. Defaults to None.</span>
<span class="sd">            device (str | torch.device | None, optional): The device to use. Defaults to None.</span>
<span class="sd">            repeat_dimensions (bool, optional): Whether to repeat dimensions. Defaults to False.</span>
<span class="sd">            return_dict_labels_to_segment_ids (bool, optional):</span>
<span class="sd">                Whether to return the dictionary mapping labels to segment IDs. Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor | tuple[torch.Tensor, dict[tuple[str, ...] | str, int]]:</span>
<span class="sd">                The tensor band mask or a tuple containing the tensor band mask</span>
<span class="sd">                and the dictionary mapping labels to segment IDs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">device</span>
        <span class="n">segment_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dict_labels_to_indices</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating a band mask on the device </span><span class="si">{</span><span class="n">device</span><span class="si">}</span><span class="s2"> using </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">segment_labels</span><span class="p">)</span><span class="si">}</span><span class="s2"> segments&quot;</span><span class="p">)</span>

        <span class="c1"># Check for overlapping segments</span>
        <span class="n">Lime</span><span class="o">.</span><span class="n">_check_overlapping_segments</span><span class="p">(</span><span class="n">dict_labels_to_indices</span><span class="p">)</span>

        <span class="c1"># Create or validate dict_labels_to_segment_ids</span>
        <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_validate_and_create_dict_labels_to_segment_ids</span><span class="p">(</span>
            <span class="n">dict_labels_to_segment_ids</span><span class="p">,</span> <span class="n">segment_labels</span>
        <span class="p">)</span>

        <span class="c1"># Create single-dimensional band mask</span>
        <span class="n">band_mask_single_dim</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_create_single_dim_band_mask</span><span class="p">(</span>
            <span class="n">hsi</span><span class="p">,</span> <span class="n">dict_labels_to_indices</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span><span class="p">,</span> <span class="n">device</span>
        <span class="p">)</span>

        <span class="c1"># Expand band mask to match image dimensions</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="n">expand_spectral_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask_single_dim</span><span class="p">,</span> <span class="n">repeat_dimensions</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_dict_labels_to_segment_ids</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">band_mask</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span>
        <span class="k">return</span> <span class="n">band_mask</span>

    <span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">attribution_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;spatial&quot;</span><span class="p">,</span> <span class="s2">&quot;spectral&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributesSpatial</span> <span class="o">|</span> <span class="n">HSIAttributesSpectral</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributesSpatial</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributesSpectral</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A wrapper function to attribute the image using the LIME method. It executes either the</span>
<span class="sd">        `get_spatial_attributes` or `get_spectral_attributes` method based on the provided `attribution_type`. For more</span>
<span class="sd">        detailed description of the methods, please refer to the respective method documentation.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">                If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">                The output will be a list of HSIAttributesSpatial or HSIAttributesSpectral objects.</span>
<span class="sd">            target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">                methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">                must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">                image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">            attribution_type (Literal[&quot;spatial&quot;, &quot;spectral&quot;] | None, optional): The type of attribution to be computed.</span>
<span class="sd">                User can compute spatial or spectral attributions with the LIME method. If None, the method will</span>
<span class="sd">                throw an error. Defaults to None.</span>
<span class="sd">            additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">                the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">                It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">                containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">                These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">                Note that attributions are not computed with respect to these arguments. Default: None</span>
<span class="sd">            kwargs (Any): Additional keyword arguments for the LIME method.</span>

<span class="sd">        Returns:</span>
<span class="sd">            HSIAttributesSpectral | HSIAttributesSpatial | list[HSIAttributesSpectral | HSIAttributesSpatial]:</span>
<span class="sd">                The computed attributions Spectral or Spatial for the input hyperspectral image(s).</span>
<span class="sd">                if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If the Lime object is not initialized or is not an instance of LimeBase.</span>
<span class="sd">            ValueError: If number of HSI images is not equal to the number of masks provided.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; simple_model = lambda x: torch.rand((x.shape[0], 2))</span>
<span class="sd">            &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask = torch.randint(1, 4, (1, 240, 240))</span>
<span class="sd">            &gt;&gt;&gt; lime = meteors.attr.Lime(</span>
<span class="sd">                    explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="sd">                )</span>
<span class="sd">            &gt;&gt;&gt; spatial_attribution = lime.attribute(hsi, segmentation_mask=segmentation_mask, target=0, attribution_type=&quot;spatial&quot;)</span>
<span class="sd">            &gt;&gt;&gt; spatial_attribution.hsi</span>
<span class="sd">            HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="sd">            &gt;&gt;&gt; band_mask = torch.randint(1, 4, (4, 1, 1)).repeat(1, 240, 240)</span>
<span class="sd">            &gt;&gt;&gt; band_names = [&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]</span>
<span class="sd">            &gt;&gt;&gt; spectral_attribution = lime.attribute(</span>
<span class="sd">            ...     hsi, band_mask=band_mask, band_names=band_names, target=0, attribution_type=&quot;spectral&quot;</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; spectral_attribution.hsi</span>
<span class="sd">            HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">attribution_type</span> <span class="o">==</span> <span class="s2">&quot;spatial&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spatial_attributes</span><span class="p">(</span>
                <span class="n">hsi</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">attribution_type</span> <span class="o">==</span> <span class="s2">&quot;spectral&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spectral_attributes</span><span class="p">(</span>
                <span class="n">hsi</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported attribution type: </span><span class="si">{</span><span class="n">attribution_type</span><span class="si">}</span><span class="s2">. Use &#39;spatial&#39; or &#39;spectral&#39;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_spatial_attributes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">segmentation_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">perturbations_per_eval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">segmentation_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;slic&quot;</span><span class="p">,</span> <span class="s2">&quot;patch&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;slic&quot;</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributesSpatial</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSIAttributesSpatial</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get spatial attributes of an hsi image using the LIME method. Based on the provided hsi and segmentation mask</span>
<span class="sd">        LIME method attributes the `superpixels` provided by the segmentation mask. Please refer to the original paper</span>
<span class="sd">        `https://arxiv.org/abs/1602.04938` for more details or to Christoph Molnar&#39;s book</span>
<span class="sd">        `https://christophm.github.io/interpretable-ml-book/lime.html`.</span>

<span class="sd">        This function attributes the hyperspectral image using the LIME (Local Interpretable Model-Agnostic Explanations)</span>
<span class="sd">        method for spatial data. It returns an `HSIAttributesSpatial` object that contains the hyperspectral image,,</span>
<span class="sd">        the attributions, the segmentation mask, and the score of the interpretable model used for the explanation.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">                If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">                The output will be a list of HSIAttributesSpatial objects.</span>
<span class="sd">            segmentation_mask (np.ndarray | torch.Tensor | list[np.ndarray | torch.Tensor] | None, optional):</span>
<span class="sd">                A segmentation mask according to which the attribution should be performed.</span>
<span class="sd">                The segmentation mask should have a 2D or 3D shape, which can be broadcastable to the shape of the</span>
<span class="sd">                input image. The only dimension on which the image and the mask shapes can differ is the spectral</span>
<span class="sd">                dimension, marked with letter `C` in the `image.orientation` parameter. If None, a new segmentation mask</span>
<span class="sd">                is created using the `segmentation_method`. Additional parameters for the segmentation method may be</span>
<span class="sd">                passed as kwargs. If multiple HSI images are provided, a list of segmentation masks can be provided,</span>
<span class="sd">                one for each image. If list is not provided method will assume that the same segmentation mask is used</span>
<span class="sd">                    for all images. Defaults to None.</span>
<span class="sd">            target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">                methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">                must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">                image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">            n_samples (int, optional): The number of samples to generate/analyze in LIME. The more the better but slower.</span>
<span class="sd">                Defaults to 10.</span>
<span class="sd">            perturbations_per_eval (int, optional): The number of perturbations to evaluate at once</span>
<span class="sd">                (Simply the inner batch size). Defaults to 4.</span>
<span class="sd">            verbose (bool, optional): Whether to show the progress bar. Defaults to False.</span>
<span class="sd">            segmentation_method (Literal[&quot;slic&quot;, &quot;patch&quot;], optional):</span>
<span class="sd">                Segmentation method used only if `segmentation_mask` is None. Defaults to &quot;slic&quot;.</span>
<span class="sd">            additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">                the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">                It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">                containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">                These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">                Note that attributions are not computed with respect to these arguments. Default: None</span>
<span class="sd">            **segmentation_method_params (Any): Additional parameters for the segmentation method.</span>

<span class="sd">        Returns:</span>
<span class="sd">            HSIAttributesSpatial | list[HSIAttributesSpatial]: An object containing the image, the attributions,</span>
<span class="sd">                the segmentation mask, and the score of the interpretable model used for the explanation.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If the Lime object is not initialized or is not an instance of LimeBase.</span>
<span class="sd">            MaskCreationError: If there is an error creating the segmentation mask.</span>
<span class="sd">            ValueError: If the number of segmentation masks is not equal to the number of HSI images provided.</span>
<span class="sd">            HSIAttributesError: If there is an error during creating spatial attribution.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; simple_model = lambda x: torch.rand((x.shape[0], 2))</span>
<span class="sd">            &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">            &gt;&gt;&gt; segmentation_mask = torch.randint(1, 4, (1, 240, 240))</span>
<span class="sd">            &gt;&gt;&gt; lime = meteors.attr.Lime(</span>
<span class="sd">                    explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="sd">                )</span>
<span class="sd">            &gt;&gt;&gt; spatial_attribution = lime.get_spatial_attributes(hsi, segmentation_mask=segmentation_mask, target=0)</span>
<span class="sd">            &gt;&gt;&gt; spatial_attribution.hsi</span>
<span class="sd">            HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="sd">            &gt;&gt;&gt; spatial_attribution.attributes.shape</span>
<span class="sd">            torch.Size([4, 240, 240])</span>
<span class="sd">            &gt;&gt;&gt; spatial_attribution.segmentation_mask.shape</span>
<span class="sd">            torch.Size([1, 240, 240])</span>
<span class="sd">            &gt;&gt;&gt; spatial_attribution.score</span>
<span class="sd">            1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="p">,</span> <span class="n">LimeBase</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Lime object not initialized&quot;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">):</span>
            <span class="n">hsi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">HSI</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All of the input hyperspectral images must be of type HSI&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">segmentation_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">segmentation_method</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Segmentation mask is created based on the first HSI image provided, this approach may not be optimal as &quot;</span>
                <span class="s2">&quot;the same segmentation mask may not be the best suitable for all images&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="p">[</span><span class="n">segmentation_mask</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Number of segmentation masks should be equal to the number of HSI images provided, provided </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">ensure_torch_tensor</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Segmentation mask number </span><span class="si">{</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> should be None, numpy array, or torch tensor&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hsi_img</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">)</span> <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">hsi_img</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="k">else</span> <span class="n">mask</span>
            <span class="k">for</span> <span class="n">hsi_img</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_mask</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">validate_mask_shape</span><span class="p">(</span><span class="s2">&quot;segmentation&quot;</span><span class="p">,</span> <span class="n">hsi_img</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_img</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_mask</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="n">hsi_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">hsi_img</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span> <span class="k">for</span> <span class="n">hsi_img</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">hsi_input</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">hsi_input</span> <span class="o">=</span> <span class="n">hsi_input</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="n">lime_attributes</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
            <span class="n">inputs</span><span class="o">=</span><span class="n">hsi_input</span><span class="p">,</span>
            <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
            <span class="n">feature_mask</span><span class="o">=</span><span class="n">segmentation_mask</span><span class="p">,</span>
            <span class="n">n_samples</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
            <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="n">perturbations_per_eval</span><span class="p">,</span>
            <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span><span class="p">,</span>
            <span class="n">show_progress</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">return_input_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">spatial_attribution</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">HSIAttributesSpatial</span><span class="p">(</span>
                    <span class="n">hsi</span><span class="o">=</span><span class="n">hsi_img</span><span class="p">,</span>
                    <span class="n">attributes</span><span class="o">=</span><span class="n">lime_attr</span><span class="p">,</span>
                    <span class="n">mask</span><span class="o">=</span><span class="n">segmentation_mask</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">hsi_img</span><span class="o">.</span><span class="n">image</span><span class="p">),</span>
                    <span class="n">score</span><span class="o">=</span><span class="n">score</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
                    <span class="n">attribution_method</span><span class="o">=</span><span class="s2">&quot;Lime&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">hsi_img</span><span class="p">,</span> <span class="n">lime_attr</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">lime_attributes</span><span class="p">))</span>
            <span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error during creating spatial attribution </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">return</span> <span class="n">spatial_attribution</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatial_attribution</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">spatial_attribution</span>

    <span class="k">def</span> <span class="nf">get_spectral_attributes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">band_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">perturbations_per_eval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">band_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributesSpectral</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributesSpectral</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attributes the hsi image using LIME method for spectral data. Based on the provided hsi and band mask, the LIME</span>
<span class="sd">        method attributes the hsi based on `superbands` (clustered bands) provided by the band mask.</span>
<span class="sd">        Please refer to the original paper `https://arxiv.org/abs/1602.04938` for more details or to</span>
<span class="sd">        Christoph Molnar&#39;s book `https://christophm.github.io/interpretable-ml-book/lime.html`.</span>

<span class="sd">        The function returns a HSIAttributesSpectral object that contains the image, the attributions, the band mask,</span>
<span class="sd">        the band names, and the score of the interpretable model used for the explanation.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">                If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">                The output will be a list of HSIAttributesSpatial objects.</span>
<span class="sd">            band_mask (np.ndarray | torch.Tensor | list[np.ndarray | torch.Tensor] | None, optional): Band mask that</span>
<span class="sd">                is used for the spectral attribution. The band mask should have a 1D or 3D shape, which can be</span>
<span class="sd">                broadcastable to the shape of the input image. The only dimensions on which the image and the mask shapes</span>
<span class="sd">                can differ is the height and width dimensions, marked with letters `H` and `W` in the `image.orientation`</span>
<span class="sd">                parameter. If equals to None, the band mask is created within the function. If multiple HSI images are</span>
<span class="sd">                provided, a list of band masks can be provided, one for each image. If list is not provided method will</span>
<span class="sd">                assume that the same band mask is used for all images. Defaults to None.</span>
<span class="sd">            target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">                methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">                must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">                image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">            n_samples (int, optional): The number of samples to generate/analyze in LIME. The more the better but slower.</span>
<span class="sd">                Defaults to 10.</span>
<span class="sd">            perturbations_per_eval (int, optional): The number of perturbations to evaluate at once</span>
<span class="sd">                (Simply the inner batch size). Defaults to 4.</span>
<span class="sd">            verbose (bool, optional): Whether to show the progress bar. Defaults to False.</span>
<span class="sd">            segmentation_method (Literal[&quot;slic&quot;, &quot;patch&quot;], optional):</span>
<span class="sd">                Segmentation method used only if `segmentation_mask` is None. Defaults to &quot;slic&quot;.</span>
<span class="sd">            additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">                the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">                It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">                containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">                These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">                Note that attributions are not computed with respect to these arguments. Default: None</span>
<span class="sd">            band_names (list[str] | dict[str | tuple[str, ...], int] | None, optional): Band names. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            HSIAttributesSpectral | list[HSIAttributesSpectral]: An object containing the image, the attributions,</span>
<span class="sd">                the band mask, the band names, and the score of the interpretable model used for the explanation.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If the Lime object is not initialized or is not an instance of LimeBase.</span>
<span class="sd">            MaskCreationError: If there is an error creating the band mask.</span>
<span class="sd">            ValueError: If the number of band masks is not equal to the number of HSI images provided.</span>
<span class="sd">            HSIAttributesError: If there is an error during creating spectral attribution.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; simple_model = lambda x: torch.rand((x.shape[0], 2))</span>
<span class="sd">            &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">            &gt;&gt;&gt; band_mask = torch.randint(1, 4, (4, 1, 1)).repeat(1, 240, 240)</span>
<span class="sd">            &gt;&gt;&gt; band_names = [&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]</span>
<span class="sd">            &gt;&gt;&gt; lime = meteors.attr.Lime(</span>
<span class="sd">                    explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="sd">                )</span>
<span class="sd">            &gt;&gt;&gt; spectral_attribution = lime.get_spectral_attributes(hsi, band_mask=band_mask, band_names=band_names, target=0)</span>
<span class="sd">            &gt;&gt;&gt; spectral_attribution.hsi</span>
<span class="sd">            HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="sd">            &gt;&gt;&gt; spectral_attribution.attributes.shape</span>
<span class="sd">            torch.Size([4, 240, 240])</span>
<span class="sd">            &gt;&gt;&gt; spectral_attribution.band_mask.shape</span>
<span class="sd">            torch.Size([4, 240, 240])</span>
<span class="sd">            &gt;&gt;&gt; spectral_attribution.band_names</span>
<span class="sd">            [&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]</span>
<span class="sd">            &gt;&gt;&gt; spectral_attribution.score</span>
<span class="sd">            1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="p">,</span> <span class="n">LimeBase</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Lime object not initialized&quot;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">):</span>
            <span class="n">hsi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">HSI</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All of the input hyperspectral images must be of type HSI&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">band_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">created_bands</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_band_mask</span><span class="p">(</span><span class="n">hsi_img</span><span class="p">,</span> <span class="n">band_names</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_img</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">]</span>
            <span class="n">band_mask</span><span class="p">,</span> <span class="n">band_name_list</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">created_bands</span><span class="p">)</span>
            <span class="n">band_names</span> <span class="o">=</span> <span class="n">band_name_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_mask</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">band_mask</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">band_mask</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_mask</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">band_mask</span> <span class="o">=</span> <span class="p">[</span><span class="n">band_mask</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_mask</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">band_mask</span> <span class="o">=</span> <span class="n">band_mask</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Reusing the same band mask for all images&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Number of band masks should be equal to the number of HSI images provided, provided </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">band_mask</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="n">band_mask</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">ensure_torch_tensor</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Band mask number </span><span class="si">{</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> should be None, numpy array, or torch tensor&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">band_mask</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hsi_img</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">hsi_img</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span>
            <span class="k">else</span> <span class="n">mask</span>
            <span class="k">for</span> <span class="n">hsi_img</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="p">[</span><span class="n">validate_mask_shape</span><span class="p">(</span><span class="s2">&quot;band&quot;</span><span class="p">,</span> <span class="n">hsi_img</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_img</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask</span><span class="p">)]</span>

        <span class="n">hsi_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">hsi_img</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span> <span class="k">for</span> <span class="n">hsi_img</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">band_mask</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">band_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">band_names</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">segment</span><span class="p">):</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">band_mask</span><span class="p">))}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Band names are provided and will be used. In the future, there should be an option to validate them.&quot;</span>
            <span class="p">)</span>

        <span class="k">assert</span> <span class="n">hsi_input</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">band_mask</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">hsi_input</span> <span class="o">=</span> <span class="n">hsi_input</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="n">band_mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="n">lime_attributes</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
            <span class="n">inputs</span><span class="o">=</span><span class="n">hsi_input</span><span class="p">,</span>
            <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
            <span class="n">feature_mask</span><span class="o">=</span><span class="n">band_mask</span><span class="p">,</span>
            <span class="n">n_samples</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
            <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="n">perturbations_per_eval</span><span class="p">,</span>
            <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span><span class="p">,</span>
            <span class="n">show_progress</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">return_input_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">spectral_attribution</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">HSIAttributesSpectral</span><span class="p">(</span>
                    <span class="n">hsi</span><span class="o">=</span><span class="n">hsi_img</span><span class="p">,</span>
                    <span class="n">attributes</span><span class="o">=</span><span class="n">lime_attr</span><span class="p">,</span>
                    <span class="n">mask</span><span class="o">=</span><span class="n">band_mask</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">hsi_img</span><span class="o">.</span><span class="n">image</span><span class="p">),</span>
                    <span class="n">band_names</span><span class="o">=</span><span class="n">band_names</span><span class="p">,</span>
                    <span class="n">score</span><span class="o">=</span><span class="n">score</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
                    <span class="n">attribution_method</span><span class="o">=</span><span class="s2">&quot;Lime&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">hsi_img</span><span class="p">,</span> <span class="n">lime_attr</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">lime_attributes</span><span class="p">))</span>
            <span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error during creating spectral attribution </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">return</span> <span class="n">spectral_attribution</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectral_attribution</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">spectral_attribution</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_slic_segmentation_mask</span><span class="p">(</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span> <span class="n">num_interpret_features</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a segmentation mask using the SLIC method.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): An HSI object for which the segmentation mask is created.</span>
<span class="sd">            num_interpret_features (int, optional): Number of segments. Defaults to 10.</span>
<span class="sd">            *args: Additional positional arguments to be passed to the SLIC method.</span>
<span class="sd">            **kwargs: Additional keyword arguments to be passed to the SLIC method.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: An output segmentation mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">slic</span><span class="p">(</span>
            <span class="n">hsi</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span>
            <span class="n">n_segments</span><span class="o">=</span><span class="n">num_interpret_features</span><span class="p">,</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">spatial_binary_mask</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span>
            <span class="n">channel_axis</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">segmentation_mask</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">)</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">segmentation_mask</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_patch_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a segmentation mask using the patch method - creates small squares of the same size</span>
<span class="sd">            and assigns a unique value to each square.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (HSI): An HSI object for which the segmentation mask is created.</span>
<span class="sd">            patch_size (int, optional): Size of the patch, the hsi size should be divisible by this value.</span>
<span class="sd">                Defaults to 10.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: An output segmentation mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">patch_size</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">patch_size</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid patch_size. patch_size must be a positive integer&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="n">patch_size</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">%</span> <span class="n">patch_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid patch_size. patch_size must be a factor of both width and height of the hsi&quot;</span><span class="p">)</span>

        <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">idx_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">height</span> <span class="o">//</span> <span class="n">patch_size</span> <span class="o">*</span> <span class="n">width</span> <span class="o">//</span> <span class="n">patch_size</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">height</span> <span class="o">//</span> <span class="n">patch_size</span><span class="p">,</span> <span class="n">width</span> <span class="o">//</span> <span class="n">patch_size</span>
        <span class="p">)</span>
        <span class="n">idx_mask</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">idx_mask</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">segmentation_mask</span> <span class="o">*</span> <span class="n">hsi</span><span class="o">.</span><span class="n">spatial_binary_mask</span>
        <span class="c1"># segmentation_mask = torch.repeat_interleave(</span>
        <span class="c1"># torch.unsqueeze(segmentation_mask, dim=hsi.spectral_axis),</span>
        <span class="c1"># repeats=hsi.image.shape[hsi.spectral_axis], dim=hsi.spectral_axis)</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">)</span>

        <span class="n">mask_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">mask_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mask_idx</span><span class="p">):</span>
            <span class="n">segmentation_mask</span><span class="p">[</span><span class="n">segmentation_mask</span> <span class="o">==</span> <span class="n">mask_val</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>

        <span class="k">return</span> <span class="n">segmentation_mask</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.lime.Lime.attribute" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">attribute</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">attribution_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>A wrapper function to attribute the image using the LIME method. It executes either the
<code>get_spatial_attributes</code> or <code>get_spectral_attributes</code> method based on the provided <code>attribution_type</code>. For more
detailed description of the methods, please refer to the respective method documentation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>hsi</code>
            </td>
            <td>
                  <code>list[<span title="meteors.HSI">HSI</span>] | <span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Input hyperspectral image(s) for which the attributions are to be computed.
If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.
The output will be a list of HSIAttributesSpatial or HSIAttributesSpectral objects.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>target</code>
            </td>
            <td>
                  <code>list[int] | int | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>target class index for computing the attributions. If None,
methods assume that the output has only one class. If the output has multiple classes, the target index
must be provided. For multiple input images, a list of target indices can be provided, one for each
image or single target value will be used for all images. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>attribution_type</code>
            </td>
            <td>
                  <code><span title="typing_extensions.Literal">Literal</span>[&#39;spatial&#39;, &#39;spectral&#39;] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The type of attribution to be computed.
User can compute spatial or spectral attributions with the LIME method. If None, the method will
throw an error. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>additional_forward_args</code>
            </td>
            <td>
                  <code><span title="typing_extensions.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the forward function requires additional arguments other than
the inputs for which attributions should not be computed, this argument can be provided.
It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple
containing multiple additional arguments including tensors or any arbitrary python types.
These arguments are provided to forward_func in order following the arguments in inputs.
Note that attributions are not computed with respect to these arguments. Default: None</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>kwargs</code>
            </td>
            <td>
                  <code><span title="typing_extensions.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional keyword arguments for the LIME method.</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributesSpatial" href="#src.meteors.attr.attributes.HSIAttributesSpatial">HSIAttributesSpatial</a> | <a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributesSpectral" href="#src.meteors.attr.attributes.HSIAttributesSpectral">HSIAttributesSpectral</a> | list[<a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributesSpatial" href="#src.meteors.attr.attributes.HSIAttributesSpatial">HSIAttributesSpatial</a>] | list[<a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributesSpectral" href="#src.meteors.attr.attributes.HSIAttributesSpectral">HSIAttributesSpectral</a>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>HSIAttributesSpectral | HSIAttributesSpatial | list[HSIAttributesSpectral | HSIAttributesSpatial]:
The computed attributions Spectral or Spatial for the input hyperspectral image(s).
if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>RuntimeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the Lime object is not initialized or is not an instance of LimeBase.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If number of HSI images is not equal to the number of masks provided.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">simple_model</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">)),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="p">[</span><span class="mf">462.08</span><span class="p">,</span> <span class="mf">465.27</span><span class="p">,</span> <span class="mf">468.47</span><span class="p">,</span> <span class="mf">471.68</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lime</span> <span class="o">=</span> <span class="n">meteors</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">Lime</span><span class="p">(</span>
<span class="go">        explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_attribution</span> <span class="o">=</span> <span class="n">lime</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_mask</span><span class="o">=</span><span class="n">segmentation_mask</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">attribution_type</span><span class="o">=</span><span class="s2">&quot;spatial&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_attribution</span><span class="o">.</span><span class="n">hsi</span>
<span class="go">HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_attribution</span> <span class="o">=</span> <span class="n">lime</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask</span><span class="o">=</span><span class="n">band_mask</span><span class="p">,</span> <span class="n">band_names</span><span class="o">=</span><span class="n">band_names</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">attribution_type</span><span class="o">=</span><span class="s2">&quot;spectral&quot;</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_attribution</span><span class="o">.</span><span class="n">hsi</span>
<span class="go">HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">attribution_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;spatial&quot;</span><span class="p">,</span> <span class="s2">&quot;spectral&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributesSpatial</span> <span class="o">|</span> <span class="n">HSIAttributesSpectral</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributesSpatial</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributesSpectral</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A wrapper function to attribute the image using the LIME method. It executes either the</span>
<span class="sd">    `get_spatial_attributes` or `get_spectral_attributes` method based on the provided `attribution_type`. For more</span>
<span class="sd">    detailed description of the methods, please refer to the respective method documentation.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">            If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">            The output will be a list of HSIAttributesSpatial or HSIAttributesSpectral objects.</span>
<span class="sd">        target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">            methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">            must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">            image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">        attribution_type (Literal[&quot;spatial&quot;, &quot;spectral&quot;] | None, optional): The type of attribution to be computed.</span>
<span class="sd">            User can compute spatial or spectral attributions with the LIME method. If None, the method will</span>
<span class="sd">            throw an error. Defaults to None.</span>
<span class="sd">        additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">            the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">            It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">            containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">            These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">            Note that attributions are not computed with respect to these arguments. Default: None</span>
<span class="sd">        kwargs (Any): Additional keyword arguments for the LIME method.</span>

<span class="sd">    Returns:</span>
<span class="sd">        HSIAttributesSpectral | HSIAttributesSpatial | list[HSIAttributesSpectral | HSIAttributesSpatial]:</span>
<span class="sd">            The computed attributions Spectral or Spatial for the input hyperspectral image(s).</span>
<span class="sd">            if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If the Lime object is not initialized or is not an instance of LimeBase.</span>
<span class="sd">        ValueError: If number of HSI images is not equal to the number of masks provided.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; simple_model = lambda x: torch.rand((x.shape[0], 2))</span>
<span class="sd">        &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask = torch.randint(1, 4, (1, 240, 240))</span>
<span class="sd">        &gt;&gt;&gt; lime = meteors.attr.Lime(</span>
<span class="sd">                explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="sd">            )</span>
<span class="sd">        &gt;&gt;&gt; spatial_attribution = lime.attribute(hsi, segmentation_mask=segmentation_mask, target=0, attribution_type=&quot;spatial&quot;)</span>
<span class="sd">        &gt;&gt;&gt; spatial_attribution.hsi</span>
<span class="sd">        HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="sd">        &gt;&gt;&gt; band_mask = torch.randint(1, 4, (4, 1, 1)).repeat(1, 240, 240)</span>
<span class="sd">        &gt;&gt;&gt; band_names = [&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]</span>
<span class="sd">        &gt;&gt;&gt; spectral_attribution = lime.attribute(</span>
<span class="sd">        ...     hsi, band_mask=band_mask, band_names=band_names, target=0, attribution_type=&quot;spectral&quot;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; spectral_attribution.hsi</span>
<span class="sd">        HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">attribution_type</span> <span class="o">==</span> <span class="s2">&quot;spatial&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spatial_attributes</span><span class="p">(</span>
            <span class="n">hsi</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">attribution_type</span> <span class="o">==</span> <span class="s2">&quot;spectral&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spectral_attributes</span><span class="p">(</span>
            <span class="n">hsi</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported attribution type: </span><span class="si">{</span><span class="n">attribution_type</span><span class="si">}</span><span class="s2">. Use &#39;spatial&#39; or &#39;spectral&#39;&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.lime.Lime.get_band_mask" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_band_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">band_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">band_wavelengths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">repeat_dimensions</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Generates a band mask based on the provided hsi and band information.</p>
<p>Remember you need to provide either band_names, band_indices, or band_wavelengths to create the band mask.
If you provide more than one, the band mask will be created using only one using the following priority:
band_names &gt; band_wavelengths &gt; band_indices.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>hsi</code>
            </td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The input hyperspectral image.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>band_names</code>
            </td>
            <td>
                  <code>None | list[str | list[str]] | dict[tuple[str, ...] | str, int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The names of the spectral bands to include in the mask. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>band_indices</code>
            </td>
            <td>
                  <code>None | dict[str | tuple[str, ...], list[tuple[int, int]] | tuple[int, int] | list[int]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The indices or ranges of indices of the spectral bands to include in the mask. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>band_wavelengths</code>
            </td>
            <td>
                  <code>None | dict[str | tuple[str, ...], list[tuple[float, float]] | tuple[float, float], list[float], float]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The wavelengths or ranges of wavelengths of the spectral bands to include in the mask. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>device</code>
            </td>
            <td>
                  <code>str | <span title="torch.device">device</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The device to use for computation. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>repeat_dimensions</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to repeat the dimensions of the mask to match the input hsi shape. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple[torch.Tensor, dict[tuple[str, ...] | str, int]]: A tuple containing the band mask tensor and a dictionary</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>dict[tuple[str, ...] | str, int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>mapping band names to segment IDs.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>TypeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the input hsi is not an instance of the HSI class.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If no band names, indices, or wavelengths are provided.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">hsi</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="n">wavelengths</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_mask</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">mt_lime</span><span class="o">.</span><span class="n">Lime</span><span class="o">.</span><span class="n">get_band_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_names</span><span class="o">=</span><span class="n">band_names</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dict_labels_to_segment_ids</span>
<span class="go">{&quot;R&quot;: 1, &quot;G&quot;: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_indices</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;RGB&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_mask</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">mt_lime</span><span class="o">.</span><span class="n">Lime</span><span class="o">.</span><span class="n">get_band_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_indices</span><span class="o">=</span><span class="n">band_indices</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dict_labels_to_segment_ids</span>
<span class="go">{&quot;RGB&quot;: 1}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_wavelengths</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;RGB&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="mf">462.08</span><span class="p">,</span> <span class="mf">465.27</span><span class="p">),</span> <span class="p">(</span><span class="mf">465.27</span><span class="p">,</span> <span class="mf">468.47</span><span class="p">),</span> <span class="p">(</span><span class="mf">468.47</span><span class="p">,</span> <span class="mf">471.68</span><span class="p">)]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_mask</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">mt_lime</span><span class="o">.</span><span class="n">Lime</span><span class="o">.</span><span class="n">get_band_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_wavelengths</span><span class="o">=</span><span class="n">band_wavelengths</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dict_labels_to_segment_ids</span>
<span class="go">{&quot;RGB&quot;: 1}</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">get_band_mask</span><span class="p">(</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">band_names</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">band_indices</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ListOfWavelengthsIndices</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">band_wavelengths</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ListOfWavelengths</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">repeat_dimensions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates a band mask based on the provided hsi and band information.</span>

<span class="sd">    Remember you need to provide either band_names, band_indices, or band_wavelengths to create the band mask.</span>
<span class="sd">    If you provide more than one, the band mask will be created using only one using the following priority:</span>
<span class="sd">    band_names &gt; band_wavelengths &gt; band_indices.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (HSI): The input hyperspectral image.</span>
<span class="sd">        band_names (None | list[str | list[str]] | dict[tuple[str, ...] | str, int], optional):</span>
<span class="sd">            The names of the spectral bands to include in the mask. Defaults to None.</span>
<span class="sd">        band_indices (None | dict[str | tuple[str, ...], list[tuple[int, int]] | tuple[int, int] | list[int]], optional):</span>
<span class="sd">            The indices or ranges of indices of the spectral bands to include in the mask. Defaults to None.</span>
<span class="sd">        band_wavelengths (None | dict[str | tuple[str, ...], list[tuple[float, float]] | tuple[float, float], list[float], float], optional):</span>
<span class="sd">            The wavelengths or ranges of wavelengths of the spectral bands to include in the mask. Defaults to None.</span>
<span class="sd">        device (str | torch.device | None, optional):</span>
<span class="sd">            The device to use for computation. Defaults to None.</span>
<span class="sd">        repeat_dimensions (bool, optional):</span>
<span class="sd">            Whether to repeat the dimensions of the mask to match the input hsi shape. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[torch.Tensor, dict[tuple[str, ...] | str, int]]: A tuple containing the band mask tensor and a dictionary</span>
<span class="sd">        mapping band names to segment IDs.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the input hsi is not an instance of the HSI class.</span>
<span class="sd">        ValueError: If no band names, indices, or wavelengths are provided.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((len(wavelengths), 10, 10)), wavelengths=wavelengths)</span>
<span class="sd">        &gt;&gt;&gt; band_names = [&quot;R&quot;, &quot;G&quot;]</span>
<span class="sd">        &gt;&gt;&gt; band_mask, dict_labels_to_segment_ids = mt_lime.Lime.get_band_mask(hsi, band_names=band_names)</span>
<span class="sd">        &gt;&gt;&gt; dict_labels_to_segment_ids</span>
<span class="sd">        {&quot;R&quot;: 1, &quot;G&quot;: 2}</span>
<span class="sd">        &gt;&gt;&gt; band_indices = {&quot;RGB&quot;: [0, 1, 2]}</span>
<span class="sd">        &gt;&gt;&gt; band_mask, dict_labels_to_segment_ids = mt_lime.Lime.get_band_mask(hsi, band_indices=band_indices)</span>
<span class="sd">        &gt;&gt;&gt; dict_labels_to_segment_ids</span>
<span class="sd">        {&quot;RGB&quot;: 1}</span>
<span class="sd">        &gt;&gt;&gt; band_wavelengths = {&quot;RGB&quot;: [(462.08, 465.27), (465.27, 468.47), (468.47, 471.68)]}</span>
<span class="sd">        &gt;&gt;&gt; band_mask, dict_labels_to_segment_ids = mt_lime.Lime.get_band_mask(hsi, band_wavelengths=band_wavelengths)</span>
<span class="sd">        &gt;&gt;&gt; dict_labels_to_segment_ids</span>
<span class="sd">        {&quot;RGB&quot;: 1}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;hsi should be an instance of HSI class&quot;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">band_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">band_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No band names, indices, or wavelengths are provided.&quot;</span><span class="p">)</span>

        <span class="c1"># validate types</span>
        <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">band_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting band mask from band names of spectral bands&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">band_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ignored_params</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">param</span>
                    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;band_wavelengths&quot;</span><span class="p">,</span> <span class="s2">&quot;band_indices&quot;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">param</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="p">]</span>
                <span class="n">ignored_params_str</span> <span class="o">=</span> <span class="s2">&quot; and &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ignored_params</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Only the band names will be used to create the band mask. The additional parameters </span><span class="si">{</span><span class="n">ignored_params_str</span><span class="si">}</span><span class="s2"> will be ignored.&quot;</span>
                <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">validate_band_names</span><span class="p">(</span><span class="n">band_names</span><span class="p">)</span>
                <span class="n">band_groups</span><span class="p">,</span> <span class="n">dict_labels_to_segment_ids</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_band_wavelengths_indices_from_band_names</span><span class="p">(</span>
                    <span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">band_names</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">BandSelectionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Incorrect band names provided: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
        <span class="k">elif</span> <span class="n">band_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting band mask from band groups given by ranges of wavelengths&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Only the band wavelengths will be used to create the band mask. The band_indices will be ignored.&quot;</span>
                <span class="p">)</span>
            <span class="n">validate_band_format</span><span class="p">(</span><span class="n">band_wavelengths</span><span class="p">,</span> <span class="n">variable_name</span><span class="o">=</span><span class="s2">&quot;band_wavelengths&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">band_groups</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_band_indices_from_band_wavelengths</span><span class="p">(</span>
                    <span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span>
                    <span class="n">band_wavelengths</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Incorrect band ranges wavelengths provided, please check if provided wavelengths are correct: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
        <span class="k">elif</span> <span class="n">band_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting band mask from band groups given by ranges of indices&quot;</span><span class="p">)</span>
            <span class="n">validate_band_format</span><span class="p">(</span><span class="n">band_indices</span><span class="p">,</span> <span class="n">variable_name</span><span class="o">=</span><span class="s2">&quot;band_indices&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">band_groups</span> <span class="o">=</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_band_indices_from_input_band_indices</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">band_indices</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Incorrect band ranges indices provided, please check if provided indices are correct: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">return</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_create_tensor_band_mask</span><span class="p">(</span>
            <span class="n">hsi</span><span class="p">,</span>
            <span class="n">band_groups</span><span class="p">,</span>
            <span class="n">dict_labels_to_segment_ids</span><span class="o">=</span><span class="n">dict_labels_to_segment_ids</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
            <span class="n">repeat_dimensions</span><span class="o">=</span><span class="n">repeat_dimensions</span><span class="p">,</span>
            <span class="n">return_dict_labels_to_segment_ids</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MaskCreationError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error creating band mask: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.lime.Lime.get_segmentation_mask" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_method</span><span class="o">=</span><span class="s1">&#39;slic&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Generates a segmentation mask for the given hsi using the specified segmentation method.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>hsi</code>
            </td>
            <td>
                  <code><span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The input hyperspectral image for which the segmentation mask needs to be generated.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>segmentation_method</code>
            </td>
            <td>
                  <code><span title="typing_extensions.Literal">Literal</span>[&#39;patch&#39;, &#39;slic&#39;]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The segmentation method to be used.
Defaults to "slic".</p>
              </div>
            </td>
            <td>
                  <code>&#39;slic&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**segmentation_method_params</code>
            </td>
            <td>
                  <code><span title="typing_extensions.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional parameters specific to the chosen segmentation method.</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: The segmentation mask as a tensor.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>TypeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the input hsi is not an instance of the HSI class.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If an unsupported segmentation method is specified.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">hsi</span> <span class="o">=</span> <span class="n">meteors</span><span class="o">.</span><span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">)),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="p">[</span><span class="mf">462.08</span><span class="p">,</span> <span class="mf">465.27</span><span class="p">,</span> <span class="mf">468.47</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">mt_lime</span><span class="o">.</span><span class="n">Lime</span><span class="o">.</span><span class="n">get_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_method</span><span class="o">=</span><span class="s2">&quot;slic&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([1, 240, 240])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">meteors</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">Lime</span><span class="o">.</span><span class="n">get_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_method</span><span class="o">=</span><span class="s2">&quot;patch&quot;</span><span class="p">,</span> <span class="n">patch_size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([1, 240, 240])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">torch.tensor([[1, 1],</span>
<span class="go">              [1, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">torch.tensor([[2, 2],</span>
<span class="go">              [2, 2]])</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">get_segmentation_mask</span><span class="p">(</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">segmentation_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;patch&quot;</span><span class="p">,</span> <span class="s2">&quot;slic&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;slic&quot;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates a segmentation mask for the given hsi using the specified segmentation method.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (HSI): The input hyperspectral image for which the segmentation mask needs to be generated.</span>
<span class="sd">        segmentation_method (Literal[&quot;patch&quot;, &quot;slic&quot;], optional): The segmentation method to be used.</span>
<span class="sd">            Defaults to &quot;slic&quot;.</span>
<span class="sd">        **segmentation_method_params (Any): Additional parameters specific to the chosen segmentation method.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: The segmentation mask as a tensor.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the input hsi is not an instance of the HSI class.</span>
<span class="sd">        ValueError: If an unsupported segmentation method is specified.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; hsi = meteors.HSI(image=torch.ones((3, 240, 240)), wavelengths=[462.08, 465.27, 468.47])</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask = mt_lime.Lime.get_segmentation_mask(hsi, segmentation_method=&quot;slic&quot;)</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask.shape</span>
<span class="sd">        torch.Size([1, 240, 240])</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask = meteors.attr.Lime.get_segmentation_mask(hsi, segmentation_method=&quot;patch&quot;, patch_size=2)</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask.shape</span>
<span class="sd">        torch.Size([1, 240, 240])</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask[0, :2, :2]</span>
<span class="sd">        torch.tensor([[1, 1],</span>
<span class="sd">                      [1, 1]])</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask[0, 2:4, :2]</span>
<span class="sd">        torch.tensor([[2, 2],</span>
<span class="sd">                      [2, 2]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;hsi should be an instance of HSI class&quot;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">segmentation_method</span> <span class="o">==</span> <span class="s2">&quot;slic&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_slic_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">segmentation_method</span> <span class="o">==</span> <span class="s2">&quot;patch&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Lime</span><span class="o">.</span><span class="n">_get_patch_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported segmentation method: </span><span class="si">{</span><span class="n">segmentation_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MaskCreationError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error creating segmentation mask using method </span><span class="si">{</span><span class="n">segmentation_method</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.lime.Lime.get_spatial_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_spatial_attributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">segmentation_method</span><span class="o">=</span><span class="s1">&#39;slic&#39;</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Get spatial attributes of an hsi image using the LIME method. Based on the provided hsi and segmentation mask
LIME method attributes the <code>superpixels</code> provided by the segmentation mask. Please refer to the original paper
<code>https://arxiv.org/abs/1602.04938</code> for more details or to Christoph Molnar's book
<code>https://christophm.github.io/interpretable-ml-book/lime.html</code>.</p>
<p>This function attributes the hyperspectral image using the LIME (Local Interpretable Model-Agnostic Explanations)
method for spatial data. It returns an <code>HSIAttributesSpatial</code> object that contains the hyperspectral image,,
the attributions, the segmentation mask, and the score of the interpretable model used for the explanation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>hsi</code>
            </td>
            <td>
                  <code>list[<span title="meteors.HSI">HSI</span>] | <span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Input hyperspectral image(s) for which the attributions are to be computed.
If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.
The output will be a list of HSIAttributesSpatial objects.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>segmentation_mask</code>
            </td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span> | <span title="torch.Tensor">Tensor</span> | list[<span title="numpy.ndarray">ndarray</span> | <span title="torch.Tensor">Tensor</span>] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A segmentation mask according to which the attribution should be performed.
The segmentation mask should have a 2D or 3D shape, which can be broadcastable to the shape of the
input image. The only dimension on which the image and the mask shapes can differ is the spectral
dimension, marked with letter <code>C</code> in the <code>image.orientation</code> parameter. If None, a new segmentation mask
is created using the <code>segmentation_method</code>. Additional parameters for the segmentation method may be
passed as kwargs. If multiple HSI images are provided, a list of segmentation masks can be provided,
one for each image. If list is not provided method will assume that the same segmentation mask is used
    for all images. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>target</code>
            </td>
            <td>
                  <code>list[int] | int | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>target class index for computing the attributions. If None,
methods assume that the output has only one class. If the output has multiple classes, the target index
must be provided. For multiple input images, a list of target indices can be provided, one for each
image or single target value will be used for all images. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_samples</code>
            </td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of samples to generate/analyze in LIME. The more the better but slower.
Defaults to 10.</p>
              </div>
            </td>
            <td>
                  <code>10</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>perturbations_per_eval</code>
            </td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of perturbations to evaluate at once
(Simply the inner batch size). Defaults to 4.</p>
              </div>
            </td>
            <td>
                  <code>4</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>verbose</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to show the progress bar. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>segmentation_method</code>
            </td>
            <td>
                  <code><span title="typing_extensions.Literal">Literal</span>[&#39;slic&#39;, &#39;patch&#39;]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Segmentation method used only if <code>segmentation_mask</code> is None. Defaults to "slic".</p>
              </div>
            </td>
            <td>
                  <code>&#39;slic&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>additional_forward_args</code>
            </td>
            <td>
                  <code><span title="typing_extensions.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the forward function requires additional arguments other than
the inputs for which attributions should not be computed, this argument can be provided.
It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple
containing multiple additional arguments including tensors or any arbitrary python types.
These arguments are provided to forward_func in order following the arguments in inputs.
Note that attributions are not computed with respect to these arguments. Default: None</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**segmentation_method_params</code>
            </td>
            <td>
                  <code><span title="typing_extensions.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional parameters for the segmentation method.</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>list[<a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributesSpatial" href="#src.meteors.attr.attributes.HSIAttributesSpatial">HSIAttributesSpatial</a>] | <a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributesSpatial" href="#src.meteors.attr.attributes.HSIAttributesSpatial">HSIAttributesSpatial</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>HSIAttributesSpatial | list[HSIAttributesSpatial]: An object containing the image, the attributions,
the segmentation mask, and the score of the interpretable model used for the explanation.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>RuntimeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the Lime object is not initialized or is not an instance of LimeBase.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="meteors.exceptions.MaskCreationError">MaskCreationError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If there is an error creating the segmentation mask.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the number of segmentation masks is not equal to the number of HSI images provided.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="meteors.exceptions.HSIAttributesError">HSIAttributesError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If there is an error during creating spatial attribution.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">simple_model</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">)),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="p">[</span><span class="mf">462.08</span><span class="p">,</span> <span class="mf">465.27</span><span class="p">,</span> <span class="mf">468.47</span><span class="p">,</span> <span class="mf">471.68</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lime</span> <span class="o">=</span> <span class="n">meteors</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">Lime</span><span class="p">(</span>
<span class="go">        explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_attribution</span> <span class="o">=</span> <span class="n">lime</span><span class="o">.</span><span class="n">get_spatial_attributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_mask</span><span class="o">=</span><span class="n">segmentation_mask</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_attribution</span><span class="o">.</span><span class="n">hsi</span>
<span class="go">HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_attribution</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([4, 240, 240])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_attribution</span><span class="o">.</span><span class="n">segmentation_mask</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([1, 240, 240])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatial_attribution</span><span class="o">.</span><span class="n">score</span>
<span class="go">1.0</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_spatial_attributes</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">segmentation_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">perturbations_per_eval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">segmentation_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;slic&quot;</span><span class="p">,</span> <span class="s2">&quot;patch&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;slic&quot;</span><span class="p">,</span>
    <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributesSpatial</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSIAttributesSpatial</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get spatial attributes of an hsi image using the LIME method. Based on the provided hsi and segmentation mask</span>
<span class="sd">    LIME method attributes the `superpixels` provided by the segmentation mask. Please refer to the original paper</span>
<span class="sd">    `https://arxiv.org/abs/1602.04938` for more details or to Christoph Molnar&#39;s book</span>
<span class="sd">    `https://christophm.github.io/interpretable-ml-book/lime.html`.</span>

<span class="sd">    This function attributes the hyperspectral image using the LIME (Local Interpretable Model-Agnostic Explanations)</span>
<span class="sd">    method for spatial data. It returns an `HSIAttributesSpatial` object that contains the hyperspectral image,,</span>
<span class="sd">    the attributions, the segmentation mask, and the score of the interpretable model used for the explanation.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">            If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">            The output will be a list of HSIAttributesSpatial objects.</span>
<span class="sd">        segmentation_mask (np.ndarray | torch.Tensor | list[np.ndarray | torch.Tensor] | None, optional):</span>
<span class="sd">            A segmentation mask according to which the attribution should be performed.</span>
<span class="sd">            The segmentation mask should have a 2D or 3D shape, which can be broadcastable to the shape of the</span>
<span class="sd">            input image. The only dimension on which the image and the mask shapes can differ is the spectral</span>
<span class="sd">            dimension, marked with letter `C` in the `image.orientation` parameter. If None, a new segmentation mask</span>
<span class="sd">            is created using the `segmentation_method`. Additional parameters for the segmentation method may be</span>
<span class="sd">            passed as kwargs. If multiple HSI images are provided, a list of segmentation masks can be provided,</span>
<span class="sd">            one for each image. If list is not provided method will assume that the same segmentation mask is used</span>
<span class="sd">                for all images. Defaults to None.</span>
<span class="sd">        target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">            methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">            must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">            image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">        n_samples (int, optional): The number of samples to generate/analyze in LIME. The more the better but slower.</span>
<span class="sd">            Defaults to 10.</span>
<span class="sd">        perturbations_per_eval (int, optional): The number of perturbations to evaluate at once</span>
<span class="sd">            (Simply the inner batch size). Defaults to 4.</span>
<span class="sd">        verbose (bool, optional): Whether to show the progress bar. Defaults to False.</span>
<span class="sd">        segmentation_method (Literal[&quot;slic&quot;, &quot;patch&quot;], optional):</span>
<span class="sd">            Segmentation method used only if `segmentation_mask` is None. Defaults to &quot;slic&quot;.</span>
<span class="sd">        additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">            the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">            It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">            containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">            These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">            Note that attributions are not computed with respect to these arguments. Default: None</span>
<span class="sd">        **segmentation_method_params (Any): Additional parameters for the segmentation method.</span>

<span class="sd">    Returns:</span>
<span class="sd">        HSIAttributesSpatial | list[HSIAttributesSpatial]: An object containing the image, the attributions,</span>
<span class="sd">            the segmentation mask, and the score of the interpretable model used for the explanation.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If the Lime object is not initialized or is not an instance of LimeBase.</span>
<span class="sd">        MaskCreationError: If there is an error creating the segmentation mask.</span>
<span class="sd">        ValueError: If the number of segmentation masks is not equal to the number of HSI images provided.</span>
<span class="sd">        HSIAttributesError: If there is an error during creating spatial attribution.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; simple_model = lambda x: torch.rand((x.shape[0], 2))</span>
<span class="sd">        &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">        &gt;&gt;&gt; segmentation_mask = torch.randint(1, 4, (1, 240, 240))</span>
<span class="sd">        &gt;&gt;&gt; lime = meteors.attr.Lime(</span>
<span class="sd">                explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="sd">            )</span>
<span class="sd">        &gt;&gt;&gt; spatial_attribution = lime.get_spatial_attributes(hsi, segmentation_mask=segmentation_mask, target=0)</span>
<span class="sd">        &gt;&gt;&gt; spatial_attribution.hsi</span>
<span class="sd">        HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="sd">        &gt;&gt;&gt; spatial_attribution.attributes.shape</span>
<span class="sd">        torch.Size([4, 240, 240])</span>
<span class="sd">        &gt;&gt;&gt; spatial_attribution.segmentation_mask.shape</span>
<span class="sd">        torch.Size([1, 240, 240])</span>
<span class="sd">        &gt;&gt;&gt; spatial_attribution.score</span>
<span class="sd">        1.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="p">,</span> <span class="n">LimeBase</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Lime object not initialized&quot;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">):</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">HSI</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All of the input hyperspectral images must be of type HSI&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">segmentation_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segmentation_mask</span><span class="p">(</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">segmentation_method</span><span class="p">,</span> <span class="o">**</span><span class="n">segmentation_method_params</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;Segmentation mask is created based on the first HSI image provided, this approach may not be optimal as &quot;</span>
            <span class="s2">&quot;the same segmentation mask may not be the best suitable for all images&quot;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="p">[</span><span class="n">segmentation_mask</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Number of segmentation masks should be equal to the number of HSI images provided, provided </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">ensure_torch_tensor</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Segmentation mask number </span><span class="si">{</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> should be None, numpy array, or torch tensor&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hsi_img</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">)</span> <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">hsi_img</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="k">else</span> <span class="n">mask</span>
        <span class="k">for</span> <span class="n">hsi_img</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_mask</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">validate_mask_shape</span><span class="p">(</span><span class="s2">&quot;segmentation&quot;</span><span class="p">,</span> <span class="n">hsi_img</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_img</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">segmentation_mask</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="n">hsi_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">hsi_img</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span> <span class="k">for</span> <span class="n">hsi_img</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">segmentation_mask</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">hsi_input</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">segmentation_mask</span> <span class="o">=</span> <span class="n">segmentation_mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">hsi_input</span> <span class="o">=</span> <span class="n">hsi_input</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="n">lime_attributes</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
        <span class="n">inputs</span><span class="o">=</span><span class="n">hsi_input</span><span class="p">,</span>
        <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
        <span class="n">feature_mask</span><span class="o">=</span><span class="n">segmentation_mask</span><span class="p">,</span>
        <span class="n">n_samples</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
        <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="n">perturbations_per_eval</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span><span class="p">,</span>
        <span class="n">show_progress</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="n">return_input_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">spatial_attribution</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">HSIAttributesSpatial</span><span class="p">(</span>
                <span class="n">hsi</span><span class="o">=</span><span class="n">hsi_img</span><span class="p">,</span>
                <span class="n">attributes</span><span class="o">=</span><span class="n">lime_attr</span><span class="p">,</span>
                <span class="n">mask</span><span class="o">=</span><span class="n">segmentation_mask</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">hsi_img</span><span class="o">.</span><span class="n">image</span><span class="p">),</span>
                <span class="n">score</span><span class="o">=</span><span class="n">score</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
                <span class="n">attribution_method</span><span class="o">=</span><span class="s2">&quot;Lime&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">hsi_img</span><span class="p">,</span> <span class="n">lime_attr</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">lime_attributes</span><span class="p">))</span>
        <span class="p">]</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error during creating spatial attribution </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">return</span> <span class="n">spatial_attribution</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatial_attribution</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">spatial_attribution</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.lime.Lime.get_spectral_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_spectral_attributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">band_names</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Attributes the hsi image using LIME method for spectral data. Based on the provided hsi and band mask, the LIME
method attributes the hsi based on <code>superbands</code> (clustered bands) provided by the band mask.
Please refer to the original paper <code>https://arxiv.org/abs/1602.04938</code> for more details or to
Christoph Molnar's book <code>https://christophm.github.io/interpretable-ml-book/lime.html</code>.</p>
<p>The function returns a HSIAttributesSpectral object that contains the image, the attributions, the band mask,
the band names, and the score of the interpretable model used for the explanation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>hsi</code>
            </td>
            <td>
                  <code>list[<span title="meteors.HSI">HSI</span>] | <span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Input hyperspectral image(s) for which the attributions are to be computed.
If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.
The output will be a list of HSIAttributesSpatial objects.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>band_mask</code>
            </td>
            <td>
                  <code><span title="numpy.ndarray">ndarray</span> | <span title="torch.Tensor">Tensor</span> | list[<span title="numpy.ndarray">ndarray</span> | <span title="torch.Tensor">Tensor</span>] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Band mask that
is used for the spectral attribution. The band mask should have a 1D or 3D shape, which can be
broadcastable to the shape of the input image. The only dimensions on which the image and the mask shapes
can differ is the height and width dimensions, marked with letters <code>H</code> and <code>W</code> in the <code>image.orientation</code>
parameter. If equals to None, the band mask is created within the function. If multiple HSI images are
provided, a list of band masks can be provided, one for each image. If list is not provided method will
assume that the same band mask is used for all images. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>target</code>
            </td>
            <td>
                  <code>list[int] | int | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>target class index for computing the attributions. If None,
methods assume that the output has only one class. If the output has multiple classes, the target index
must be provided. For multiple input images, a list of target indices can be provided, one for each
image or single target value will be used for all images. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_samples</code>
            </td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of samples to generate/analyze in LIME. The more the better but slower.
Defaults to 10.</p>
              </div>
            </td>
            <td>
                  <code>10</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>perturbations_per_eval</code>
            </td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of perturbations to evaluate at once
(Simply the inner batch size). Defaults to 4.</p>
              </div>
            </td>
            <td>
                  <code>4</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>verbose</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to show the progress bar. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>segmentation_method</code>
            </td>
            <td>
                  <code><span title="typing_extensions.Literal">Literal</span>[&#39;slic&#39;, &#39;patch&#39;]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Segmentation method used only if <code>segmentation_mask</code> is None. Defaults to "slic".</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>additional_forward_args</code>
            </td>
            <td>
                  <code><span title="typing_extensions.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the forward function requires additional arguments other than
the inputs for which attributions should not be computed, this argument can be provided.
It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple
containing multiple additional arguments including tensors or any arbitrary python types.
These arguments are provided to forward_func in order following the arguments in inputs.
Note that attributions are not computed with respect to these arguments. Default: None</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>band_names</code>
            </td>
            <td>
                  <code>list[str] | dict[str | tuple[str, ...], int] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Band names. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributesSpectral" href="#src.meteors.attr.attributes.HSIAttributesSpectral">HSIAttributesSpectral</a> | list[<a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributesSpectral" href="#src.meteors.attr.attributes.HSIAttributesSpectral">HSIAttributesSpectral</a>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>HSIAttributesSpectral | list[HSIAttributesSpectral]: An object containing the image, the attributions,
the band mask, the band names, and the score of the interpretable model used for the explanation.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>RuntimeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the Lime object is not initialized or is not an instance of LimeBase.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="meteors.exceptions.MaskCreationError">MaskCreationError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If there is an error creating the band mask.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the number of band masks is not equal to the number of HSI images provided.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="meteors.exceptions.HSIAttributesError">HSIAttributesError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If there is an error during creating spectral attribution.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">simple_model</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">)),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="p">[</span><span class="mf">462.08</span><span class="p">,</span> <span class="mf">465.27</span><span class="p">,</span> <span class="mf">468.47</span><span class="p">,</span> <span class="mf">471.68</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">band_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lime</span> <span class="o">=</span> <span class="n">meteors</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">Lime</span><span class="p">(</span>
<span class="go">        explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_attribution</span> <span class="o">=</span> <span class="n">lime</span><span class="o">.</span><span class="n">get_spectral_attributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask</span><span class="o">=</span><span class="n">band_mask</span><span class="p">,</span> <span class="n">band_names</span><span class="o">=</span><span class="n">band_names</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_attribution</span><span class="o">.</span><span class="n">hsi</span>
<span class="go">HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_attribution</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([4, 240, 240])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_attribution</span><span class="o">.</span><span class="n">band_mask</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([4, 240, 240])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_attribution</span><span class="o">.</span><span class="n">band_names</span>
<span class="go">[&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_attribution</span><span class="o">.</span><span class="n">score</span>
<span class="go">1.0</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/lime.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span>
<span class="normal">1299</span>
<span class="normal">1300</span>
<span class="normal">1301</span>
<span class="normal">1302</span>
<span class="normal">1303</span>
<span class="normal">1304</span>
<span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span>
<span class="normal">1310</span>
<span class="normal">1311</span>
<span class="normal">1312</span>
<span class="normal">1313</span>
<span class="normal">1314</span>
<span class="normal">1315</span>
<span class="normal">1316</span>
<span class="normal">1317</span>
<span class="normal">1318</span>
<span class="normal">1319</span>
<span class="normal">1320</span>
<span class="normal">1321</span>
<span class="normal">1322</span>
<span class="normal">1323</span>
<span class="normal">1324</span>
<span class="normal">1325</span>
<span class="normal">1326</span>
<span class="normal">1327</span>
<span class="normal">1328</span>
<span class="normal">1329</span>
<span class="normal">1330</span>
<span class="normal">1331</span>
<span class="normal">1332</span>
<span class="normal">1333</span>
<span class="normal">1334</span>
<span class="normal">1335</span>
<span class="normal">1336</span>
<span class="normal">1337</span>
<span class="normal">1338</span>
<span class="normal">1339</span>
<span class="normal">1340</span>
<span class="normal">1341</span>
<span class="normal">1342</span>
<span class="normal">1343</span>
<span class="normal">1344</span>
<span class="normal">1345</span>
<span class="normal">1346</span>
<span class="normal">1347</span>
<span class="normal">1348</span>
<span class="normal">1349</span>
<span class="normal">1350</span>
<span class="normal">1351</span>
<span class="normal">1352</span>
<span class="normal">1353</span>
<span class="normal">1354</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_spectral_attributes</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">band_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">perturbations_per_eval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">band_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributesSpectral</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributesSpectral</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attributes the hsi image using LIME method for spectral data. Based on the provided hsi and band mask, the LIME</span>
<span class="sd">    method attributes the hsi based on `superbands` (clustered bands) provided by the band mask.</span>
<span class="sd">    Please refer to the original paper `https://arxiv.org/abs/1602.04938` for more details or to</span>
<span class="sd">    Christoph Molnar&#39;s book `https://christophm.github.io/interpretable-ml-book/lime.html`.</span>

<span class="sd">    The function returns a HSIAttributesSpectral object that contains the image, the attributions, the band mask,</span>
<span class="sd">    the band names, and the score of the interpretable model used for the explanation.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">            If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">            The output will be a list of HSIAttributesSpatial objects.</span>
<span class="sd">        band_mask (np.ndarray | torch.Tensor | list[np.ndarray | torch.Tensor] | None, optional): Band mask that</span>
<span class="sd">            is used for the spectral attribution. The band mask should have a 1D or 3D shape, which can be</span>
<span class="sd">            broadcastable to the shape of the input image. The only dimensions on which the image and the mask shapes</span>
<span class="sd">            can differ is the height and width dimensions, marked with letters `H` and `W` in the `image.orientation`</span>
<span class="sd">            parameter. If equals to None, the band mask is created within the function. If multiple HSI images are</span>
<span class="sd">            provided, a list of band masks can be provided, one for each image. If list is not provided method will</span>
<span class="sd">            assume that the same band mask is used for all images. Defaults to None.</span>
<span class="sd">        target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">            methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">            must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">            image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">        n_samples (int, optional): The number of samples to generate/analyze in LIME. The more the better but slower.</span>
<span class="sd">            Defaults to 10.</span>
<span class="sd">        perturbations_per_eval (int, optional): The number of perturbations to evaluate at once</span>
<span class="sd">            (Simply the inner batch size). Defaults to 4.</span>
<span class="sd">        verbose (bool, optional): Whether to show the progress bar. Defaults to False.</span>
<span class="sd">        segmentation_method (Literal[&quot;slic&quot;, &quot;patch&quot;], optional):</span>
<span class="sd">            Segmentation method used only if `segmentation_mask` is None. Defaults to &quot;slic&quot;.</span>
<span class="sd">        additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">            the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">            It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">            containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">            These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">            Note that attributions are not computed with respect to these arguments. Default: None</span>
<span class="sd">        band_names (list[str] | dict[str | tuple[str, ...], int] | None, optional): Band names. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        HSIAttributesSpectral | list[HSIAttributesSpectral]: An object containing the image, the attributions,</span>
<span class="sd">            the band mask, the band names, and the score of the interpretable model used for the explanation.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If the Lime object is not initialized or is not an instance of LimeBase.</span>
<span class="sd">        MaskCreationError: If there is an error creating the band mask.</span>
<span class="sd">        ValueError: If the number of band masks is not equal to the number of HSI images provided.</span>
<span class="sd">        HSIAttributesError: If there is an error during creating spectral attribution.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; simple_model = lambda x: torch.rand((x.shape[0], 2))</span>
<span class="sd">        &gt;&gt;&gt; hsi = mt.HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">        &gt;&gt;&gt; band_mask = torch.randint(1, 4, (4, 1, 1)).repeat(1, 240, 240)</span>
<span class="sd">        &gt;&gt;&gt; band_names = [&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]</span>
<span class="sd">        &gt;&gt;&gt; lime = meteors.attr.Lime(</span>
<span class="sd">                explainable_model=ExplainableModel(simple_model, &quot;regression&quot;), interpretable_model=SkLearnLasso(alpha=0.1)</span>
<span class="sd">            )</span>
<span class="sd">        &gt;&gt;&gt; spectral_attribution = lime.get_spectral_attributes(hsi, band_mask=band_mask, band_names=band_names, target=0)</span>
<span class="sd">        &gt;&gt;&gt; spectral_attribution.hsi</span>
<span class="sd">        HSI(shape=(4, 240, 240), dtype=torch.float32)</span>
<span class="sd">        &gt;&gt;&gt; spectral_attribution.attributes.shape</span>
<span class="sd">        torch.Size([4, 240, 240])</span>
<span class="sd">        &gt;&gt;&gt; spectral_attribution.band_mask.shape</span>
<span class="sd">        torch.Size([4, 240, 240])</span>
<span class="sd">        &gt;&gt;&gt; spectral_attribution.band_names</span>
<span class="sd">        [&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]</span>
<span class="sd">        &gt;&gt;&gt; spectral_attribution.score</span>
<span class="sd">        1.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="p">,</span> <span class="n">LimeBase</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Lime object not initialized&quot;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">HSI</span><span class="p">):</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">HSI</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All of the input hyperspectral images must be of type HSI&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">band_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">created_bands</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_band_mask</span><span class="p">(</span><span class="n">hsi_img</span><span class="p">,</span> <span class="n">band_names</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_img</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">]</span>
        <span class="n">band_mask</span><span class="p">,</span> <span class="n">band_name_list</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">created_bands</span><span class="p">)</span>
        <span class="n">band_names</span> <span class="o">=</span> <span class="n">band_name_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_mask</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">band_mask</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_mask</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="p">[</span><span class="n">band_mask</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_mask</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">band_mask</span> <span class="o">=</span> <span class="n">band_mask</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Reusing the same band mask for all images&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Number of band masks should be equal to the number of HSI images provided, provided </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">band_mask</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="n">band_mask</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">ensure_torch_tensor</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Band mask number </span><span class="si">{</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> should be None, numpy array, or torch tensor&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">band_mask</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">band_mask</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hsi_img</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">hsi_img</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">else</span> <span class="n">mask</span>
        <span class="k">for</span> <span class="n">hsi_img</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">band_mask</span> <span class="o">=</span> <span class="p">[</span><span class="n">validate_mask_shape</span><span class="p">(</span><span class="s2">&quot;band&quot;</span><span class="p">,</span> <span class="n">hsi_img</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_img</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">band_mask</span><span class="p">)]</span>

    <span class="n">hsi_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">hsi_img</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span> <span class="k">for</span> <span class="n">hsi_img</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">band_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">band_mask</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">band_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">band_names</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">segment</span><span class="p">):</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">band_mask</span><span class="p">))}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Band names are provided and will be used. In the future, there should be an option to validate them.&quot;</span>
        <span class="p">)</span>

    <span class="k">assert</span> <span class="n">hsi_input</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">band_mask</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">hsi_input</span> <span class="o">=</span> <span class="n">hsi_input</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">band_mask</span> <span class="o">=</span> <span class="n">band_mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="n">lime_attributes</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
        <span class="n">inputs</span><span class="o">=</span><span class="n">hsi_input</span><span class="p">,</span>
        <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
        <span class="n">feature_mask</span><span class="o">=</span><span class="n">band_mask</span><span class="p">,</span>
        <span class="n">n_samples</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
        <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="n">perturbations_per_eval</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span><span class="p">,</span>
        <span class="n">show_progress</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="n">return_input_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">spectral_attribution</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">HSIAttributesSpectral</span><span class="p">(</span>
                <span class="n">hsi</span><span class="o">=</span><span class="n">hsi_img</span><span class="p">,</span>
                <span class="n">attributes</span><span class="o">=</span><span class="n">lime_attr</span><span class="p">,</span>
                <span class="n">mask</span><span class="o">=</span><span class="n">band_mask</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">hsi_img</span><span class="o">.</span><span class="n">image</span><span class="p">),</span>
                <span class="n">band_names</span><span class="o">=</span><span class="n">band_names</span><span class="p">,</span>
                <span class="n">score</span><span class="o">=</span><span class="n">score</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
                <span class="n">attribution_method</span><span class="o">=</span><span class="s2">&quot;Lime&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">hsi_img</span><span class="p">,</span> <span class="n">lime_attr</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">lime_attributes</span><span class="p">))</span>
        <span class="p">]</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error during creating spectral attribution </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">return</span> <span class="n">spectral_attribution</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectral_attribution</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">spectral_attribution</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h4 id="lime-base">Lime Base</h4>
<p>The Lime Base class was adapted from the Captum Lime implementation. This adaptation builds upon the original work, extending and customizing it for specific use cases within this project. To see the original implementation, please refer to the <a href="https://captum.ai/api/_modules/captum/attr/_core/lime.html#LimeBase">Captum repository</a>.</p>


<div class="doc doc-object doc-class">



<h3 id="src.meteors.attr.integrated_gradients.IntegratedGradients" class="doc doc-heading">
            <code>IntegratedGradients</code>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="src.meteors.attr.explainer.Explainer">Explainer</span></code></p>


        <p>IntegratedGradients explainer class for generating attributions using the Integrated Gradients method.
The Integrated Gradients method is based on the <a href="https://captum.ai/api/integrated_gradients.html"><code>captum</code> implementation</a>
and is an implementation of an idea coming from the <a href="https://arxiv.org/pdf/1703.01365">original paper on Integrated Gradients</a>,
where more details about this method can be found.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.integrated_gradients.IntegratedGradients._attribution_method">_attribution_method</span></code></td>
            <td>
                  <code><span title="captum.attr.IntegratedGradients">IntegratedGradients</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The Integrated Gradients method from the <code>captum</code> library.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.integrated_gradients.IntegratedGradients.multiply_by_inputs">multiply_by_inputs</span></code></td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Indicates whether to factor model inputs’ multiplier in the final attribution scores.
In the literature this is also known as local vs global attribution. If inputs’ multiplier isn’t factored
in, then that type of attribution method is also called local attribution. If it is, then that type of
attribution method is called global. More detailed can be found in this <a href="https://arxiv.org/abs/1711.06104">paper</a>.
In case of integrated gradients, if multiply_by_inputs is set to True,
final sensitivity scores are being multiplied by (inputs - baselines).</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>explainable_model</code>
            </td>
            <td>
                  <code><span title="meteors.models.ExplainableModel">ExplainableModel</span> | <span title="src.meteors.attr.explainer.Explainer">Explainer</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The explainable model to be explained.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>






              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/integrated_gradients.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">IntegratedGradients</span><span class="p">(</span><span class="n">Explainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    IntegratedGradients explainer class for generating attributions using the Integrated Gradients method.</span>
<span class="sd">    The Integrated Gradients method is based on the [`captum` implementation](https://captum.ai/api/integrated_gradients.html)</span>
<span class="sd">    and is an implementation of an idea coming from the [original paper on Integrated Gradients](https://arxiv.org/pdf/1703.01365),</span>
<span class="sd">    where more details about this method can be found.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        _attribution_method (CaptumIntegratedGradients): The Integrated Gradients method from the `captum` library.</span>
<span class="sd">        multiply_by_inputs: Indicates whether to factor model inputs’ multiplier in the final attribution scores.</span>
<span class="sd">            In the literature this is also known as local vs global attribution. If inputs’ multiplier isn’t factored</span>
<span class="sd">            in, then that type of attribution method is also called local attribution. If it is, then that type of</span>
<span class="sd">            attribution method is called global. More detailed can be found in this [paper](https://arxiv.org/abs/1711.06104).</span>
<span class="sd">            In case of integrated gradients, if multiply_by_inputs is set to True,</span>
<span class="sd">            final sensitivity scores are being multiplied by (inputs - baselines).</span>

<span class="sd">    Args:</span>
<span class="sd">        explainable_model (ExplainableModel | Explainer): The explainable model to be explained.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">explainable_model</span><span class="p">:</span> <span class="n">ExplainableModel</span><span class="p">,</span> <span class="n">multiply_by_inputs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">explainable_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multiply_by_inputs</span> <span class="o">=</span> <span class="n">multiply_by_inputs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="o">=</span> <span class="n">CaptumIntegratedGradients</span><span class="p">(</span>
            <span class="n">explainable_model</span><span class="o">.</span><span class="n">forward_func</span><span class="p">,</span> <span class="n">multiply_by_inputs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">multiply_by_inputs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">baseline</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
        <span class="n">internal_batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span>
            <span class="s2">&quot;riemann_right&quot;</span><span class="p">,</span> <span class="s2">&quot;riemann_left&quot;</span><span class="p">,</span> <span class="s2">&quot;riemann_middle&quot;</span><span class="p">,</span> <span class="s2">&quot;riemann_trapezoid&quot;</span><span class="p">,</span> <span class="s2">&quot;gausslegendre&quot;</span>
        <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;gausslegendre&quot;</span><span class="p">,</span>
        <span class="n">return_convergence_delta</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">keep_gradient</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributes</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributes</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for generating attributions using the Integrated Gradients method.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">                If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">                The output will be a list of HSIAttributes objects.</span>
<span class="sd">            baseline (int | float | torch.Tensor | list[int | float | torch.Tensor, optional): Baselines define the</span>
<span class="sd">                starting point from which integral is computed and can be provided as:</span>
<span class="sd">                    - integer or float representing a constant value used as the baseline for all input pixels.</span>
<span class="sd">                    - tensor with the same shape as the input tensor, providing a baseline for each input pixel.</span>
<span class="sd">                        if the input is a list of HSI objects, the baseline can be a tensor with the same shape as</span>
<span class="sd">                        the input tensor for each HSI object.</span>
<span class="sd">                    - list of integers, floats or tensors with the same shape as the input tensor, providing a baseline</span>
<span class="sd">                        for each input pixel. If the input is a list of HSI objects, the baseline can be a list of</span>
<span class="sd">                        tensors with the same shape as the input tensor for each HSI object. Defaults to None.</span>
<span class="sd">            target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">                methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">                must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">                image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">            additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">                the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">                It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">                containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">                These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">                Note that attributions are not computed with respect to these arguments. Default: None</span>
<span class="sd">            n_steps (int, optional): The number of steps to approximate the integral. Default: 50.</span>
<span class="sd">            internal_batch_size (int, optional): Divides total #steps * #examples data points into chunks of size at</span>
<span class="sd">                most internal_batch_size, which are computed (forward / backward passes) sequentially.</span>
<span class="sd">                internal_batch_size must be at least equal to #examples. For DataParallel models, each batch is split</span>
<span class="sd">                among the available devices, so evaluations on each available device contain</span>
<span class="sd">                internal_batch_size / num_devices examples. If internal_batch_size is None, then all evaluations</span>
<span class="sd">                are processed in one batch. Default: None</span>
<span class="sd">            method (Literal[&quot;riemann_right&quot;, &quot;riemann_left&quot;, &quot;riemann_middle&quot;, &quot;riemann_trapezoid&quot;, &quot;gausslegendre&quot;],</span>
<span class="sd">                optional): Method for approximating the integral, one of riemann_right, riemann_left, riemann_middle,</span>
<span class="sd">                riemann_trapezoid or gausslegendre. Default: gausslegendre if no method is provided.</span>
<span class="sd">            return_convergence_delta (bool, optional): Indicates whether to return convergence delta or not.</span>
<span class="sd">                If return_convergence_delta is set to True convergence delta will be returned in a tuple following</span>
<span class="sd">                attributions. Default: False</span>
<span class="sd">            keep_gradient (bool, optional): Indicates whether to keep the gradient tensors in memory. By the default,</span>
<span class="sd">                the gradient tensors are removed from the computation graph after the attributions are computed, due</span>
<span class="sd">                to memory efficiency. If the gradient tensors are needed for further processing, this parameter should</span>
<span class="sd">                be set to True. Default: False</span>

<span class="sd">        Returns:</span>
<span class="sd">            HSIAttributes | list[HSIAttributes]: The computed attributions for the input hyperspectral image(s).</span>
<span class="sd">                if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If the explainer is not initialized.</span>
<span class="sd">            HSIAttributesError: If an error occurs during the generation of the attributions.</span>


<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; integrated_gradients = IntegratedGradients(explainable_model)</span>
<span class="sd">            &gt;&gt;&gt; hsi = HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">            &gt;&gt;&gt; attributions = integrated_gradients.attribute(hsi, method=&quot;riemann_right&quot;, baseline=0.0)</span>
<span class="sd">            &gt;&gt;&gt; attributions, approximation_error = integrated_gradients.attribute(hsi, return_convergence_delta=True)</span>
<span class="sd">            &gt;&gt;&gt; approximation_error</span>
<span class="sd">            0.5</span>
<span class="sd">            &gt;&gt;&gt; attributions = integrated_gradients.attribute([hsi, hsi])</span>
<span class="sd">            &gt;&gt;&gt; len(attributions)</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;IntegratedGradients explainer is not initialized, INITIALIZATION ERROR&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">hsi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">HSI</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All of the input hyperspectral images must be of type HSI&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">baseline</span> <span class="o">=</span> <span class="p">[</span><span class="n">baseline</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>

        <span class="n">baseline</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">validate_and_transform_baseline</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">hsi_image</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">baseline</span><span class="p">)</span>
            <span class="p">],</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>

        <span class="n">ig_attributions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
            <span class="n">input_tensor</span><span class="p">,</span>
            <span class="n">baselines</span><span class="o">=</span><span class="n">baseline</span><span class="p">,</span>
            <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
            <span class="n">n_steps</span><span class="o">=</span><span class="n">n_steps</span><span class="p">,</span>
            <span class="n">internal_batch_size</span><span class="o">=</span><span class="n">internal_batch_size</span><span class="p">,</span>
            <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">return_convergence_delta</span><span class="o">=</span><span class="n">return_convergence_delta</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">return_convergence_delta</span><span class="p">:</span>
            <span class="n">attributions</span><span class="p">,</span> <span class="n">approximation_error</span> <span class="o">=</span> <span class="n">ig_attributions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attributions</span><span class="p">,</span> <span class="n">approximation_error</span> <span class="o">=</span> <span class="n">ig_attributions</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">HSIAttributes</span><span class="p">(</span>
                    <span class="n">hsi</span><span class="o">=</span><span class="n">hsi_image</span><span class="p">,</span>
                    <span class="n">attributes</span><span class="o">=</span><span class="n">attribution</span> <span class="k">if</span> <span class="n">keep_gradient</span> <span class="k">else</span> <span class="n">attribution</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span>
                    <span class="n">score</span><span class="o">=</span><span class="n">error</span><span class="p">,</span>
                    <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">attribution</span><span class="p">,</span> <span class="n">error</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">attributions</span><span class="p">,</span> <span class="n">approximation_error</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error while creating HSIAttributes: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">return</span> <span class="n">attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">attributes</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.integrated_gradients.IntegratedGradients.attribute" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">attribute</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">internal_batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;gausslegendre&#39;</span><span class="p">,</span> <span class="n">return_convergence_delta</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_gradient</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Method for generating attributions using the Integrated Gradients method.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>hsi</code>
            </td>
            <td>
                  <code>list[<span title="meteors.HSI">HSI</span>] | <span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Input hyperspectral image(s) for which the attributions are to be computed.
If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.
The output will be a list of HSIAttributes objects.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>baseline</code>
            </td>
            <td>
                  <code>int | float | torch.Tensor | list[int | float | torch.Tensor</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Baselines define the
starting point from which integral is computed and can be provided as:
    - integer or float representing a constant value used as the baseline for all input pixels.
    - tensor with the same shape as the input tensor, providing a baseline for each input pixel.
        if the input is a list of HSI objects, the baseline can be a tensor with the same shape as
        the input tensor for each HSI object.
    - list of integers, floats or tensors with the same shape as the input tensor, providing a baseline
        for each input pixel. If the input is a list of HSI objects, the baseline can be a list of
        tensors with the same shape as the input tensor for each HSI object. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>target</code>
            </td>
            <td>
                  <code>list[int] | int | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>target class index for computing the attributions. If None,
methods assume that the output has only one class. If the output has multiple classes, the target index
must be provided. For multiple input images, a list of target indices can be provided, one for each
image or single target value will be used for all images. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>additional_forward_args</code>
            </td>
            <td>
                  <code><span title="typing.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the forward function requires additional arguments other than
the inputs for which attributions should not be computed, this argument can be provided.
It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple
containing multiple additional arguments including tensors or any arbitrary python types.
These arguments are provided to forward_func in order following the arguments in inputs.
Note that attributions are not computed with respect to these arguments. Default: None</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_steps</code>
            </td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of steps to approximate the integral. Default: 50.</p>
              </div>
            </td>
            <td>
                  <code>50</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>internal_batch_size</code>
            </td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Divides total #steps * #examples data points into chunks of size at
most internal_batch_size, which are computed (forward / backward passes) sequentially.
internal_batch_size must be at least equal to #examples. For DataParallel models, each batch is split
among the available devices, so evaluations on each available device contain
internal_batch_size / num_devices examples. If internal_batch_size is None, then all evaluations
are processed in one batch. Default: None</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>return_convergence_delta</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Indicates whether to return convergence delta or not.
If return_convergence_delta is set to True convergence delta will be returned in a tuple following
attributions. Default: False</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>keep_gradient</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Indicates whether to keep the gradient tensors in memory. By the default,
the gradient tensors are removed from the computation graph after the attributions are computed, due
to memory efficiency. If the gradient tensors are needed for further processing, this parameter should
be set to True. Default: False</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributes" href="#src.meteors.attr.attributes.HSIAttributes">HSIAttributes</a> | list[<a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributes" href="#src.meteors.attr.attributes.HSIAttributes">HSIAttributes</a>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>HSIAttributes | list[HSIAttributes]: The computed attributions for the input hyperspectral image(s).
if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>RuntimeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the explainer is not initialized.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="meteors.exceptions.HSIAttributesError">HSIAttributesError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If an error occurs during the generation of the attributions.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">integrated_gradients</span> <span class="o">=</span> <span class="n">IntegratedGradients</span><span class="p">(</span><span class="n">explainable_model</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">)),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="p">[</span><span class="mf">462.08</span><span class="p">,</span> <span class="mf">465.27</span><span class="p">,</span> <span class="mf">468.47</span><span class="p">,</span> <span class="mf">471.68</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attributions</span> <span class="o">=</span> <span class="n">integrated_gradients</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;riemann_right&quot;</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attributions</span><span class="p">,</span> <span class="n">approximation_error</span> <span class="o">=</span> <span class="n">integrated_gradients</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">return_convergence_delta</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">approximation_error</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attributions</span> <span class="o">=</span> <span class="n">integrated_gradients</span><span class="o">.</span><span class="n">attribute</span><span class="p">([</span><span class="n">hsi</span><span class="p">,</span> <span class="n">hsi</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">attributions</span><span class="p">)</span>
<span class="go">2</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/integrated_gradients.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">baseline</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
    <span class="n">internal_batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span>
        <span class="s2">&quot;riemann_right&quot;</span><span class="p">,</span> <span class="s2">&quot;riemann_left&quot;</span><span class="p">,</span> <span class="s2">&quot;riemann_middle&quot;</span><span class="p">,</span> <span class="s2">&quot;riemann_trapezoid&quot;</span><span class="p">,</span> <span class="s2">&quot;gausslegendre&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;gausslegendre&quot;</span><span class="p">,</span>
    <span class="n">return_convergence_delta</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">keep_gradient</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributes</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributes</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method for generating attributions using the Integrated Gradients method.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">            If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">            The output will be a list of HSIAttributes objects.</span>
<span class="sd">        baseline (int | float | torch.Tensor | list[int | float | torch.Tensor, optional): Baselines define the</span>
<span class="sd">            starting point from which integral is computed and can be provided as:</span>
<span class="sd">                - integer or float representing a constant value used as the baseline for all input pixels.</span>
<span class="sd">                - tensor with the same shape as the input tensor, providing a baseline for each input pixel.</span>
<span class="sd">                    if the input is a list of HSI objects, the baseline can be a tensor with the same shape as</span>
<span class="sd">                    the input tensor for each HSI object.</span>
<span class="sd">                - list of integers, floats or tensors with the same shape as the input tensor, providing a baseline</span>
<span class="sd">                    for each input pixel. If the input is a list of HSI objects, the baseline can be a list of</span>
<span class="sd">                    tensors with the same shape as the input tensor for each HSI object. Defaults to None.</span>
<span class="sd">        target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">            methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">            must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">            image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">        additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">            the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">            It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">            containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">            These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">            Note that attributions are not computed with respect to these arguments. Default: None</span>
<span class="sd">        n_steps (int, optional): The number of steps to approximate the integral. Default: 50.</span>
<span class="sd">        internal_batch_size (int, optional): Divides total #steps * #examples data points into chunks of size at</span>
<span class="sd">            most internal_batch_size, which are computed (forward / backward passes) sequentially.</span>
<span class="sd">            internal_batch_size must be at least equal to #examples. For DataParallel models, each batch is split</span>
<span class="sd">            among the available devices, so evaluations on each available device contain</span>
<span class="sd">            internal_batch_size / num_devices examples. If internal_batch_size is None, then all evaluations</span>
<span class="sd">            are processed in one batch. Default: None</span>
<span class="sd">        method (Literal[&quot;riemann_right&quot;, &quot;riemann_left&quot;, &quot;riemann_middle&quot;, &quot;riemann_trapezoid&quot;, &quot;gausslegendre&quot;],</span>
<span class="sd">            optional): Method for approximating the integral, one of riemann_right, riemann_left, riemann_middle,</span>
<span class="sd">            riemann_trapezoid or gausslegendre. Default: gausslegendre if no method is provided.</span>
<span class="sd">        return_convergence_delta (bool, optional): Indicates whether to return convergence delta or not.</span>
<span class="sd">            If return_convergence_delta is set to True convergence delta will be returned in a tuple following</span>
<span class="sd">            attributions. Default: False</span>
<span class="sd">        keep_gradient (bool, optional): Indicates whether to keep the gradient tensors in memory. By the default,</span>
<span class="sd">            the gradient tensors are removed from the computation graph after the attributions are computed, due</span>
<span class="sd">            to memory efficiency. If the gradient tensors are needed for further processing, this parameter should</span>
<span class="sd">            be set to True. Default: False</span>

<span class="sd">    Returns:</span>
<span class="sd">        HSIAttributes | list[HSIAttributes]: The computed attributions for the input hyperspectral image(s).</span>
<span class="sd">            if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If the explainer is not initialized.</span>
<span class="sd">        HSIAttributesError: If an error occurs during the generation of the attributions.</span>


<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; integrated_gradients = IntegratedGradients(explainable_model)</span>
<span class="sd">        &gt;&gt;&gt; hsi = HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">        &gt;&gt;&gt; attributions = integrated_gradients.attribute(hsi, method=&quot;riemann_right&quot;, baseline=0.0)</span>
<span class="sd">        &gt;&gt;&gt; attributions, approximation_error = integrated_gradients.attribute(hsi, return_convergence_delta=True)</span>
<span class="sd">        &gt;&gt;&gt; approximation_error</span>
<span class="sd">        0.5</span>
<span class="sd">        &gt;&gt;&gt; attributions = integrated_gradients.attribute([hsi, hsi])</span>
<span class="sd">        &gt;&gt;&gt; len(attributions)</span>
<span class="sd">        2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;IntegratedGradients explainer is not initialized, INITIALIZATION ERROR&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">HSI</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All of the input hyperspectral images must be of type HSI&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">baseline</span> <span class="o">=</span> <span class="p">[</span><span class="n">baseline</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>

    <span class="n">baseline</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">validate_and_transform_baseline</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">hsi_image</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">baseline</span><span class="p">)</span>
        <span class="p">],</span>
        <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
        <span class="p">[</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>

    <span class="n">ig_attributions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
        <span class="n">input_tensor</span><span class="p">,</span>
        <span class="n">baselines</span><span class="o">=</span><span class="n">baseline</span><span class="p">,</span>
        <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
        <span class="n">n_steps</span><span class="o">=</span><span class="n">n_steps</span><span class="p">,</span>
        <span class="n">internal_batch_size</span><span class="o">=</span><span class="n">internal_batch_size</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
        <span class="n">return_convergence_delta</span><span class="o">=</span><span class="n">return_convergence_delta</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">return_convergence_delta</span><span class="p">:</span>
        <span class="n">attributions</span><span class="p">,</span> <span class="n">approximation_error</span> <span class="o">=</span> <span class="n">ig_attributions</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">attributions</span><span class="p">,</span> <span class="n">approximation_error</span> <span class="o">=</span> <span class="n">ig_attributions</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">HSIAttributes</span><span class="p">(</span>
                <span class="n">hsi</span><span class="o">=</span><span class="n">hsi_image</span><span class="p">,</span>
                <span class="n">attributes</span><span class="o">=</span><span class="n">attribution</span> <span class="k">if</span> <span class="n">keep_gradient</span> <span class="k">else</span> <span class="n">attribution</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span>
                <span class="n">score</span><span class="o">=</span><span class="n">error</span><span class="p">,</span>
                <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">attribution</span><span class="p">,</span> <span class="n">error</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">attributions</span><span class="p">,</span> <span class="n">approximation_error</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error while creating HSIAttributes: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">return</span> <span class="n">attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">attributes</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.meteors.attr.input_x_gradients.InputXGradient" class="doc doc-heading">
            <code>InputXGradient</code>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="src.meteors.attr.explainer.Explainer">Explainer</span></code></p>


        <p>Initializes the InputXGradient explainer. The InputXGradients method is a straightforward approach to
computing attribution. It simply multiplies the input image with the gradient with respect to the input.
This method is based on the <a href="https://captum.ai/api/input_x_gradient.html"><code>captum</code> implementation</a></p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.input_x_gradients.InputXGradient._attribution_method">_attribution_method</span></code></td>
            <td>
                  <code>CaptumIntegratedGradients</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The InputXGradient method from the <code>captum</code> library.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>explainable_model</code>
            </td>
            <td>
                  <code><span title="meteors.models.ExplainableModel">ExplainableModel</span> | <span title="src.meteors.attr.explainer.Explainer">Explainer</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The explainable model to be explained.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>






              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/input_x_gradients.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">InputXGradient</span><span class="p">(</span><span class="n">Explainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initializes the InputXGradient explainer. The InputXGradients method is a straightforward approach to</span>
<span class="sd">    computing attribution. It simply multiplies the input image with the gradient with respect to the input.</span>
<span class="sd">    This method is based on the [`captum` implementation](https://captum.ai/api/input_x_gradient.html)</span>

<span class="sd">    Attributes:</span>
<span class="sd">        _attribution_method (CaptumIntegratedGradients): The InputXGradient method from the `captum` library.</span>

<span class="sd">    Args:</span>
<span class="sd">        explainable_model (ExplainableModel | Explainer): The explainable model to be explained.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">explainable_model</span><span class="p">:</span> <span class="n">ExplainableModel</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">explainable_model</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="o">=</span> <span class="n">CaptumInputXGradient</span><span class="p">(</span><span class="n">explainable_model</span><span class="o">.</span><span class="n">forward_func</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">keep_gradient</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributes</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributes</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for generating attributions using the InputXGradient method.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">                If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">                The output will be a list of HSIAttributes objects.</span>
<span class="sd">            target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">                methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">                must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">                image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">            additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">                the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">                It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">                containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">                These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">                Note that attributions are not computed with respect to these arguments. Default: None</span>
<span class="sd">            keep_gradient (bool, optional): Indicates whether to keep the gradient tensors in memory. By the default,</span>
<span class="sd">                the gradient tensors are removed from the computation graph after the attributions are computed, due</span>
<span class="sd">                to memory efficiency. If the gradient tensors are needed for further processing, this parameter should</span>
<span class="sd">                be set to True. Default: False</span>

<span class="sd">        Returns:</span>
<span class="sd">            HSIAttributes | list[HSIAttributes]: The computed attributions for the input hyperspectral image(s).</span>
<span class="sd">                if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If the explainer is not initialized.</span>
<span class="sd">            HSIAttributesError: If an error occurs during the generation of the attributions.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; input_x_gradient = InputXGradient(explainable_model)</span>
<span class="sd">            &gt;&gt;&gt; hsi = HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">            &gt;&gt;&gt; attributions = input_x_gradient.attribute(hsi)</span>
<span class="sd">            &gt;&gt;&gt; attributions = input_x_gradient.attribute([hsi, hsi])</span>
<span class="sd">            &gt;&gt;&gt; len(attributions)</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;InputXGradient explainer is not initialized, INITIALIZATION ERROR&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">hsi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">HSI</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All of the input hyperspectral images must be of type HSI&quot;</span><span class="p">)</span>

        <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>

        <span class="n">gradient_attribution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
            <span class="n">input_tensor</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">HSIAttributes</span><span class="p">(</span>
                    <span class="n">hsi</span><span class="o">=</span><span class="n">hsi_image</span><span class="p">,</span>
                    <span class="n">attributes</span><span class="o">=</span><span class="n">attribution</span> <span class="k">if</span> <span class="n">keep_gradient</span> <span class="k">else</span> <span class="n">attribution</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span>
                    <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">attribution</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">gradient_attribution</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error in generating InputXGradient attributions: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">return</span> <span class="n">attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">attributes</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.input_x_gradients.InputXGradient.attribute" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">attribute</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_gradient</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Method for generating attributions using the InputXGradient method.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>hsi</code>
            </td>
            <td>
                  <code>list[<span title="meteors.HSI">HSI</span>] | <span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Input hyperspectral image(s) for which the attributions are to be computed.
If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.
The output will be a list of HSIAttributes objects.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>target</code>
            </td>
            <td>
                  <code>list[int] | int | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>target class index for computing the attributions. If None,
methods assume that the output has only one class. If the output has multiple classes, the target index
must be provided. For multiple input images, a list of target indices can be provided, one for each
image or single target value will be used for all images. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>additional_forward_args</code>
            </td>
            <td>
                  <code><span title="typing.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the forward function requires additional arguments other than
the inputs for which attributions should not be computed, this argument can be provided.
It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple
containing multiple additional arguments including tensors or any arbitrary python types.
These arguments are provided to forward_func in order following the arguments in inputs.
Note that attributions are not computed with respect to these arguments. Default: None</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>keep_gradient</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Indicates whether to keep the gradient tensors in memory. By the default,
the gradient tensors are removed from the computation graph after the attributions are computed, due
to memory efficiency. If the gradient tensors are needed for further processing, this parameter should
be set to True. Default: False</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributes" href="#src.meteors.attr.attributes.HSIAttributes">HSIAttributes</a> | list[<a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributes" href="#src.meteors.attr.attributes.HSIAttributes">HSIAttributes</a>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>HSIAttributes | list[HSIAttributes]: The computed attributions for the input hyperspectral image(s).
if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>RuntimeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the explainer is not initialized.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="meteors.exceptions.HSIAttributesError">HSIAttributesError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If an error occurs during the generation of the attributions.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">input_x_gradient</span> <span class="o">=</span> <span class="n">InputXGradient</span><span class="p">(</span><span class="n">explainable_model</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">)),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="p">[</span><span class="mf">462.08</span><span class="p">,</span> <span class="mf">465.27</span><span class="p">,</span> <span class="mf">468.47</span><span class="p">,</span> <span class="mf">471.68</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attributions</span> <span class="o">=</span> <span class="n">input_x_gradient</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attributions</span> <span class="o">=</span> <span class="n">input_x_gradient</span><span class="o">.</span><span class="n">attribute</span><span class="p">([</span><span class="n">hsi</span><span class="p">,</span> <span class="n">hsi</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">attributions</span><span class="p">)</span>
<span class="go">2</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/input_x_gradients.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keep_gradient</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributes</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributes</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method for generating attributions using the InputXGradient method.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">            If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">            The output will be a list of HSIAttributes objects.</span>
<span class="sd">        target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">            methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">            must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">            image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">        additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">            the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">            It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">            containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">            These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">            Note that attributions are not computed with respect to these arguments. Default: None</span>
<span class="sd">        keep_gradient (bool, optional): Indicates whether to keep the gradient tensors in memory. By the default,</span>
<span class="sd">            the gradient tensors are removed from the computation graph after the attributions are computed, due</span>
<span class="sd">            to memory efficiency. If the gradient tensors are needed for further processing, this parameter should</span>
<span class="sd">            be set to True. Default: False</span>

<span class="sd">    Returns:</span>
<span class="sd">        HSIAttributes | list[HSIAttributes]: The computed attributions for the input hyperspectral image(s).</span>
<span class="sd">            if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If the explainer is not initialized.</span>
<span class="sd">        HSIAttributesError: If an error occurs during the generation of the attributions.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; input_x_gradient = InputXGradient(explainable_model)</span>
<span class="sd">        &gt;&gt;&gt; hsi = HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">        &gt;&gt;&gt; attributions = input_x_gradient.attribute(hsi)</span>
<span class="sd">        &gt;&gt;&gt; attributions = input_x_gradient.attribute([hsi, hsi])</span>
<span class="sd">        &gt;&gt;&gt; len(attributions)</span>
<span class="sd">        2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;InputXGradient explainer is not initialized, INITIALIZATION ERROR&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">HSI</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All of the input hyperspectral images must be of type HSI&quot;</span><span class="p">)</span>

    <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
        <span class="p">[</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>

    <span class="n">gradient_attribution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
        <span class="n">input_tensor</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span>
    <span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">HSIAttributes</span><span class="p">(</span>
                <span class="n">hsi</span><span class="o">=</span><span class="n">hsi_image</span><span class="p">,</span>
                <span class="n">attributes</span><span class="o">=</span><span class="n">attribution</span> <span class="k">if</span> <span class="n">keep_gradient</span> <span class="k">else</span> <span class="n">attribution</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span>
                <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">attribution</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">gradient_attribution</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error in generating InputXGradient attributions: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">return</span> <span class="n">attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">attributes</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.meteors.attr.occlusion.Occlusion" class="doc doc-heading">
            <code>Occlusion</code>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="src.meteors.attr.explainer.Explainer">Explainer</span></code></p>


        <p>Occlusion explainer class for generating attributions using the Occlusion method.
This attribution method perturbs the input by replacing the contiguous rectangular region
with a given baseline and computing the difference in output.
In our case, features are located in multiple regions, and attribution from different hyper-rectangles is averaged.
The implementation of this method is also based on the <a href="https://captum.ai/api/occlusion.html"><code>captum</code> repository</a>.
More details about this approach can be found in the <a href="https://arxiv.org/abs/1311.2901">original paper</a></p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.occlusion.Occlusion._attribution_method">_attribution_method</span></code></td>
            <td>
                  <code><span title="captum.attr.Occlusion">Occlusion</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The Occlusion method from the <code>captum</code> library.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>explainable_model</code>
            </td>
            <td>
                  <code><span title="meteors.models.ExplainableModel">ExplainableModel</span> | <span title="src.meteors.attr.explainer.Explainer">Explainer</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The explainable model to be explained.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>postprocessing_segmentation_output</code>
            </td>
            <td>
                  <code>Callable[[<span title="torch.Tensor">Tensor</span>], <span title="torch.Tensor">Tensor</span>] | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A segmentation postprocessing function for segmentation problem type. This is required for segmentation
problem type as attribution methods needs to have 1d output. Defaults to None, which means that the
attribution method is not used.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>






              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/occlusion.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Occlusion</span><span class="p">(</span><span class="n">Explainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Occlusion explainer class for generating attributions using the Occlusion method.</span>
<span class="sd">    This attribution method perturbs the input by replacing the contiguous rectangular region</span>
<span class="sd">    with a given baseline and computing the difference in output.</span>
<span class="sd">    In our case, features are located in multiple regions, and attribution from different hyper-rectangles is averaged.</span>
<span class="sd">    The implementation of this method is also based on the [`captum` repository](https://captum.ai/api/occlusion.html).</span>
<span class="sd">    More details about this approach can be found in the [original paper](https://arxiv.org/abs/1311.2901)</span>

<span class="sd">    Attributes:</span>
<span class="sd">        _attribution_method (CaptumOcclusion): The Occlusion method from the `captum` library.</span>

<span class="sd">    Args:</span>
<span class="sd">        explainable_model (ExplainableModel | Explainer): The explainable model to be explained.</span>
<span class="sd">        postprocessing_segmentation_output (Callable[[torch.Tensor], torch.Tensor] | None):</span>
<span class="sd">            A segmentation postprocessing function for segmentation problem type. This is required for segmentation</span>
<span class="sd">            problem type as attribution methods needs to have 1d output. Defaults to None, which means that the</span>
<span class="sd">            attribution method is not used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">explainable_model</span><span class="p">:</span> <span class="n">ExplainableModel</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">explainable_model</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="o">=</span> <span class="n">CaptumOcclusion</span><span class="p">(</span><span class="n">explainable_model</span><span class="o">.</span><span class="n">forward_func</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_segmentation_mask</span><span class="p">(</span>
        <span class="n">input_shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">sliding_window_shapes</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">strides</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a binary segmentation mask based on sliding windows.</span>

<span class="sd">        Args:</span>
<span class="sd">            input_shape (Tuple[int, int, int]): Shape of the input tensor (e.g., (H, W, C))</span>
<span class="sd">            sliding_window_shapes (Tuple[int, int, int]): Shape of the sliding window (e.g., (h, w, c))</span>
<span class="sd">            strides (Tuple[int, int, int]): Strides for the sliding window (e.g., (s_h, s_w, s_c))</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Binary mask tensor with ones where windows are placed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize empty mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">input_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># Calculate number of windows in each dimension</span>
        <span class="n">windows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dim_size</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">stride</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">input_shape</span><span class="p">,</span> <span class="n">sliding_window_shapes</span><span class="p">,</span> <span class="n">strides</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">stride</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Stride cannot be zero.&quot;</span><span class="p">)</span>
            <span class="n">n_windows</span> <span class="o">=</span> <span class="n">dim_size</span> <span class="o">//</span> <span class="n">stride</span> <span class="k">if</span> <span class="p">(</span><span class="n">dim_size</span> <span class="o">-</span> <span class="n">window_size</span><span class="p">)</span> <span class="o">%</span> <span class="n">stride</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">dim_size</span> <span class="o">//</span> <span class="n">stride</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># 1 + (dim_size - window_size) // stride</span>
            <span class="n">windows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_windows</span><span class="p">)</span>

        <span class="c1"># Generate all possible indices using itertools.product</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">windows</span><span class="p">])):</span>
            <span class="c1"># Calculate start position for each dimension</span>
            <span class="n">starts</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="o">*</span> <span class="n">stride</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">stride</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">strides</span><span class="p">)]</span>

            <span class="c1"># Calculate end position for each dimension</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span> <span class="o">+</span> <span class="n">window</span> <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">window</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">sliding_window_shapes</span><span class="p">)]</span>

            <span class="c1"># Create slice objects for each dimension</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">ends</span><span class="p">))</span>

            <span class="c1"># Mark window position in mask</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sliding_window_shapes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">baseline</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">perturbations_per_eval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">show_progress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributes</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributes</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for generating attributions using the Occlusion method.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">                If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">                The output will be a list of HSIAttributes objects.</span>
<span class="sd">            target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">                methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">                must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">                image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">            sliding_window_shapes (int | tuple[int, int, int]):</span>
<span class="sd">                The shape of the sliding window. If an integer is provided, it will be used for all dimensions.</span>
<span class="sd">                Defaults to (1, 1, 1).</span>
<span class="sd">            strides (int | tuple[int, int, int], optional): The stride of the sliding window. Defaults to (1, 1, 1).</span>
<span class="sd">                Simply put, the stride is the number of pixels by which the sliding window is moved in each dimension.</span>
<span class="sd">            baseline (int | float | torch.Tensor | list[int | float | torch.Tensor], optional): Baselines define</span>
<span class="sd">                reference value which replaces each feature when occluded is computed and can be provided as:</span>
<span class="sd">                    - integer or float representing a constant value used as the baseline for all input pixels.</span>
<span class="sd">                    - tensor with the same shape as the input tensor, providing a baseline for each input pixel.</span>
<span class="sd">                        if the input is a list of HSI objects, the baseline can be a tensor with the same shape as</span>
<span class="sd">                        the input tensor for each HSI object.</span>
<span class="sd">                    - list of integers, floats or tensors with the same shape as the input tensor, providing a baseline</span>
<span class="sd">                        for each input pixel. If the input is a list of HSI objects, the baseline can be a list of</span>
<span class="sd">                        tensors with the same shape as the input tensor for each HSI object. Defaults to None.</span>
<span class="sd">            additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">                the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">                It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">                containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">                These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">                Note that attributions are not computed with respect to these arguments. Default: None</span>
<span class="sd">            perturbations_per_eval (int, optional): Allows multiple occlusions to be included in one batch</span>
<span class="sd">                (one call to forward_fn). By default, perturbations_per_eval is 1, so each occlusion is processed</span>
<span class="sd">                individually. Each forward pass will contain a maximum of perturbations_per_eval * #examples samples.</span>
<span class="sd">                For DataParallel models, each batch is split among the available devices, so evaluations on each</span>
<span class="sd">                available device contain at most (perturbations_per_eval * #examples) / num_devices samples. When</span>
<span class="sd">                working with multiple examples, the number of perturbations per evaluation should be set to at least</span>
<span class="sd">                the number of examples. Defaults to 1.</span>
<span class="sd">            show_progress (bool, optional): If True, displays a progress bar. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            HSIAttributes: The computed attributions for the input hyperspectral image(s). if a list of HSI objects</span>
<span class="sd">                is provided, the attributions are computed for each HSI object in the list.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If the explainer is not initialized.</span>
<span class="sd">            ValueError: If the sliding window shapes or strides are not a tuple of three integers.</span>
<span class="sd">            HSIAttributesError: If an error occurs during the generation of the attributions.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; occlusion = Occlusion(explainable_model)</span>
<span class="sd">            &gt;&gt;&gt; hsi = HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">            &gt;&gt;&gt; attributions = occlusion.attribute(hsi, baseline=0, sliding_window_shapes=(4, 3, 3), strides=(1, 1, 1))</span>
<span class="sd">            &gt;&gt;&gt; attributions = occlusion.attribute([hsi, hsi], baseline=0, sliding_window_shapes=(4, 3, 3), strides=(1, 2, 2))</span>
<span class="sd">            &gt;&gt;&gt; len(attributions)</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Occlusion explainer is not initialized, INITIALIZATION ERROR&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">hsi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">HSI</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All of the input hyperspectral images must be of type HSI&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">baseline</span> <span class="o">=</span> <span class="p">[</span><span class="n">baseline</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>

        <span class="n">baseline</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">validate_and_transform_baseline</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">hsi_image</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">baseline</span><span class="p">)</span>
            <span class="p">],</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">sliding_window_shapes</span> <span class="o">=</span> <span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">,</span> <span class="n">sliding_window_shapes</span><span class="p">,</span> <span class="n">sliding_window_shapes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strides</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="n">strides</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">strides</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">strides</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Strides must be a tuple of three integers&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sliding window shapes must be a tuple of three integers&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">strides</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="n">occlusion_attributions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
            <span class="n">input_tensor</span><span class="p">,</span>
            <span class="n">sliding_window_shapes</span><span class="o">=</span><span class="n">sliding_window_shapes</span><span class="p">,</span>
            <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">,</span>
            <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
            <span class="n">baselines</span><span class="o">=</span><span class="n">baseline</span><span class="p">,</span>
            <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span><span class="p">,</span>
            <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">perturbations_per_eval</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)),</span>
            <span class="n">show_progress</span><span class="o">=</span><span class="n">show_progress</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">HSIAttributes</span><span class="p">(</span><span class="n">hsi</span><span class="o">=</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">attributes</span><span class="o">=</span><span class="n">attribution</span><span class="p">,</span> <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">attribution</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">occlusion_attributions</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error in generating Occlusion attributions: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">return</span> <span class="n">attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">attributes</span>

    <span class="k">def</span> <span class="nf">get_spatial_attributes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sliding_window_shapes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">baseline</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">perturbations_per_eval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">show_progress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributesSpatial</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributesSpatial</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute spatial attributions for the input HSI using the Occlusion method. In this case, the sliding window</span>
<span class="sd">        is applied to the spatial dimensions only.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">                If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">                The output will be a list of HSIAttributes objects.</span>
<span class="sd">            target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">                methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">                must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">                image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">            sliding_window_shapes (int | tuple[int, int]): The shape of the sliding window for spatial dimensions.</span>
<span class="sd">                If an integer is provided, it will be used for both spatial dimensions. Defaults to (1, 1).</span>
<span class="sd">            strides (int | tuple[int, int], optional): The stride of the sliding window for spatial dimensions.</span>
<span class="sd">                Defaults to 1. Simply put, the stride is the number of pixels by which the sliding window is moved</span>
<span class="sd">                in each spatial dimension.</span>
<span class="sd">            baseline (int | float | torch.Tensor | list[int | float | torch.Tensor], optional): Baselines define</span>
<span class="sd">                reference value which replaces each feature when occluded is computed and can be provided as:</span>
<span class="sd">                    - integer or float representing a constant value used as the baseline for all input pixels.</span>
<span class="sd">                    - tensor with the same shape as the input tensor, providing a baseline for each input pixel.</span>
<span class="sd">                        if the input is a list of HSI objects, the baseline can be a tensor with the same shape as</span>
<span class="sd">                        the input tensor for each HSI object.</span>
<span class="sd">                    - list of integers, floats or tensors with the same shape as the input tensor, providing a baseline</span>
<span class="sd">                      for each input pixel. If the input is a list of HSI objects, the baseline can be a list of</span>
<span class="sd">                      tensors with the same shape as the input tensor for each HSI object. Defaults to None.</span>
<span class="sd">            additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">                the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">                It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">                containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">                These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">                Note that attributions are not computed with respect to these arguments. Default: None</span>
<span class="sd">            perturbations_per_eval (int, optional): Allows multiple occlusions to be included in one batch</span>
<span class="sd">                (one call to forward_fn). By default, perturbations_per_eval is 1, so each occlusion is processed</span>
<span class="sd">                individually. Each forward pass will contain a maximum of perturbations_per_eval * #examples samples.</span>
<span class="sd">                For DataParallel models, each batch is split among the available devices, so evaluations on each</span>
<span class="sd">                available device contain at most (perturbations_per_eval * #examples) / num_devices samples. When</span>
<span class="sd">                working with multiple examples, the number of perturbations per evaluation should be set to at least</span>
<span class="sd">                the number of examples. Defaults to 1.</span>
<span class="sd">            show_progress (bool, optional): If True, displays a progress bar. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            HSIAttributesSpatial | list[HSIAttributesSpatial]: The computed attributions for the input hyperspectral image(s).</span>
<span class="sd">                if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If the explainer is not initialized.</span>
<span class="sd">            ValueError: If the sliding window shapes or strides are not a tuple of two integers.</span>
<span class="sd">            HSIAttributesError: If an error occurs during the generation of the attributions</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; occlusion = Occlusion(explainable_model)</span>
<span class="sd">            &gt;&gt;&gt; hsi = HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">            &gt;&gt;&gt; attributions = occlusion.get_spatial_attributes(hsi, baseline=0, sliding_window_shapes=(3, 3), strides=(1, 1))</span>
<span class="sd">            &gt;&gt;&gt; attributions = occlusion.get_spatial_attributes([hsi, hsi], baseline=0, sliding_window_shapes=(3, 3), strides=(2, 2))</span>
<span class="sd">            &gt;&gt;&gt; len(attributions)</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Occlusion explainer is not initialized, INITIALIZATION ERROR&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">hsi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">HSI</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All of the input hyperspectral images must be of type HSI&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">baseline</span> <span class="o">=</span> <span class="p">[</span><span class="n">baseline</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>

        <span class="n">baseline</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">validate_and_transform_baseline</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">hsi_image</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">baseline</span><span class="p">)</span>
            <span class="p">],</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">sliding_window_shapes</span> <span class="o">=</span> <span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">,</span> <span class="n">sliding_window_shapes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strides</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="n">strides</span><span class="p">,</span> <span class="n">strides</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">strides</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Strides must be a tuple of two integers&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sliding window shapes must be a tuple of two integers&quot;</span><span class="p">)</span>

        <span class="n">list_sliding_window_shapes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">)</span>
        <span class="n">list_strides</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">strides</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">list_sliding_window_shapes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">])</span>
            <span class="n">list_strides</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">list_sliding_window_shapes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">])</span>
            <span class="n">list_strides</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">])</span>
        <span class="n">sliding_window_shapes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">list_sliding_window_shapes</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">list_strides</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">strides</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="n">segment_mask</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_segmentation_mask</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">sliding_window_shapes</span><span class="p">,</span> <span class="n">strides</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span>
        <span class="p">]</span>

        <span class="n">occlusion_attributions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
            <span class="n">input_tensor</span><span class="p">,</span>
            <span class="n">sliding_window_shapes</span><span class="o">=</span><span class="n">sliding_window_shapes</span><span class="p">,</span>
            <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">,</span>
            <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
            <span class="n">baselines</span><span class="o">=</span><span class="n">baseline</span><span class="p">,</span>
            <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span><span class="p">,</span>
            <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">perturbations_per_eval</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)),</span>
            <span class="n">show_progress</span><span class="o">=</span><span class="n">show_progress</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">spatial_attributes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">HSIAttributesSpatial</span><span class="p">(</span>
                    <span class="n">hsi</span><span class="o">=</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">attributes</span><span class="o">=</span><span class="n">attribution</span><span class="p">,</span> <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">attribution</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">occlusion_attributions</span><span class="p">,</span> <span class="n">segment_mask</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error in generating Occlusion attributions: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">return</span> <span class="n">spatial_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatial_attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">spatial_attributes</span>

    <span class="k">def</span> <span class="nf">get_spectral_attributes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sliding_window_shapes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">baseline</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">perturbations_per_eval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">show_progress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributesSpectral</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributesSpectral</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute spectral attributions for the input HSI using the Occlusion method. In this case, the sliding window</span>
<span class="sd">        is applied to the spectral dimension only.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">                If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">                The output will be a list of HSIAttributes objects.</span>
<span class="sd">            target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">                methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">                must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">                image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">            sliding_window_shapes (int | tuple[int]): The size of the sliding window for the spectral dimension.</span>
<span class="sd">                Defaults to 1.</span>
<span class="sd">            strides (int | tuple[int], optional): The stride of the sliding window for the spectral dimension.</span>
<span class="sd">                Defaults to 1. Simply put, the stride is the number of pixels by which the sliding window is moved</span>
<span class="sd">                in spectral dimension.</span>
<span class="sd">            baseline (int | float | torch.Tensor | list[int | float | torch.Tensor], optional): Baselines define</span>
<span class="sd">                reference value which replaces each feature when occluded is computed and can be provided as:</span>
<span class="sd">                    - integer or float representing a constant value used as the baseline for all input pixels.</span>
<span class="sd">                    - tensor with the same shape as the input tensor, providing a baseline for each input pixel.</span>
<span class="sd">                        if the input is a list of HSI objects, the baseline can be a tensor with the same shape as</span>
<span class="sd">                        the input tensor for each HSI object.</span>
<span class="sd">                    - list of integers, floats or tensors with the same shape as the input tensor, providing a baseline</span>
<span class="sd">                      for each input pixel. If the input is a list of HSI objects, the baseline can be a list of</span>
<span class="sd">                      tensors with the same shape as the input tensor for each HSI object. Defaults to None.</span>
<span class="sd">            additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">                the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">                It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">                containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">                These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">                Note that attributions are not computed with respect to these arguments. Default: None</span>
<span class="sd">            perturbations_per_eval (int, optional): Allows multiple occlusions to be included in one batch</span>
<span class="sd">                (one call to forward_fn). By default, perturbations_per_eval is 1, so each occlusion is processed</span>
<span class="sd">                individually. Each forward pass will contain a maximum of perturbations_per_eval * #examples samples.</span>
<span class="sd">                For DataParallel models, each batch is split among the available devices, so evaluations on each</span>
<span class="sd">                available device contain at most (perturbations_per_eval * #examples) / num_devices samples. When</span>
<span class="sd">                working with multiple examples, the number of perturbations per evaluation should be set to at least</span>
<span class="sd">                the number of examples. Defaults to 1.</span>
<span class="sd">            show_progress (bool, optional): If True, displays a progress bar. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            HSIAttributesSpectral | list[HSIAttributesSpectral]: The computed attributions for the input hyperspectral</span>
<span class="sd">                image(s). if a list of HSI objects is provided, the attributions are computed for each HSI object in</span>
<span class="sd">                the list.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If the explainer is not initialized.</span>
<span class="sd">            ValueError: If the sliding window shapes or strides are not a tuple of a single integer.</span>
<span class="sd">            TypeError: If the sliding window shapes or strides are not a single integer.</span>
<span class="sd">            HSIAttributesError: If an error occurs during the generation of the attributions</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; occlusion = Occlusion(explainable_model)</span>
<span class="sd">            &gt;&gt;&gt; hsi = HSI(image=torch.ones((10, 240, 240)), wavelengths=torch.arange(10))</span>
<span class="sd">            &gt;&gt;&gt; attributions = occlusion.get_spectral_attributes(hsi, baseline=0, sliding_window_shapes=3, strides=1)</span>
<span class="sd">            &gt;&gt;&gt; attributions = occlusion.get_spectral_attributes([hsi, hsi], baseline=0, sliding_window_shapes=3, strides=2)</span>
<span class="sd">            &gt;&gt;&gt; len(attributions)</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Occlusion explainer is not initialized, INITIALIZATION ERROR&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">hsi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">HSI</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All of the input hyperspectral images must be of type HSI&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">baseline</span> <span class="o">=</span> <span class="p">[</span><span class="n">baseline</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>

        <span class="n">baseline</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">validate_and_transform_baseline</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">hsi_image</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">baseline</span><span class="p">)</span>
            <span class="p">],</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sliding window shapes must be a single integer or a tuple of a single integer&quot;</span><span class="p">)</span>
            <span class="n">sliding_window_shapes</span> <span class="o">=</span> <span class="n">sliding_window_shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strides</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">strides</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Strides must be a single integer or a tuple of a single integer&quot;</span><span class="p">)</span>
            <span class="n">strides</span> <span class="o">=</span> <span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Sliding window shapes must be a single integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strides</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Strides must be a single integer&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">full_sliding_window_shapes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">full_sliding_window_shapes</span><span class="p">[</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">sliding_window_shapes</span>
            <span class="n">full_strides</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">full_strides</span><span class="p">[</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">strides</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">full_sliding_window_shapes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">full_sliding_window_shapes</span><span class="p">[</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">sliding_window_shapes</span>
            <span class="n">full_strides</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">full_strides</span><span class="p">[</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">strides</span>

        <span class="n">sliding_window_shapes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">full_sliding_window_shapes</span><span class="p">)</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">full_strides</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">strides</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="n">band_mask</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_segmentation_mask</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">sliding_window_shapes</span><span class="p">,</span> <span class="n">strides</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span>
        <span class="p">]</span>
        <span class="n">band_names</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">ui</span><span class="o">.</span><span class="n">item</span><span class="p">()):</span> <span class="n">ui</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">ui</span> <span class="ow">in</span> <span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">band_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])}</span>

        <span class="n">occlusion_attributions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
            <span class="n">input_tensor</span><span class="p">,</span>
            <span class="n">sliding_window_shapes</span><span class="o">=</span><span class="n">sliding_window_shapes</span><span class="p">,</span>
            <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">,</span>
            <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
            <span class="n">baselines</span><span class="o">=</span><span class="n">baseline</span><span class="p">,</span>
            <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span><span class="p">,</span>
            <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">perturbations_per_eval</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)),</span>
            <span class="n">show_progress</span><span class="o">=</span><span class="n">show_progress</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">spectral_attributes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">HSIAttributesSpectral</span><span class="p">(</span>
                    <span class="n">hsi</span><span class="o">=</span><span class="n">hsi_image</span><span class="p">,</span>
                    <span class="n">attributes</span><span class="o">=</span><span class="n">attribution</span><span class="p">,</span>
                    <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span>
                    <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                    <span class="n">band_names</span><span class="o">=</span><span class="n">band_names</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">attribution</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">occlusion_attributions</span><span class="p">,</span> <span class="n">band_mask</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error in generating Occlusion attributions: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">return</span> <span class="n">spectral_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">spectral_attributes</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.occlusion.Occlusion.attribute" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">attribute</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sliding_window_shapes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">baseline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">show_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Method for generating attributions using the Occlusion method.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>hsi</code>
            </td>
            <td>
                  <code>list[<span title="meteors.HSI">HSI</span>] | <span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Input hyperspectral image(s) for which the attributions are to be computed.
If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.
The output will be a list of HSIAttributes objects.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>target</code>
            </td>
            <td>
                  <code>list[int] | int | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>target class index for computing the attributions. If None,
methods assume that the output has only one class. If the output has multiple classes, the target index
must be provided. For multiple input images, a list of target indices can be provided, one for each
image or single target value will be used for all images. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>sliding_window_shapes</code>
            </td>
            <td>
                  <code>int | tuple[int, int, int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The shape of the sliding window. If an integer is provided, it will be used for all dimensions.
Defaults to (1, 1, 1).</p>
              </div>
            </td>
            <td>
                  <code>(1, 1, 1)</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>strides</code>
            </td>
            <td>
                  <code>int | tuple[int, int, int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The stride of the sliding window. Defaults to (1, 1, 1).
Simply put, the stride is the number of pixels by which the sliding window is moved in each dimension.</p>
              </div>
            </td>
            <td>
                  <code>(1, 1, 1)</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>baseline</code>
            </td>
            <td>
                  <code>int | float | <span title="torch.Tensor">Tensor</span> | list[int | float | <span title="torch.Tensor">Tensor</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Baselines define
reference value which replaces each feature when occluded is computed and can be provided as:
    - integer or float representing a constant value used as the baseline for all input pixels.
    - tensor with the same shape as the input tensor, providing a baseline for each input pixel.
        if the input is a list of HSI objects, the baseline can be a tensor with the same shape as
        the input tensor for each HSI object.
    - list of integers, floats or tensors with the same shape as the input tensor, providing a baseline
        for each input pixel. If the input is a list of HSI objects, the baseline can be a list of
        tensors with the same shape as the input tensor for each HSI object. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>additional_forward_args</code>
            </td>
            <td>
                  <code><span title="typing.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the forward function requires additional arguments other than
the inputs for which attributions should not be computed, this argument can be provided.
It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple
containing multiple additional arguments including tensors or any arbitrary python types.
These arguments are provided to forward_func in order following the arguments in inputs.
Note that attributions are not computed with respect to these arguments. Default: None</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>perturbations_per_eval</code>
            </td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Allows multiple occlusions to be included in one batch
(one call to forward_fn). By default, perturbations_per_eval is 1, so each occlusion is processed
individually. Each forward pass will contain a maximum of perturbations_per_eval * #examples samples.
For DataParallel models, each batch is split among the available devices, so evaluations on each
available device contain at most (perturbations_per_eval * #examples) / num_devices samples. When
working with multiple examples, the number of perturbations per evaluation should be set to at least
the number of examples. Defaults to 1.</p>
              </div>
            </td>
            <td>
                  <code>1</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>show_progress</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, displays a progress bar. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>HSIAttributes</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributes" href="#src.meteors.attr.attributes.HSIAttributes">HSIAttributes</a> | list[<a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributes" href="#src.meteors.attr.attributes.HSIAttributes">HSIAttributes</a>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The computed attributions for the input hyperspectral image(s). if a list of HSI objects
is provided, the attributions are computed for each HSI object in the list.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>RuntimeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the explainer is not initialized.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the sliding window shapes or strides are not a tuple of three integers.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="meteors.exceptions.HSIAttributesError">HSIAttributesError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If an error occurs during the generation of the attributions.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="example" open>
  <summary>Example</summary>
  <blockquote>
<blockquote>
<blockquote>
<p>occlusion = Occlusion(explainable_model)
hsi = HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])
attributions = occlusion.attribute(hsi, baseline=0, sliding_window_shapes=(4, 3, 3), strides=(1, 1, 1))
attributions = occlusion.attribute([hsi, hsi], baseline=0, sliding_window_shapes=(4, 3, 3), strides=(1, 2, 2))
len(attributions)
2</p>
</blockquote>
</blockquote>
</blockquote>
</details>
            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/occlusion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sliding_window_shapes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">baseline</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">perturbations_per_eval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">show_progress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributes</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributes</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method for generating attributions using the Occlusion method.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">            If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">            The output will be a list of HSIAttributes objects.</span>
<span class="sd">        target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">            methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">            must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">            image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">        sliding_window_shapes (int | tuple[int, int, int]):</span>
<span class="sd">            The shape of the sliding window. If an integer is provided, it will be used for all dimensions.</span>
<span class="sd">            Defaults to (1, 1, 1).</span>
<span class="sd">        strides (int | tuple[int, int, int], optional): The stride of the sliding window. Defaults to (1, 1, 1).</span>
<span class="sd">            Simply put, the stride is the number of pixels by which the sliding window is moved in each dimension.</span>
<span class="sd">        baseline (int | float | torch.Tensor | list[int | float | torch.Tensor], optional): Baselines define</span>
<span class="sd">            reference value which replaces each feature when occluded is computed and can be provided as:</span>
<span class="sd">                - integer or float representing a constant value used as the baseline for all input pixels.</span>
<span class="sd">                - tensor with the same shape as the input tensor, providing a baseline for each input pixel.</span>
<span class="sd">                    if the input is a list of HSI objects, the baseline can be a tensor with the same shape as</span>
<span class="sd">                    the input tensor for each HSI object.</span>
<span class="sd">                - list of integers, floats or tensors with the same shape as the input tensor, providing a baseline</span>
<span class="sd">                    for each input pixel. If the input is a list of HSI objects, the baseline can be a list of</span>
<span class="sd">                    tensors with the same shape as the input tensor for each HSI object. Defaults to None.</span>
<span class="sd">        additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">            the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">            It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">            containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">            These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">            Note that attributions are not computed with respect to these arguments. Default: None</span>
<span class="sd">        perturbations_per_eval (int, optional): Allows multiple occlusions to be included in one batch</span>
<span class="sd">            (one call to forward_fn). By default, perturbations_per_eval is 1, so each occlusion is processed</span>
<span class="sd">            individually. Each forward pass will contain a maximum of perturbations_per_eval * #examples samples.</span>
<span class="sd">            For DataParallel models, each batch is split among the available devices, so evaluations on each</span>
<span class="sd">            available device contain at most (perturbations_per_eval * #examples) / num_devices samples. When</span>
<span class="sd">            working with multiple examples, the number of perturbations per evaluation should be set to at least</span>
<span class="sd">            the number of examples. Defaults to 1.</span>
<span class="sd">        show_progress (bool, optional): If True, displays a progress bar. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        HSIAttributes: The computed attributions for the input hyperspectral image(s). if a list of HSI objects</span>
<span class="sd">            is provided, the attributions are computed for each HSI object in the list.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If the explainer is not initialized.</span>
<span class="sd">        ValueError: If the sliding window shapes or strides are not a tuple of three integers.</span>
<span class="sd">        HSIAttributesError: If an error occurs during the generation of the attributions.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; occlusion = Occlusion(explainable_model)</span>
<span class="sd">        &gt;&gt;&gt; hsi = HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">        &gt;&gt;&gt; attributions = occlusion.attribute(hsi, baseline=0, sliding_window_shapes=(4, 3, 3), strides=(1, 1, 1))</span>
<span class="sd">        &gt;&gt;&gt; attributions = occlusion.attribute([hsi, hsi], baseline=0, sliding_window_shapes=(4, 3, 3), strides=(1, 2, 2))</span>
<span class="sd">        &gt;&gt;&gt; len(attributions)</span>
<span class="sd">        2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Occlusion explainer is not initialized, INITIALIZATION ERROR&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">HSI</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All of the input hyperspectral images must be of type HSI&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">baseline</span> <span class="o">=</span> <span class="p">[</span><span class="n">baseline</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>

    <span class="n">baseline</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">validate_and_transform_baseline</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">hsi_image</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">baseline</span><span class="p">)</span>
        <span class="p">],</span>
        <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
        <span class="p">[</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">sliding_window_shapes</span> <span class="o">=</span> <span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">,</span> <span class="n">sliding_window_shapes</span><span class="p">,</span> <span class="n">sliding_window_shapes</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strides</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="n">strides</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">strides</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">strides</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Strides must be a tuple of three integers&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sliding window shapes must be a tuple of three integers&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">strides</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="n">occlusion_attributions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
        <span class="n">input_tensor</span><span class="p">,</span>
        <span class="n">sliding_window_shapes</span><span class="o">=</span><span class="n">sliding_window_shapes</span><span class="p">,</span>
        <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">,</span>
        <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
        <span class="n">baselines</span><span class="o">=</span><span class="n">baseline</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span><span class="p">,</span>
        <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">perturbations_per_eval</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)),</span>
        <span class="n">show_progress</span><span class="o">=</span><span class="n">show_progress</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">HSIAttributes</span><span class="p">(</span><span class="n">hsi</span><span class="o">=</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">attributes</span><span class="o">=</span><span class="n">attribution</span><span class="p">,</span> <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">attribution</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">occlusion_attributions</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error in generating Occlusion attributions: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">return</span> <span class="n">attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">attributes</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.occlusion.Occlusion.get_spatial_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_spatial_attributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sliding_window_shapes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">strides</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">show_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Compute spatial attributions for the input HSI using the Occlusion method. In this case, the sliding window
is applied to the spatial dimensions only.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>hsi</code>
            </td>
            <td>
                  <code>list[<span title="meteors.HSI">HSI</span>] | <span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Input hyperspectral image(s) for which the attributions are to be computed.
If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.
The output will be a list of HSIAttributes objects.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>target</code>
            </td>
            <td>
                  <code>list[int] | int | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>target class index for computing the attributions. If None,
methods assume that the output has only one class. If the output has multiple classes, the target index
must be provided. For multiple input images, a list of target indices can be provided, one for each
image or single target value will be used for all images. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>sliding_window_shapes</code>
            </td>
            <td>
                  <code>int | tuple[int, int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The shape of the sliding window for spatial dimensions.
If an integer is provided, it will be used for both spatial dimensions. Defaults to (1, 1).</p>
              </div>
            </td>
            <td>
                  <code>(1, 1)</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>strides</code>
            </td>
            <td>
                  <code>int | tuple[int, int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The stride of the sliding window for spatial dimensions.
Defaults to 1. Simply put, the stride is the number of pixels by which the sliding window is moved
in each spatial dimension.</p>
              </div>
            </td>
            <td>
                  <code>1</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>baseline</code>
            </td>
            <td>
                  <code>int | float | <span title="torch.Tensor">Tensor</span> | list[int | float | <span title="torch.Tensor">Tensor</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Baselines define
reference value which replaces each feature when occluded is computed and can be provided as:
    - integer or float representing a constant value used as the baseline for all input pixels.
    - tensor with the same shape as the input tensor, providing a baseline for each input pixel.
        if the input is a list of HSI objects, the baseline can be a tensor with the same shape as
        the input tensor for each HSI object.
    - list of integers, floats or tensors with the same shape as the input tensor, providing a baseline
      for each input pixel. If the input is a list of HSI objects, the baseline can be a list of
      tensors with the same shape as the input tensor for each HSI object. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>additional_forward_args</code>
            </td>
            <td>
                  <code><span title="typing.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the forward function requires additional arguments other than
the inputs for which attributions should not be computed, this argument can be provided.
It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple
containing multiple additional arguments including tensors or any arbitrary python types.
These arguments are provided to forward_func in order following the arguments in inputs.
Note that attributions are not computed with respect to these arguments. Default: None</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>perturbations_per_eval</code>
            </td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Allows multiple occlusions to be included in one batch
(one call to forward_fn). By default, perturbations_per_eval is 1, so each occlusion is processed
individually. Each forward pass will contain a maximum of perturbations_per_eval * #examples samples.
For DataParallel models, each batch is split among the available devices, so evaluations on each
available device contain at most (perturbations_per_eval * #examples) / num_devices samples. When
working with multiple examples, the number of perturbations per evaluation should be set to at least
the number of examples. Defaults to 1.</p>
              </div>
            </td>
            <td>
                  <code>1</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>show_progress</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, displays a progress bar. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributesSpatial" href="#src.meteors.attr.attributes.HSIAttributesSpatial">HSIAttributesSpatial</a> | list[<a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributesSpatial" href="#src.meteors.attr.attributes.HSIAttributesSpatial">HSIAttributesSpatial</a>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>HSIAttributesSpatial | list[HSIAttributesSpatial]: The computed attributions for the input hyperspectral image(s).
if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>RuntimeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the explainer is not initialized.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the sliding window shapes or strides are not a tuple of two integers.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="meteors.exceptions.HSIAttributesError">HSIAttributesError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If an error occurs during the generation of the attributions</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="example" open>
  <summary>Example</summary>
  <blockquote>
<blockquote>
<blockquote>
<p>occlusion = Occlusion(explainable_model)
hsi = HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])
attributions = occlusion.get_spatial_attributes(hsi, baseline=0, sliding_window_shapes=(3, 3), strides=(1, 1))
attributions = occlusion.get_spatial_attributes([hsi, hsi], baseline=0, sliding_window_shapes=(3, 3), strides=(2, 2))
len(attributions)
2</p>
</blockquote>
</blockquote>
</blockquote>
</details>
            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/occlusion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_spatial_attributes</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sliding_window_shapes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">baseline</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">perturbations_per_eval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">show_progress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributesSpatial</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributesSpatial</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute spatial attributions for the input HSI using the Occlusion method. In this case, the sliding window</span>
<span class="sd">    is applied to the spatial dimensions only.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">            If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">            The output will be a list of HSIAttributes objects.</span>
<span class="sd">        target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">            methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">            must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">            image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">        sliding_window_shapes (int | tuple[int, int]): The shape of the sliding window for spatial dimensions.</span>
<span class="sd">            If an integer is provided, it will be used for both spatial dimensions. Defaults to (1, 1).</span>
<span class="sd">        strides (int | tuple[int, int], optional): The stride of the sliding window for spatial dimensions.</span>
<span class="sd">            Defaults to 1. Simply put, the stride is the number of pixels by which the sliding window is moved</span>
<span class="sd">            in each spatial dimension.</span>
<span class="sd">        baseline (int | float | torch.Tensor | list[int | float | torch.Tensor], optional): Baselines define</span>
<span class="sd">            reference value which replaces each feature when occluded is computed and can be provided as:</span>
<span class="sd">                - integer or float representing a constant value used as the baseline for all input pixels.</span>
<span class="sd">                - tensor with the same shape as the input tensor, providing a baseline for each input pixel.</span>
<span class="sd">                    if the input is a list of HSI objects, the baseline can be a tensor with the same shape as</span>
<span class="sd">                    the input tensor for each HSI object.</span>
<span class="sd">                - list of integers, floats or tensors with the same shape as the input tensor, providing a baseline</span>
<span class="sd">                  for each input pixel. If the input is a list of HSI objects, the baseline can be a list of</span>
<span class="sd">                  tensors with the same shape as the input tensor for each HSI object. Defaults to None.</span>
<span class="sd">        additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">            the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">            It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">            containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">            These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">            Note that attributions are not computed with respect to these arguments. Default: None</span>
<span class="sd">        perturbations_per_eval (int, optional): Allows multiple occlusions to be included in one batch</span>
<span class="sd">            (one call to forward_fn). By default, perturbations_per_eval is 1, so each occlusion is processed</span>
<span class="sd">            individually. Each forward pass will contain a maximum of perturbations_per_eval * #examples samples.</span>
<span class="sd">            For DataParallel models, each batch is split among the available devices, so evaluations on each</span>
<span class="sd">            available device contain at most (perturbations_per_eval * #examples) / num_devices samples. When</span>
<span class="sd">            working with multiple examples, the number of perturbations per evaluation should be set to at least</span>
<span class="sd">            the number of examples. Defaults to 1.</span>
<span class="sd">        show_progress (bool, optional): If True, displays a progress bar. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        HSIAttributesSpatial | list[HSIAttributesSpatial]: The computed attributions for the input hyperspectral image(s).</span>
<span class="sd">            if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If the explainer is not initialized.</span>
<span class="sd">        ValueError: If the sliding window shapes or strides are not a tuple of two integers.</span>
<span class="sd">        HSIAttributesError: If an error occurs during the generation of the attributions</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; occlusion = Occlusion(explainable_model)</span>
<span class="sd">        &gt;&gt;&gt; hsi = HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">        &gt;&gt;&gt; attributions = occlusion.get_spatial_attributes(hsi, baseline=0, sliding_window_shapes=(3, 3), strides=(1, 1))</span>
<span class="sd">        &gt;&gt;&gt; attributions = occlusion.get_spatial_attributes([hsi, hsi], baseline=0, sliding_window_shapes=(3, 3), strides=(2, 2))</span>
<span class="sd">        &gt;&gt;&gt; len(attributions)</span>
<span class="sd">        2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Occlusion explainer is not initialized, INITIALIZATION ERROR&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">HSI</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All of the input hyperspectral images must be of type HSI&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">baseline</span> <span class="o">=</span> <span class="p">[</span><span class="n">baseline</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>

    <span class="n">baseline</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">validate_and_transform_baseline</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">hsi_image</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">baseline</span><span class="p">)</span>
        <span class="p">],</span>
        <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
        <span class="p">[</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">sliding_window_shapes</span> <span class="o">=</span> <span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">,</span> <span class="n">sliding_window_shapes</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strides</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="n">strides</span><span class="p">,</span> <span class="n">strides</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">strides</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Strides must be a tuple of two integers&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sliding window shapes must be a tuple of two integers&quot;</span><span class="p">)</span>

    <span class="n">list_sliding_window_shapes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">)</span>
    <span class="n">list_strides</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">strides</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">list_sliding_window_shapes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">])</span>
        <span class="n">list_strides</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">list_sliding_window_shapes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">])</span>
        <span class="n">list_strides</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">,</span> <span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">])</span>
    <span class="n">sliding_window_shapes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">list_sliding_window_shapes</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
    <span class="n">strides</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">list_strides</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">strides</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="n">segment_mask</span> <span class="o">=</span> <span class="p">[</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_segmentation_mask</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">sliding_window_shapes</span><span class="p">,</span> <span class="n">strides</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span>
    <span class="p">]</span>

    <span class="n">occlusion_attributions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
        <span class="n">input_tensor</span><span class="p">,</span>
        <span class="n">sliding_window_shapes</span><span class="o">=</span><span class="n">sliding_window_shapes</span><span class="p">,</span>
        <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">,</span>
        <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
        <span class="n">baselines</span><span class="o">=</span><span class="n">baseline</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span><span class="p">,</span>
        <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">perturbations_per_eval</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)),</span>
        <span class="n">show_progress</span><span class="o">=</span><span class="n">show_progress</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">spatial_attributes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">HSIAttributesSpatial</span><span class="p">(</span>
                <span class="n">hsi</span><span class="o">=</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">attributes</span><span class="o">=</span><span class="n">attribution</span><span class="p">,</span> <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">attribution</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">occlusion_attributions</span><span class="p">,</span> <span class="n">segment_mask</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error in generating Occlusion attributions: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">return</span> <span class="n">spatial_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatial_attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">spatial_attributes</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.occlusion.Occlusion.get_spectral_attributes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_spectral_attributes</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sliding_window_shapes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">show_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Compute spectral attributions for the input HSI using the Occlusion method. In this case, the sliding window
is applied to the spectral dimension only.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>hsi</code>
            </td>
            <td>
                  <code>list[<span title="meteors.HSI">HSI</span>] | <span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Input hyperspectral image(s) for which the attributions are to be computed.
If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.
The output will be a list of HSIAttributes objects.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>target</code>
            </td>
            <td>
                  <code>list[int] | int | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>target class index for computing the attributions. If None,
methods assume that the output has only one class. If the output has multiple classes, the target index
must be provided. For multiple input images, a list of target indices can be provided, one for each
image or single target value will be used for all images. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>sliding_window_shapes</code>
            </td>
            <td>
                  <code>int | tuple[int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The size of the sliding window for the spectral dimension.
Defaults to 1.</p>
              </div>
            </td>
            <td>
                  <code>1</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>strides</code>
            </td>
            <td>
                  <code>int | tuple[int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The stride of the sliding window for the spectral dimension.
Defaults to 1. Simply put, the stride is the number of pixels by which the sliding window is moved
in spectral dimension.</p>
              </div>
            </td>
            <td>
                  <code>1</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>baseline</code>
            </td>
            <td>
                  <code>int | float | <span title="torch.Tensor">Tensor</span> | list[int | float | <span title="torch.Tensor">Tensor</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Baselines define
reference value which replaces each feature when occluded is computed and can be provided as:
    - integer or float representing a constant value used as the baseline for all input pixels.
    - tensor with the same shape as the input tensor, providing a baseline for each input pixel.
        if the input is a list of HSI objects, the baseline can be a tensor with the same shape as
        the input tensor for each HSI object.
    - list of integers, floats or tensors with the same shape as the input tensor, providing a baseline
      for each input pixel. If the input is a list of HSI objects, the baseline can be a list of
      tensors with the same shape as the input tensor for each HSI object. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>additional_forward_args</code>
            </td>
            <td>
                  <code><span title="typing.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the forward function requires additional arguments other than
the inputs for which attributions should not be computed, this argument can be provided.
It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple
containing multiple additional arguments including tensors or any arbitrary python types.
These arguments are provided to forward_func in order following the arguments in inputs.
Note that attributions are not computed with respect to these arguments. Default: None</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>perturbations_per_eval</code>
            </td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Allows multiple occlusions to be included in one batch
(one call to forward_fn). By default, perturbations_per_eval is 1, so each occlusion is processed
individually. Each forward pass will contain a maximum of perturbations_per_eval * #examples samples.
For DataParallel models, each batch is split among the available devices, so evaluations on each
available device contain at most (perturbations_per_eval * #examples) / num_devices samples. When
working with multiple examples, the number of perturbations per evaluation should be set to at least
the number of examples. Defaults to 1.</p>
              </div>
            </td>
            <td>
                  <code>1</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>show_progress</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, displays a progress bar. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributesSpectral" href="#src.meteors.attr.attributes.HSIAttributesSpectral">HSIAttributesSpectral</a> | list[<a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributesSpectral" href="#src.meteors.attr.attributes.HSIAttributesSpectral">HSIAttributesSpectral</a>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>HSIAttributesSpectral | list[HSIAttributesSpectral]: The computed attributions for the input hyperspectral
image(s). if a list of HSI objects is provided, the attributions are computed for each HSI object in
the list.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>RuntimeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the explainer is not initialized.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>ValueError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the sliding window shapes or strides are not a tuple of a single integer.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code>TypeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the sliding window shapes or strides are not a single integer.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="meteors.exceptions.HSIAttributesError">HSIAttributesError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If an error occurs during the generation of the attributions</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="example" open>
  <summary>Example</summary>
  <blockquote>
<blockquote>
<blockquote>
<p>occlusion = Occlusion(explainable_model)
hsi = HSI(image=torch.ones((10, 240, 240)), wavelengths=torch.arange(10))
attributions = occlusion.get_spectral_attributes(hsi, baseline=0, sliding_window_shapes=3, strides=1)
attributions = occlusion.get_spectral_attributes([hsi, hsi], baseline=0, sliding_window_shapes=3, strides=2)
len(attributions)
2</p>
</blockquote>
</blockquote>
</blockquote>
</details>
            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/occlusion.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_spectral_attributes</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sliding_window_shapes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">baseline</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">perturbations_per_eval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">show_progress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributesSpectral</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributesSpectral</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute spectral attributions for the input HSI using the Occlusion method. In this case, the sliding window</span>
<span class="sd">    is applied to the spectral dimension only.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">            If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">            The output will be a list of HSIAttributes objects.</span>
<span class="sd">        target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">            methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">            must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">            image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">        sliding_window_shapes (int | tuple[int]): The size of the sliding window for the spectral dimension.</span>
<span class="sd">            Defaults to 1.</span>
<span class="sd">        strides (int | tuple[int], optional): The stride of the sliding window for the spectral dimension.</span>
<span class="sd">            Defaults to 1. Simply put, the stride is the number of pixels by which the sliding window is moved</span>
<span class="sd">            in spectral dimension.</span>
<span class="sd">        baseline (int | float | torch.Tensor | list[int | float | torch.Tensor], optional): Baselines define</span>
<span class="sd">            reference value which replaces each feature when occluded is computed and can be provided as:</span>
<span class="sd">                - integer or float representing a constant value used as the baseline for all input pixels.</span>
<span class="sd">                - tensor with the same shape as the input tensor, providing a baseline for each input pixel.</span>
<span class="sd">                    if the input is a list of HSI objects, the baseline can be a tensor with the same shape as</span>
<span class="sd">                    the input tensor for each HSI object.</span>
<span class="sd">                - list of integers, floats or tensors with the same shape as the input tensor, providing a baseline</span>
<span class="sd">                  for each input pixel. If the input is a list of HSI objects, the baseline can be a list of</span>
<span class="sd">                  tensors with the same shape as the input tensor for each HSI object. Defaults to None.</span>
<span class="sd">        additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">            the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">            It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">            containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">            These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">            Note that attributions are not computed with respect to these arguments. Default: None</span>
<span class="sd">        perturbations_per_eval (int, optional): Allows multiple occlusions to be included in one batch</span>
<span class="sd">            (one call to forward_fn). By default, perturbations_per_eval is 1, so each occlusion is processed</span>
<span class="sd">            individually. Each forward pass will contain a maximum of perturbations_per_eval * #examples samples.</span>
<span class="sd">            For DataParallel models, each batch is split among the available devices, so evaluations on each</span>
<span class="sd">            available device contain at most (perturbations_per_eval * #examples) / num_devices samples. When</span>
<span class="sd">            working with multiple examples, the number of perturbations per evaluation should be set to at least</span>
<span class="sd">            the number of examples. Defaults to 1.</span>
<span class="sd">        show_progress (bool, optional): If True, displays a progress bar. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        HSIAttributesSpectral | list[HSIAttributesSpectral]: The computed attributions for the input hyperspectral</span>
<span class="sd">            image(s). if a list of HSI objects is provided, the attributions are computed for each HSI object in</span>
<span class="sd">            the list.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If the explainer is not initialized.</span>
<span class="sd">        ValueError: If the sliding window shapes or strides are not a tuple of a single integer.</span>
<span class="sd">        TypeError: If the sliding window shapes or strides are not a single integer.</span>
<span class="sd">        HSIAttributesError: If an error occurs during the generation of the attributions</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; occlusion = Occlusion(explainable_model)</span>
<span class="sd">        &gt;&gt;&gt; hsi = HSI(image=torch.ones((10, 240, 240)), wavelengths=torch.arange(10))</span>
<span class="sd">        &gt;&gt;&gt; attributions = occlusion.get_spectral_attributes(hsi, baseline=0, sliding_window_shapes=3, strides=1)</span>
<span class="sd">        &gt;&gt;&gt; attributions = occlusion.get_spectral_attributes([hsi, hsi], baseline=0, sliding_window_shapes=3, strides=2)</span>
<span class="sd">        &gt;&gt;&gt; len(attributions)</span>
<span class="sd">        2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Occlusion explainer is not initialized, INITIALIZATION ERROR&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">HSI</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All of the input hyperspectral images must be of type HSI&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">baseline</span> <span class="o">=</span> <span class="p">[</span><span class="n">baseline</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>

    <span class="n">baseline</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">validate_and_transform_baseline</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">hsi_image</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">baseline</span><span class="p">)</span>
        <span class="p">],</span>
        <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
        <span class="p">[</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sliding window shapes must be a single integer or a tuple of a single integer&quot;</span><span class="p">)</span>
        <span class="n">sliding_window_shapes</span> <span class="o">=</span> <span class="n">sliding_window_shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strides</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">strides</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Strides must be a single integer or a tuple of a single integer&quot;</span><span class="p">)</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Sliding window shapes must be a single integer&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strides</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Strides must be a single integer&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">full_sliding_window_shapes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">full_sliding_window_shapes</span><span class="p">[</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">sliding_window_shapes</span>
        <span class="n">full_strides</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">full_strides</span><span class="p">[</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">strides</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">full_sliding_window_shapes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">full_sliding_window_shapes</span><span class="p">[</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">sliding_window_shapes</span>
        <span class="n">full_strides</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hsi</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">full_strides</span><span class="p">[</span><span class="n">hsi</span><span class="o">.</span><span class="n">spectral_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">strides</span>

    <span class="n">sliding_window_shapes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">full_sliding_window_shapes</span><span class="p">)</span>
    <span class="n">strides</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">full_strides</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sliding_window_shapes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">strides</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="n">band_mask</span> <span class="o">=</span> <span class="p">[</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_segmentation_mask</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">sliding_window_shapes</span><span class="p">,</span> <span class="n">strides</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span>
    <span class="p">]</span>
    <span class="n">band_names</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">ui</span><span class="o">.</span><span class="n">item</span><span class="p">()):</span> <span class="n">ui</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">ui</span> <span class="ow">in</span> <span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">band_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])}</span>

    <span class="n">occlusion_attributions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
        <span class="n">input_tensor</span><span class="p">,</span>
        <span class="n">sliding_window_shapes</span><span class="o">=</span><span class="n">sliding_window_shapes</span><span class="p">,</span>
        <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">,</span>
        <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
        <span class="n">baselines</span><span class="o">=</span><span class="n">baseline</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span><span class="p">,</span>
        <span class="n">perturbations_per_eval</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">perturbations_per_eval</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)),</span>
        <span class="n">show_progress</span><span class="o">=</span><span class="n">show_progress</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">spectral_attributes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">HSIAttributesSpectral</span><span class="p">(</span>
                <span class="n">hsi</span><span class="o">=</span><span class="n">hsi_image</span><span class="p">,</span>
                <span class="n">attributes</span><span class="o">=</span><span class="n">attribution</span><span class="p">,</span>
                <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span>
                <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                <span class="n">band_names</span><span class="o">=</span><span class="n">band_names</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">attribution</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">occlusion_attributions</span><span class="p">,</span> <span class="n">band_mask</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error in generating Occlusion attributions: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">return</span> <span class="n">spectral_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectral_attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">spectral_attributes</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.meteors.attr.saliency.Saliency" class="doc doc-heading">
            <code>Saliency</code>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="src.meteors.attr.explainer.Explainer">Explainer</span></code></p>


        <p>Saliency explainer class for generating attributions using the Saliency method.
This baseline method for computing input attribution calculates gradients with respect to inputs.
It also has an option to return the absolute value of the gradients, which is the default behaviour.
Implementation of this method is based on the <a href="https://captum.ai/api/saliency.html"><code>captum</code> repository</a></p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="src.meteors.attr.saliency.Saliency._attribution_method">_attribution_method</span></code></td>
            <td>
                  <code><span title="captum.attr.Saliency">Saliency</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The Saliency method from the <code>captum</code> library.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>explainable_model</code>
            </td>
            <td>
                  <code><span title="meteors.models.ExplainableModel">ExplainableModel</span> | <span title="src.meteors.attr.explainer.Explainer">Explainer</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The explainable model to be explained.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>






              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/saliency.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Saliency</span><span class="p">(</span><span class="n">Explainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Saliency explainer class for generating attributions using the Saliency method.</span>
<span class="sd">    This baseline method for computing input attribution calculates gradients with respect to inputs.</span>
<span class="sd">    It also has an option to return the absolute value of the gradients, which is the default behaviour.</span>
<span class="sd">    Implementation of this method is based on the [`captum` repository](https://captum.ai/api/saliency.html)</span>

<span class="sd">    Attributes:</span>
<span class="sd">        _attribution_method (CaptumSaliency): The Saliency method from the `captum` library.</span>

<span class="sd">    Args:</span>
<span class="sd">        explainable_model (ExplainableModel | Explainer): The explainable model to be explained.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">explainable_model</span><span class="p">:</span> <span class="n">ExplainableModel</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">explainable_model</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="o">=</span> <span class="n">CaptumSaliency</span><span class="p">(</span><span class="n">explainable_model</span><span class="o">.</span><span class="n">forward_func</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="nb">abs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributes</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributes</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for generating attributions using the Saliency method.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">                If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">                The output will be a list of HSIAttributes objects.</span>
<span class="sd">            target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">                methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">                must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">                image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">            abs (bool, optional): Returns absolute value of gradients if set to True,</span>
<span class="sd">                otherwise returns the (signed) gradients if False. Default: True</span>
<span class="sd">            additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">                the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">                It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">                containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">                These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">                Note that attributions are not computed with respect to these arguments. Default: None</span>

<span class="sd">        Returns:</span>
<span class="sd">            HSIAttributes | list[HSIAttributes]: The computed attributions for the input hyperspectral image(s).</span>
<span class="sd">                if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If the explainer is not initialized.</span>
<span class="sd">            HSIAttributesError: If an error occurs during the generation of the attributions</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; saliency = Saliency(explainable_model)</span>
<span class="sd">            &gt;&gt;&gt; hsi = HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">            &gt;&gt;&gt; attributions = saliency.attribute(hsi)</span>
<span class="sd">            &gt;&gt;&gt; attributions = saliency.attribute([hsi, hsi])</span>
<span class="sd">            &gt;&gt;&gt; len(attributions)</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Saliency explainer is not initialized, INITIALIZATION ERROR&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">hsi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">HSI</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All of the input hyperspectral images must be of type HSI&quot;</span><span class="p">)</span>

        <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>

        <span class="n">saliency_attributions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
            <span class="n">input_tensor</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="nb">abs</span><span class="o">=</span><span class="nb">abs</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">HSIAttributes</span><span class="p">(</span><span class="n">hsi</span><span class="o">=</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">attributes</span><span class="o">=</span><span class="n">attribution</span><span class="p">,</span> <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">attribution</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">saliency_attributions</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error in generating Saliency attributions: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">return</span> <span class="n">attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">attributes</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.saliency.Saliency.attribute" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">attribute</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">abs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Method for generating attributions using the Saliency method.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>hsi</code>
            </td>
            <td>
                  <code>list[<span title="meteors.HSI">HSI</span>] | <span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Input hyperspectral image(s) for which the attributions are to be computed.
If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.
The output will be a list of HSIAttributes objects.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>target</code>
            </td>
            <td>
                  <code>list[int] | int | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>target class index for computing the attributions. If None,
methods assume that the output has only one class. If the output has multiple classes, the target index
must be provided. For multiple input images, a list of target indices can be provided, one for each
image or single target value will be used for all images. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>abs</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Returns absolute value of gradients if set to True,
otherwise returns the (signed) gradients if False. Default: True</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>additional_forward_args</code>
            </td>
            <td>
                  <code><span title="typing.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the forward function requires additional arguments other than
the inputs for which attributions should not be computed, this argument can be provided.
It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple
containing multiple additional arguments including tensors or any arbitrary python types.
These arguments are provided to forward_func in order following the arguments in inputs.
Note that attributions are not computed with respect to these arguments. Default: None</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributes" href="#src.meteors.attr.attributes.HSIAttributes">HSIAttributes</a> | list[<a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributes" href="#src.meteors.attr.attributes.HSIAttributes">HSIAttributes</a>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>HSIAttributes | list[HSIAttributes]: The computed attributions for the input hyperspectral image(s).
if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>RuntimeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the explainer is not initialized.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="meteors.exceptions.HSIAttributesError">HSIAttributesError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If an error occurs during the generation of the attributions</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">saliency</span> <span class="o">=</span> <span class="n">Saliency</span><span class="p">(</span><span class="n">explainable_model</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">)),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="p">[</span><span class="mf">462.08</span><span class="p">,</span> <span class="mf">465.27</span><span class="p">,</span> <span class="mf">468.47</span><span class="p">,</span> <span class="mf">471.68</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attributions</span> <span class="o">=</span> <span class="n">saliency</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attributions</span> <span class="o">=</span> <span class="n">saliency</span><span class="o">.</span><span class="n">attribute</span><span class="p">([</span><span class="n">hsi</span><span class="p">,</span> <span class="n">hsi</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">attributions</span><span class="p">)</span>
<span class="go">2</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/saliency.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="nb">abs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributes</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributes</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method for generating attributions using the Saliency method.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">            If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">            The output will be a list of HSIAttributes objects.</span>
<span class="sd">        target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">            methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">            must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">            image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">        abs (bool, optional): Returns absolute value of gradients if set to True,</span>
<span class="sd">            otherwise returns the (signed) gradients if False. Default: True</span>
<span class="sd">        additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">            the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">            It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">            containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">            These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">            Note that attributions are not computed with respect to these arguments. Default: None</span>

<span class="sd">    Returns:</span>
<span class="sd">        HSIAttributes | list[HSIAttributes]: The computed attributions for the input hyperspectral image(s).</span>
<span class="sd">            if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If the explainer is not initialized.</span>
<span class="sd">        HSIAttributesError: If an error occurs during the generation of the attributions</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; saliency = Saliency(explainable_model)</span>
<span class="sd">        &gt;&gt;&gt; hsi = HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">        &gt;&gt;&gt; attributions = saliency.attribute(hsi)</span>
<span class="sd">        &gt;&gt;&gt; attributions = saliency.attribute([hsi, hsi])</span>
<span class="sd">        &gt;&gt;&gt; len(attributions)</span>
<span class="sd">        2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Saliency explainer is not initialized, INITIALIZATION ERROR&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">HSI</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All of the input hyperspectral images must be of type HSI&quot;</span><span class="p">)</span>

    <span class="n">input_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
        <span class="p">[</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">get_image</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hsi_image</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>

    <span class="n">saliency_attributions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribution_method</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span>
        <span class="n">input_tensor</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="nb">abs</span><span class="o">=</span><span class="nb">abs</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="n">additional_forward_args</span>
    <span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">HSIAttributes</span><span class="p">(</span><span class="n">hsi</span><span class="o">=</span><span class="n">hsi_image</span><span class="p">,</span> <span class="n">attributes</span><span class="o">=</span><span class="n">attribution</span><span class="p">,</span> <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">attribution</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">saliency_attributions</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error in generating Saliency attributions: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">return</span> <span class="n">attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">attributes</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.meteors.attr.noise_tunnel.NoiseTunnel" class="doc doc-heading">
            <code>NoiseTunnel</code>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="src.meteors.attr.noise_tunnel.BaseNoiseTunnel">BaseNoiseTunnel</span></code></p>


        <p>Noise Tunnel is a method that is used to explain the model's predictions by adding noise to the input tensor.
The noise is added to the input tensor, and the model's output is computed. The process is repeated multiple times
to obtain a distribution of the model's output. The final attribution is computed as the mean of the outputs.
For more information about the method, see <a href="https://captum.ai/api/noise_tunnel.html"><code>captum</code> documentation</a>.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chained_explainer</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The explainable method that will be used to compute the attributions.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>RuntimeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the callable object is not an instance of the Explainer class</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>






              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/noise_tunnel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">NoiseTunnel</span><span class="p">(</span><span class="n">BaseNoiseTunnel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Noise Tunnel is a method that is used to explain the model&#39;s predictions by adding noise to the input tensor.</span>
<span class="sd">    The noise is added to the input tensor, and the model&#39;s output is computed. The process is repeated multiple times</span>
<span class="sd">    to obtain a distribution of the model&#39;s output. The final attribution is computed as the mean of the outputs.</span>
<span class="sd">    For more information about the method, see [`captum` documentation](https://captum.ai/api/noise_tunnel.html).</span>

<span class="sd">    Arguments:</span>
<span class="sd">        chained_explainer: The explainable method that will be used to compute the attributions.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If the callable object is not an instance of the Explainer class</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">perturb_input</span><span class="p">(</span>
        <span class="nb">input</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">perturbation_axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">slice</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">stdevs</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The default perturbation function used in the noise tunnel with small enhancement for hyperspectral images.</span>
<span class="sd">        It randomly adds noise to the input tensor from a normal distribution with a given standard deviation.</span>
<span class="sd">        The noise is added to the selected bands (channels) of the input tensor.</span>
<span class="sd">        The bands to be perturbed are selected based on the `perturbation_axis` parameter.</span>
<span class="sd">        By default all bands are perturbed, which is equivalent to the standard noise tunnel method.</span>

<span class="sd">        Args:</span>
<span class="sd">            input (torch.Tensor): An input tensor to be perturbed. It should have the shape (C, H, W).</span>
<span class="sd">            n_samples (int): A number of samples to be drawn - number of perturbed inputs to be generated.</span>
<span class="sd">            perturbation_axis (None | tuple[int | slice]): The indices of the bands to be perturbed.</span>
<span class="sd">                If set to None, all bands are perturbed. Defaults to None.</span>
<span class="sd">            stdevs (float): The standard deviation of gaussian noise with zero mean that is added to each input</span>
<span class="sd">                in the batch. Defaults to 1.0.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A perturbed tensor, which contains `n_samples` perturbed inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n_samples</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of perturbated samples to be generated must be greater than 0&quot;</span><span class="p">)</span>

        <span class="c1"># the perturbation</span>
        <span class="n">perturbed_input</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># repeat the perturbed_input on the first dimension n_samples times</span>
        <span class="n">perturbed_input</span> <span class="o">=</span> <span class="n">perturbed_input</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># the perturbation shape</span>
        <span class="k">if</span> <span class="n">perturbation_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">perturbation_shape</span> <span class="o">=</span> <span class="n">perturbed_input</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">perturbation_axis</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="n">perturbation_axis</span>  <span class="c1"># type: ignore</span>
            <span class="n">perturbation_shape</span> <span class="o">=</span> <span class="n">perturbed_input</span><span class="p">[</span><span class="n">perturbation_axis</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># the noise</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stdevs</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">perturbation_shape</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># add the noise to the perturbed_input</span>
        <span class="k">if</span> <span class="n">perturbation_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">perturbed_input</span> <span class="o">+=</span> <span class="n">noise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">perturbed_input</span><span class="p">[</span><span class="n">perturbation_axis</span><span class="p">]</span> <span class="o">+=</span> <span class="n">noise</span>

        <span class="n">perturbed_input</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">perturbed_input</span>

    <span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">steps_per_batch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">perturbation_axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">slice</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">stdevs</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;smoothgrad&quot;</span><span class="p">,</span> <span class="s2">&quot;smoothgrad_sq&quot;</span><span class="p">,</span> <span class="s2">&quot;vargrad&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;smoothgrad&quot;</span><span class="p">,</span>
        <span class="n">keep_gradient</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributes</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributes</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for generating attributions using the Noise Tunnel method.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">                If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">                The output will be a list of HSIAttributes objects.</span>
<span class="sd">            baseline (int | float | torch.Tensor, optional): Baselines define reference value which replaces each</span>
<span class="sd">                feature when occluded is computed and can be provided as:</span>
<span class="sd">                    - integer or float representing a constant value used as the baseline for all input pixels.</span>
<span class="sd">                    - tensor with the same shape as the input tensor, providing a baseline for each input pixel.</span>
<span class="sd">                        if the input is a list of HSI objects, the baseline can be a tensor with the same shape as</span>
<span class="sd">                        the input tensor for each HSI object.</span>
<span class="sd">            target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">                methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">                must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">                image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">            additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">                the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">                It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">                containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">                These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">                Note that attributions are not computed with respect to these arguments. Default: None</span>
<span class="sd">            n_samples (int, optional): The number of randomly generated examples per sample in the input batch.</span>
<span class="sd">                Random examples are generated by adding gaussian random noise to each sample.</span>
<span class="sd">                Default: 5 if nt_samples is not provided.</span>
<span class="sd">            steps_per_batch (int, optional): The number of the n_samples that will be processed together.</span>
<span class="sd">                With the help of this parameter we can avoid out of memory situation and reduce the number of randomly</span>
<span class="sd">                generated examples per sample in each batch. Default: None if steps_per_batch is not provided.</span>
<span class="sd">                In this case all nt_samples will be processed together.</span>
<span class="sd">            perturbation_axis (None | tuple[int | slice], optional): The indices of the input image to be perturbed.</span>
<span class="sd">                If set to None, all bands are perturbed, which corresponds to a traditional noise tunnel method.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            stdevs (float | tuple[float, ...], optional): The standard deviation of gaussian noise with zero mean that</span>
<span class="sd">                is added to each input in the batch. If stdevs is a single float value then that same value is used</span>
<span class="sd">                for all inputs. If stdevs is a tuple, then the length of the tuple must match the number of inputs as</span>
<span class="sd">                each value in the tuple is used for the corresponding input. Default: 1.0</span>
<span class="sd">            method (Literal[&quot;smoothgrad&quot;, &quot;smoothgrad_sq&quot;, &quot;vargrad&quot;], optional): Smoothing type of the attributions.</span>
<span class="sd">                smoothgrad, smoothgrad_sq or vargrad Default: smoothgrad if type is not provided.</span>
<span class="sd">            keep_gradient (bool, optional): Indicates whether to keep the gradient tensors in memory. By the default,</span>
<span class="sd">                the gradient tensors are removed from the computation graph after the attributions are computed, due</span>
<span class="sd">                to memory efficiency. If the gradient tensors are needed for further processing, this parameter should</span>
<span class="sd">                be set to True. Default: False</span>

<span class="sd">        Returns:</span>
<span class="sd">            HSIAttributes | list[HSIAttributes]: The computed attributions for the input hyperspectral image(s).</span>
<span class="sd">                if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>

<span class="sd">        Raises:</span>
<span class="sd">            HSIAttributesError: If an error occurs during the generation of the attributions.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; noise_tunnel = NoiseTunnel(explainable_model)</span>
<span class="sd">            &gt;&gt;&gt; hsi = HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">            &gt;&gt;&gt; attributions = noise_tunnel.attribute(hsi)</span>
<span class="sd">            &gt;&gt;&gt; attributions = noise_tunnel.attribute([hsi, hsi])</span>
<span class="sd">            &gt;&gt;&gt; len(attributions)</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stdevs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">stdevs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">stdevs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">hsi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">HSI</span><span class="p">)</span> <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All inputs must be HSI objects&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stdevs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stdevs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The number of stdevs must match the number of input images, number of stdevs:&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">stdevs</span><span class="p">)</span><span class="si">}</span><span class="s2">, number of input images: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stdevs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">stdevs</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">target</span> <span class="o">=</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="n">nt_attributes</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">))</span> <span class="o">+</span> <span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)):</span>
            <span class="nb">input</span> <span class="o">=</span> <span class="n">hsi</span><span class="p">[</span><span class="n">batch</span><span class="p">]</span>
            <span class="n">targeted</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="n">batch</span><span class="p">]</span>
            <span class="n">stdev</span> <span class="o">=</span> <span class="n">stdevs</span><span class="p">[</span><span class="n">batch</span><span class="p">]</span>
            <span class="n">perturbed_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perturb_input</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">perturbation_axis</span><span class="p">,</span> <span class="n">stdev</span><span class="p">)</span>
            <span class="n">nt_attributes</span><span class="p">[:,</span> <span class="n">batch</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_forward_loop</span><span class="p">(</span>
                <span class="n">perturbed_input</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">targeted</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">steps_per_batch</span>
            <span class="p">)</span>

        <span class="n">nt_attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_attributions</span><span class="p">(</span><span class="n">nt_attributes</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">HSIAttributes</span><span class="p">(</span>
                    <span class="n">hsi</span><span class="o">=</span><span class="n">hsi_image</span><span class="p">,</span>
                    <span class="n">attributes</span><span class="o">=</span><span class="n">attribution</span> <span class="k">if</span> <span class="n">keep_gradient</span> <span class="k">else</span> <span class="n">attribution</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span>
                    <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">attribution</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">nt_attributes</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error in generating NoiseTunnel attributions: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">return</span> <span class="n">attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">attributes</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.noise_tunnel.NoiseTunnel.attribute" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">attribute</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">steps_per_batch</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">perturbation_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stdevs</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;smoothgrad&#39;</span><span class="p">,</span> <span class="n">keep_gradient</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Method for generating attributions using the Noise Tunnel method.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>hsi</code>
            </td>
            <td>
                  <code>list[<span title="meteors.HSI">HSI</span>] | <span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Input hyperspectral image(s) for which the attributions are to be computed.
If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.
The output will be a list of HSIAttributes objects.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>baseline</code>
            </td>
            <td>
                  <code>int | float | <span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Baselines define reference value which replaces each
feature when occluded is computed and can be provided as:
    - integer or float representing a constant value used as the baseline for all input pixels.
    - tensor with the same shape as the input tensor, providing a baseline for each input pixel.
        if the input is a list of HSI objects, the baseline can be a tensor with the same shape as
        the input tensor for each HSI object.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>target</code>
            </td>
            <td>
                  <code>list[int] | int | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>target class index for computing the attributions. If None,
methods assume that the output has only one class. If the output has multiple classes, the target index
must be provided. For multiple input images, a list of target indices can be provided, one for each
image or single target value will be used for all images. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>additional_forward_args</code>
            </td>
            <td>
                  <code><span title="typing.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the forward function requires additional arguments other than
the inputs for which attributions should not be computed, this argument can be provided.
It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple
containing multiple additional arguments including tensors or any arbitrary python types.
These arguments are provided to forward_func in order following the arguments in inputs.
Note that attributions are not computed with respect to these arguments. Default: None</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_samples</code>
            </td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of randomly generated examples per sample in the input batch.
Random examples are generated by adding gaussian random noise to each sample.
Default: 5 if nt_samples is not provided.</p>
              </div>
            </td>
            <td>
                  <code>5</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>steps_per_batch</code>
            </td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of the n_samples that will be processed together.
With the help of this parameter we can avoid out of memory situation and reduce the number of randomly
generated examples per sample in each batch. Default: None if steps_per_batch is not provided.
In this case all nt_samples will be processed together.</p>
              </div>
            </td>
            <td>
                  <code>1</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>perturbation_axis</code>
            </td>
            <td>
                  <code>None | tuple[int | slice]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The indices of the input image to be perturbed.
If set to None, all bands are perturbed, which corresponds to a traditional noise tunnel method.
Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>stdevs</code>
            </td>
            <td>
                  <code>float | tuple[float, ...]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The standard deviation of gaussian noise with zero mean that
is added to each input in the batch. If stdevs is a single float value then that same value is used
for all inputs. If stdevs is a tuple, then the length of the tuple must match the number of inputs as
each value in the tuple is used for the corresponding input. Default: 1.0</p>
              </div>
            </td>
            <td>
                  <code>1.0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>method</code>
            </td>
            <td>
                  <code><span title="typing.Literal">Literal</span>[&#39;smoothgrad&#39;, &#39;smoothgrad_sq&#39;, &#39;vargrad&#39;]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Smoothing type of the attributions.
smoothgrad, smoothgrad_sq or vargrad Default: smoothgrad if type is not provided.</p>
              </div>
            </td>
            <td>
                  <code>&#39;smoothgrad&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>keep_gradient</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Indicates whether to keep the gradient tensors in memory. By the default,
the gradient tensors are removed from the computation graph after the attributions are computed, due
to memory efficiency. If the gradient tensors are needed for further processing, this parameter should
be set to True. Default: False</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributes" href="#src.meteors.attr.attributes.HSIAttributes">HSIAttributes</a> | list[<a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributes" href="#src.meteors.attr.attributes.HSIAttributes">HSIAttributes</a>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>HSIAttributes | list[HSIAttributes]: The computed attributions for the input hyperspectral image(s).
if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="meteors.exceptions.HSIAttributesError">HSIAttributesError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If an error occurs during the generation of the attributions.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">noise_tunnel</span> <span class="o">=</span> <span class="n">NoiseTunnel</span><span class="p">(</span><span class="n">explainable_model</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">)),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="p">[</span><span class="mf">462.08</span><span class="p">,</span> <span class="mf">465.27</span><span class="p">,</span> <span class="mf">468.47</span><span class="p">,</span> <span class="mf">471.68</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attributions</span> <span class="o">=</span> <span class="n">noise_tunnel</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attributions</span> <span class="o">=</span> <span class="n">noise_tunnel</span><span class="o">.</span><span class="n">attribute</span><span class="p">([</span><span class="n">hsi</span><span class="p">,</span> <span class="n">hsi</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">attributions</span><span class="p">)</span>
<span class="go">2</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/noise_tunnel.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">steps_per_batch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">perturbation_axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">slice</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">stdevs</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;smoothgrad&quot;</span><span class="p">,</span> <span class="s2">&quot;smoothgrad_sq&quot;</span><span class="p">,</span> <span class="s2">&quot;vargrad&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;smoothgrad&quot;</span><span class="p">,</span>
    <span class="n">keep_gradient</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributes</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributes</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method for generating attributions using the Noise Tunnel method.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">            If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">            The output will be a list of HSIAttributes objects.</span>
<span class="sd">        baseline (int | float | torch.Tensor, optional): Baselines define reference value which replaces each</span>
<span class="sd">            feature when occluded is computed and can be provided as:</span>
<span class="sd">                - integer or float representing a constant value used as the baseline for all input pixels.</span>
<span class="sd">                - tensor with the same shape as the input tensor, providing a baseline for each input pixel.</span>
<span class="sd">                    if the input is a list of HSI objects, the baseline can be a tensor with the same shape as</span>
<span class="sd">                    the input tensor for each HSI object.</span>
<span class="sd">        target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">            methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">            must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">            image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">        additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">            the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">            It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">            containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">            These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">            Note that attributions are not computed with respect to these arguments. Default: None</span>
<span class="sd">        n_samples (int, optional): The number of randomly generated examples per sample in the input batch.</span>
<span class="sd">            Random examples are generated by adding gaussian random noise to each sample.</span>
<span class="sd">            Default: 5 if nt_samples is not provided.</span>
<span class="sd">        steps_per_batch (int, optional): The number of the n_samples that will be processed together.</span>
<span class="sd">            With the help of this parameter we can avoid out of memory situation and reduce the number of randomly</span>
<span class="sd">            generated examples per sample in each batch. Default: None if steps_per_batch is not provided.</span>
<span class="sd">            In this case all nt_samples will be processed together.</span>
<span class="sd">        perturbation_axis (None | tuple[int | slice], optional): The indices of the input image to be perturbed.</span>
<span class="sd">            If set to None, all bands are perturbed, which corresponds to a traditional noise tunnel method.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        stdevs (float | tuple[float, ...], optional): The standard deviation of gaussian noise with zero mean that</span>
<span class="sd">            is added to each input in the batch. If stdevs is a single float value then that same value is used</span>
<span class="sd">            for all inputs. If stdevs is a tuple, then the length of the tuple must match the number of inputs as</span>
<span class="sd">            each value in the tuple is used for the corresponding input. Default: 1.0</span>
<span class="sd">        method (Literal[&quot;smoothgrad&quot;, &quot;smoothgrad_sq&quot;, &quot;vargrad&quot;], optional): Smoothing type of the attributions.</span>
<span class="sd">            smoothgrad, smoothgrad_sq or vargrad Default: smoothgrad if type is not provided.</span>
<span class="sd">        keep_gradient (bool, optional): Indicates whether to keep the gradient tensors in memory. By the default,</span>
<span class="sd">            the gradient tensors are removed from the computation graph after the attributions are computed, due</span>
<span class="sd">            to memory efficiency. If the gradient tensors are needed for further processing, this parameter should</span>
<span class="sd">            be set to True. Default: False</span>

<span class="sd">    Returns:</span>
<span class="sd">        HSIAttributes | list[HSIAttributes]: The computed attributions for the input hyperspectral image(s).</span>
<span class="sd">            if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>

<span class="sd">    Raises:</span>
<span class="sd">        HSIAttributesError: If an error occurs during the generation of the attributions.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; noise_tunnel = NoiseTunnel(explainable_model)</span>
<span class="sd">        &gt;&gt;&gt; hsi = HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">        &gt;&gt;&gt; attributions = noise_tunnel.attribute(hsi)</span>
<span class="sd">        &gt;&gt;&gt; attributions = noise_tunnel.attribute([hsi, hsi])</span>
<span class="sd">        &gt;&gt;&gt; len(attributions)</span>
<span class="sd">        2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stdevs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">stdevs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">stdevs</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">HSI</span><span class="p">)</span> <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All inputs must be HSI objects&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stdevs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stdevs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The number of stdevs must match the number of input images, number of stdevs:&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">stdevs</span><span class="p">)</span><span class="si">}</span><span class="s2">, number of input images: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stdevs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">stdevs</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">target</span> <span class="o">=</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

    <span class="n">nt_attributes</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">))</span> <span class="o">+</span> <span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)):</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="n">hsi</span><span class="p">[</span><span class="n">batch</span><span class="p">]</span>
        <span class="n">targeted</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="n">batch</span><span class="p">]</span>
        <span class="n">stdev</span> <span class="o">=</span> <span class="n">stdevs</span><span class="p">[</span><span class="n">batch</span><span class="p">]</span>
        <span class="n">perturbed_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perturb_input</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">perturbation_axis</span><span class="p">,</span> <span class="n">stdev</span><span class="p">)</span>
        <span class="n">nt_attributes</span><span class="p">[:,</span> <span class="n">batch</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_forward_loop</span><span class="p">(</span>
            <span class="n">perturbed_input</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">targeted</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">steps_per_batch</span>
        <span class="p">)</span>

    <span class="n">nt_attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_attributions</span><span class="p">(</span><span class="n">nt_attributes</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">HSIAttributes</span><span class="p">(</span>
                <span class="n">hsi</span><span class="o">=</span><span class="n">hsi_image</span><span class="p">,</span>
                <span class="n">attributes</span><span class="o">=</span><span class="n">attribution</span> <span class="k">if</span> <span class="n">keep_gradient</span> <span class="k">else</span> <span class="n">attribution</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span>
                <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">attribution</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">nt_attributes</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error in generating NoiseTunnel attributions: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">return</span> <span class="n">attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">attributes</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.noise_tunnel.NoiseTunnel.perturb_input" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">perturb_input</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">perturbation_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stdevs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>The default perturbation function used in the noise tunnel with small enhancement for hyperspectral images.
It randomly adds noise to the input tensor from a normal distribution with a given standard deviation.
The noise is added to the selected bands (channels) of the input tensor.
The bands to be perturbed are selected based on the <code>perturbation_axis</code> parameter.
By default all bands are perturbed, which is equivalent to the standard noise tunnel method.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>input</code>
            </td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An input tensor to be perturbed. It should have the shape (C, H, W).</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_samples</code>
            </td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A number of samples to be drawn - number of perturbed inputs to be generated.</p>
              </div>
            </td>
            <td>
                  <code>1</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>perturbation_axis</code>
            </td>
            <td>
                  <code>None | tuple[int | slice]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The indices of the bands to be perturbed.
If set to None, all bands are perturbed. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>stdevs</code>
            </td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The standard deviation of gaussian noise with zero mean that is added to each input
in the batch. Defaults to 1.0.</p>
              </div>
            </td>
            <td>
                  <code>1</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: A perturbed tensor, which contains <code>n_samples</code> perturbed inputs.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/noise_tunnel.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">perturb_input</span><span class="p">(</span>
    <span class="nb">input</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">perturbation_axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">slice</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">stdevs</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The default perturbation function used in the noise tunnel with small enhancement for hyperspectral images.</span>
<span class="sd">    It randomly adds noise to the input tensor from a normal distribution with a given standard deviation.</span>
<span class="sd">    The noise is added to the selected bands (channels) of the input tensor.</span>
<span class="sd">    The bands to be perturbed are selected based on the `perturbation_axis` parameter.</span>
<span class="sd">    By default all bands are perturbed, which is equivalent to the standard noise tunnel method.</span>

<span class="sd">    Args:</span>
<span class="sd">        input (torch.Tensor): An input tensor to be perturbed. It should have the shape (C, H, W).</span>
<span class="sd">        n_samples (int): A number of samples to be drawn - number of perturbed inputs to be generated.</span>
<span class="sd">        perturbation_axis (None | tuple[int | slice]): The indices of the bands to be perturbed.</span>
<span class="sd">            If set to None, all bands are perturbed. Defaults to None.</span>
<span class="sd">        stdevs (float): The standard deviation of gaussian noise with zero mean that is added to each input</span>
<span class="sd">            in the batch. Defaults to 1.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: A perturbed tensor, which contains `n_samples` perturbed inputs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n_samples</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of perturbated samples to be generated must be greater than 0&quot;</span><span class="p">)</span>

    <span class="c1"># the perturbation</span>
    <span class="n">perturbed_input</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># repeat the perturbed_input on the first dimension n_samples times</span>
    <span class="n">perturbed_input</span> <span class="o">=</span> <span class="n">perturbed_input</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># the perturbation shape</span>
    <span class="k">if</span> <span class="n">perturbation_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">perturbation_shape</span> <span class="o">=</span> <span class="n">perturbed_input</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">perturbation_axis</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="n">perturbation_axis</span>  <span class="c1"># type: ignore</span>
        <span class="n">perturbation_shape</span> <span class="o">=</span> <span class="n">perturbed_input</span><span class="p">[</span><span class="n">perturbation_axis</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># the noise</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stdevs</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">perturbation_shape</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="c1"># add the noise to the perturbed_input</span>
    <span class="k">if</span> <span class="n">perturbation_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">perturbed_input</span> <span class="o">+=</span> <span class="n">noise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">perturbed_input</span><span class="p">[</span><span class="n">perturbation_axis</span><span class="p">]</span> <span class="o">+=</span> <span class="n">noise</span>

    <span class="n">perturbed_input</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">perturbed_input</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="src.meteors.attr.noise_tunnel.HyperNoiseTunnel" class="doc doc-heading">
            <code>HyperNoiseTunnel</code>


</h3>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="src.meteors.attr.noise_tunnel.BaseNoiseTunnel">BaseNoiseTunnel</span></code></p>


        <p>Hyper Noise Tunnel is our novel method, designed specifically to explain hyperspectral satellite images. It is
inspired by the behaviour of the classical Noise Tunnel (Smooth Grad) method, but instead of sampling noise into the
original image, it randomly masks some of the bands with the baseline. In the process, the created <em>noised</em> samples
are close to the distribution of the original image yet differ enough to smoothen the produced attribution map.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chained_explainer</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The explainable method that will be used to compute the attributions.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>RuntimeError</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the callable object is not an instance of the Explainer class</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>






              <details class="quote">
                <summary>Source code in <code>src/meteors/attr/noise_tunnel.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">HyperNoiseTunnel</span><span class="p">(</span><span class="n">BaseNoiseTunnel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Hyper Noise Tunnel is our novel method, designed specifically to explain hyperspectral satellite images. It is</span>
<span class="sd">    inspired by the behaviour of the classical Noise Tunnel (Smooth Grad) method, but instead of sampling noise into the</span>
<span class="sd">    original image, it randomly masks some of the bands with the baseline. In the process, the created _noised_ samples</span>
<span class="sd">    are close to the distribution of the original image yet differ enough to smoothen the produced attribution map.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        chained_explainer: The explainable method that will be used to compute the attributions.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If the callable object is not an instance of the Explainer class</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">perturb_input</span><span class="p">(</span>
        <span class="nb">input</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">baseline</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">perturbation_prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">num_perturbed_bands</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The perturbation function used in the hyper noise tunnel. It randomly selects a subset of the input bands</span>
<span class="sd">        that will be masked out and replaced with the baseline. The parameters `num_perturbed_bands` and</span>
<span class="sd">        `perturbation_prob` control the number of bands that will be perturbed (masked). If `num_perturbed_bands` is</span>
<span class="sd">        set, it will be used as the number of bands to perturb, which will be randomly selected. Otherwise, the number</span>
<span class="sd">        of bands will be drawn from a binomial distribution with `perturbation_prob` as the probability of success.</span>

<span class="sd">        Args:</span>
<span class="sd">            input (torch.Tensor): An input tensor to be perturbed. It should have the shape (C, H, W).</span>
<span class="sd">            baseline (torch.Tensor | None, optional): A tensor that will be used to replace the perturbed bands.</span>
<span class="sd">            n_samples (int): A number of samples to be drawn - number of perturbed inputs to be generated.</span>
<span class="sd">            perturbation_prob (float, optional): A probability that each band will be perturbed intependently.</span>
<span class="sd">                Defaults to 0.5.</span>
<span class="sd">            num_perturbed_bands (int | None, optional): A number of perturbed bands in the whole image.</span>
<span class="sd">                If set to None, the bands are perturbed with probability `perturbation_prob` each. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: A perturbed tensor, which contains `n_samples` perturbed inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># validate the baseline against the input</span>
        <span class="k">if</span> <span class="n">baseline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Baseline must be provided for the HyperNoiseTunnel method&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">baseline</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeMismatchError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Baseline shape </span><span class="si">{</span><span class="n">baseline</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> does not match input shape </span><span class="si">{</span><span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n_samples</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of perturbated samples to be generated must be greater than 0&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">perturbation_prob</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">perturbation_prob</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Perturbation probability must be in the range [0, 1]&quot;</span><span class="p">)</span>

        <span class="c1"># the perturbation</span>
        <span class="n">perturbed_input</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># repeat the perturbed_input on the first dimension n_samples times</span>
        <span class="n">perturbed_input</span> <span class="o">=</span> <span class="n">perturbed_input</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">n_samples_x_channels_shape</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">n_samples</span><span class="p">,</span>
            <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">)</span>  <span class="c1"># shape of the tensor containing the perturbed channels for each sample</span>

        <span class="n">channels_to_be_perturbed</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_samples_x_channels_shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">bool</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">num_perturbed_bands</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channel_perturbation_probabilities</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_samples_x_channels_shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">*</span> <span class="n">perturbation_prob</span>
            <span class="p">)</span>
            <span class="n">channels_to_be_perturbed</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">bernoulli</span><span class="p">(</span><span class="n">channel_perturbation_probabilities</span><span class="p">)</span><span class="o">.</span><span class="n">bool</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num_perturbed_bands</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">num_perturbed_bands</span> <span class="o">&gt;</span> <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot perturb </span><span class="si">{</span><span class="n">num_perturbed_bands</span><span class="si">}</span><span class="s2"> bands in the input with </span><span class="si">{</span><span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> channels. The number of perturbed bands must be in the range [0, </span><span class="si">{</span><span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">]&quot;</span>
                <span class="p">)</span>

            <span class="n">channels_to_be_perturbed</span> <span class="o">=</span> <span class="n">torch_random_choice</span><span class="p">(</span>
                <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num_perturbed_bands</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">device</span>
            <span class="p">)</span>

        <span class="c1"># now having chosen the perturbed channels, we can replace them with the baseline</span>
        <span class="n">reshaped_baseline</span> <span class="o">=</span> <span class="n">baseline</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">perturbed_input</span><span class="p">[</span><span class="n">channels_to_be_perturbed</span><span class="p">]</span> <span class="o">=</span> <span class="n">reshaped_baseline</span><span class="p">[</span><span class="n">channels_to_be_perturbed</span><span class="p">]</span>

        <span class="n">perturbed_input</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">perturbed_input</span>

    <span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
        <span class="n">baseline</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">steps_per_batch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">perturbation_prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">num_perturbed_bands</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;smoothgrad&quot;</span><span class="p">,</span> <span class="s2">&quot;smoothgrad_sq&quot;</span><span class="p">,</span> <span class="s2">&quot;vargrad&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;smoothgrad&quot;</span><span class="p">,</span>
        <span class="n">keep_gradient</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributes</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributes</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for generating attributions using the Hyper Noise Tunnel method.</span>

<span class="sd">        Args:</span>
<span class="sd">            hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">                If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">                The output will be a list of HSIAttributes objects.</span>
<span class="sd">            baseline (int | float | torch.Tensor | list[int | float | torch.Tensor], optional): Baselines define reference value which</span>
<span class="sd">                replaces each feature when occluded is computed and can be provided as:</span>
<span class="sd">                    - integer or float representing a constant value used as the baseline for all input pixels.</span>
<span class="sd">                    - tensor with the same shape as the input tensor, providing a baseline for each input pixel.</span>
<span class="sd">                        if the input is a list of HSI objects, the baseline can be a tensor with the same shape as</span>
<span class="sd">                        the input tensor for each HSI object or a list of tensors with the same length as the input list.</span>
<span class="sd">            target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">                methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">                must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">                image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">            additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">                the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">                It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">                containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">                These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">                Note that attributions are not computed with respect to these arguments. Default: None</span>
<span class="sd">            n_samples (int, optional):The number of randomly generated examples per sample in the input batch.</span>
<span class="sd">                Random examples are generated by adding gaussian random noise to each sample.</span>
<span class="sd">                Default: 5 if nt_samples is not provided.</span>
<span class="sd">            steps_per_batch (int, optional): The number of the n_samples that will be processed together.</span>
<span class="sd">                With the help of this parameter we can avoid out of memory situation and reduce the number of randomly</span>
<span class="sd">                generated examples per sample in each batch. Default: None if steps_per_batch is not provided.</span>
<span class="sd">                In this case all nt_samples will be processed together.</span>
<span class="sd">            perturbation_prob (float, optional): The probability that each band will be perturbed independently.</span>
<span class="sd">                Defaults to 0.5.</span>
<span class="sd">            num_perturbed_bands (int | None, optional): The number of perturbed bands in the whole image.</span>
<span class="sd">                The bands to be perturbed are selected randomly with no replacement.</span>
<span class="sd">                If set to None, the bands are perturbed with probability `perturbation_prob` each. Defaults to None.</span>
<span class="sd">            method (Literal[&quot;smoothgrad&quot;, &quot;smoothgrad_sq&quot;, &quot;vargrad&quot;], optional): Smoothing type of the attributions.</span>
<span class="sd">                smoothgrad, smoothgrad_sq or vargrad Default: smoothgrad if type is not provided.</span>
<span class="sd">            keep_gradient (bool, optional): Indicates whether to keep the gradient tensors in memory. By the default,</span>
<span class="sd">                the gradient tensors are removed from the computation graph after the attributions are computed, due</span>
<span class="sd">                to memory efficiency. If the gradient tensors are needed for further processing, this parameter should</span>
<span class="sd">                be set to True. Default: False</span>

<span class="sd">        Returns:</span>
<span class="sd">            HSIAttributes | list[HSIAttributes]: The computed attributions for the input hyperspectral image(s).</span>
<span class="sd">                if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>

<span class="sd">        Raises:</span>
<span class="sd">            HSIAttributesError: If an error occurs during the generation of the attributions.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; hyper_noise_tunnel = HyperNoiseTunnel(explainable_model)</span>
<span class="sd">            &gt;&gt;&gt; hsi = HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">            &gt;&gt;&gt; attributions = hyper_noise_tunnel.attribute(hsi)</span>
<span class="sd">            &gt;&gt;&gt; attributions = hyper_noise_tunnel.attribute([hsi, hsi])</span>
<span class="sd">            &gt;&gt;&gt; len(attributions)</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">change_orientation</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">original_orientation</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">hsi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">HSI</span><span class="p">)</span> <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All inputs must be HSI objects&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">hsi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">orientation</span> <span class="o">!=</span> <span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">):</span>
                <span class="n">change_orientation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">original_orientation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hsi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">orientation</span><span class="p">)</span>
                <span class="n">hsi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hsi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">change_orientation</span><span class="p">(</span><span class="s2">&quot;CHW&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">change_orientation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">baseline</span> <span class="o">=</span> <span class="p">[</span><span class="n">baseline</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">baseline</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of baseline must match the number of input images&quot;</span><span class="p">)</span>

        <span class="n">baseline</span> <span class="o">=</span> <span class="p">[</span><span class="n">validate_and_transform_baseline</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">hsi_image</span><span class="p">)</span> <span class="k">for</span> <span class="n">base</span><span class="p">,</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="n">hsi</span><span class="p">)]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">target</span> <span class="o">=</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="n">hnt_attributes</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">))</span> <span class="o">+</span> <span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)):</span>
            <span class="nb">input</span> <span class="o">=</span> <span class="n">hsi</span><span class="p">[</span><span class="n">batch</span><span class="p">]</span>
            <span class="n">targeted</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="n">batch</span><span class="p">]</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">baseline</span><span class="p">[</span><span class="n">batch</span><span class="p">]</span>
            <span class="n">perturbed_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perturb_input</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">perturbation_prob</span><span class="p">,</span> <span class="n">num_perturbed_bands</span><span class="p">)</span>

            <span class="n">hnt_attributes</span><span class="p">[:,</span> <span class="n">batch</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_forward_loop</span><span class="p">(</span>
                <span class="n">perturbed_input</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">targeted</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">steps_per_batch</span>
            <span class="p">)</span>

        <span class="n">hnt_attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_attributions</span><span class="p">(</span><span class="n">hnt_attributes</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">HSIAttributes</span><span class="p">(</span>
                    <span class="n">hsi</span><span class="o">=</span><span class="n">hsi_image</span><span class="p">,</span>
                    <span class="n">attributes</span><span class="o">=</span><span class="n">attribution</span> <span class="k">if</span> <span class="n">keep_gradient</span> <span class="k">else</span> <span class="n">attribution</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span>
                    <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">attribution</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">hnt_attributes</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error in generating HyperNoiseTunnel attributions: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">change_orientation</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">change_orientation</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">attributes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">hsi</span> <span class="o">=</span> <span class="n">attributes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">change_orientation</span><span class="p">(</span><span class="n">original_orientation</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">attributes</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.noise_tunnel.HyperNoiseTunnel.attribute" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">attribute</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">steps_per_batch</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">perturbation_prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">num_perturbed_bands</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;smoothgrad&#39;</span><span class="p">,</span> <span class="n">keep_gradient</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h4>


    <div class="doc doc-contents ">

        <p>Method for generating attributions using the Hyper Noise Tunnel method.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>hsi</code>
            </td>
            <td>
                  <code>list[<span title="meteors.HSI">HSI</span>] | <span title="meteors.HSI">HSI</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Input hyperspectral image(s) for which the attributions are to be computed.
If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.
The output will be a list of HSIAttributes objects.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>baseline</code>
            </td>
            <td>
                  <code>int | float | <span title="torch.Tensor">Tensor</span> | list[int | float | <span title="torch.Tensor">Tensor</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Baselines define reference value which
replaces each feature when occluded is computed and can be provided as:
    - integer or float representing a constant value used as the baseline for all input pixels.
    - tensor with the same shape as the input tensor, providing a baseline for each input pixel.
        if the input is a list of HSI objects, the baseline can be a tensor with the same shape as
        the input tensor for each HSI object or a list of tensors with the same length as the input list.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>target</code>
            </td>
            <td>
                  <code>list[int] | int | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>target class index for computing the attributions. If None,
methods assume that the output has only one class. If the output has multiple classes, the target index
must be provided. For multiple input images, a list of target indices can be provided, one for each
image or single target value will be used for all images. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>additional_forward_args</code>
            </td>
            <td>
                  <code><span title="typing.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the forward function requires additional arguments other than
the inputs for which attributions should not be computed, this argument can be provided.
It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple
containing multiple additional arguments including tensors or any arbitrary python types.
These arguments are provided to forward_func in order following the arguments in inputs.
Note that attributions are not computed with respect to these arguments. Default: None</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_samples</code>
            </td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of randomly generated examples per sample in the input batch.
Random examples are generated by adding gaussian random noise to each sample.
Default: 5 if nt_samples is not provided.</p>
              </div>
            </td>
            <td>
                  <code>5</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>steps_per_batch</code>
            </td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of the n_samples that will be processed together.
With the help of this parameter we can avoid out of memory situation and reduce the number of randomly
generated examples per sample in each batch. Default: None if steps_per_batch is not provided.
In this case all nt_samples will be processed together.</p>
              </div>
            </td>
            <td>
                  <code>1</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>perturbation_prob</code>
            </td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The probability that each band will be perturbed independently.
Defaults to 0.5.</p>
              </div>
            </td>
            <td>
                  <code>0.5</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>num_perturbed_bands</code>
            </td>
            <td>
                  <code>int | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of perturbed bands in the whole image.
The bands to be perturbed are selected randomly with no replacement.
If set to None, the bands are perturbed with probability <code>perturbation_prob</code> each. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>method</code>
            </td>
            <td>
                  <code><span title="typing.Literal">Literal</span>[&#39;smoothgrad&#39;, &#39;smoothgrad_sq&#39;, &#39;vargrad&#39;]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Smoothing type of the attributions.
smoothgrad, smoothgrad_sq or vargrad Default: smoothgrad if type is not provided.</p>
              </div>
            </td>
            <td>
                  <code>&#39;smoothgrad&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>keep_gradient</code>
            </td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Indicates whether to keep the gradient tensors in memory. By the default,
the gradient tensors are removed from the computation graph after the attributions are computed, due
to memory efficiency. If the gradient tensors are needed for further processing, this parameter should
be set to True. Default: False</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributes" href="#src.meteors.attr.attributes.HSIAttributes">HSIAttributes</a> | list[<a class="autorefs autorefs-internal" title="src.meteors.attr.attributes.HSIAttributes" href="#src.meteors.attr.attributes.HSIAttributes">HSIAttributes</a>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>HSIAttributes | list[HSIAttributes]: The computed attributions for the input hyperspectral image(s).
if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="meteors.exceptions.HSIAttributesError">HSIAttributesError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If an error occurs during the generation of the attributions.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">hyper_noise_tunnel</span> <span class="o">=</span> <span class="n">HyperNoiseTunnel</span><span class="p">(</span><span class="n">explainable_model</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hsi</span> <span class="o">=</span> <span class="n">HSI</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">)),</span> <span class="n">wavelengths</span><span class="o">=</span><span class="p">[</span><span class="mf">462.08</span><span class="p">,</span> <span class="mf">465.27</span><span class="p">,</span> <span class="mf">468.47</span><span class="p">,</span> <span class="mf">471.68</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attributions</span> <span class="o">=</span> <span class="n">hyper_noise_tunnel</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attributions</span> <span class="o">=</span> <span class="n">hyper_noise_tunnel</span><span class="o">.</span><span class="n">attribute</span><span class="p">([</span><span class="n">hsi</span><span class="p">,</span> <span class="n">hsi</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">attributions</span><span class="p">)</span>
<span class="go">2</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/noise_tunnel.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hsi</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSI</span><span class="p">]</span> <span class="o">|</span> <span class="n">HSI</span><span class="p">,</span>
    <span class="n">baseline</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">additional_forward_args</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">steps_per_batch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">perturbation_prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="n">num_perturbed_bands</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;smoothgrad&quot;</span><span class="p">,</span> <span class="s2">&quot;smoothgrad_sq&quot;</span><span class="p">,</span> <span class="s2">&quot;vargrad&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;smoothgrad&quot;</span><span class="p">,</span>
    <span class="n">keep_gradient</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HSIAttributes</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">HSIAttributes</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method for generating attributions using the Hyper Noise Tunnel method.</span>

<span class="sd">    Args:</span>
<span class="sd">        hsi (list[HSI] | HSI): Input hyperspectral image(s) for which the attributions are to be computed.</span>
<span class="sd">            If a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>
<span class="sd">            The output will be a list of HSIAttributes objects.</span>
<span class="sd">        baseline (int | float | torch.Tensor | list[int | float | torch.Tensor], optional): Baselines define reference value which</span>
<span class="sd">            replaces each feature when occluded is computed and can be provided as:</span>
<span class="sd">                - integer or float representing a constant value used as the baseline for all input pixels.</span>
<span class="sd">                - tensor with the same shape as the input tensor, providing a baseline for each input pixel.</span>
<span class="sd">                    if the input is a list of HSI objects, the baseline can be a tensor with the same shape as</span>
<span class="sd">                    the input tensor for each HSI object or a list of tensors with the same length as the input list.</span>
<span class="sd">        target (list[int] | int | None, optional): target class index for computing the attributions. If None,</span>
<span class="sd">            methods assume that the output has only one class. If the output has multiple classes, the target index</span>
<span class="sd">            must be provided. For multiple input images, a list of target indices can be provided, one for each</span>
<span class="sd">            image or single target value will be used for all images. Defaults to None.</span>
<span class="sd">        additional_forward_args (Any, optional): If the forward function requires additional arguments other than</span>
<span class="sd">            the inputs for which attributions should not be computed, this argument can be provided.</span>
<span class="sd">            It must be either a single additional argument of a Tensor or arbitrary (non-tuple) type or a tuple</span>
<span class="sd">            containing multiple additional arguments including tensors or any arbitrary python types.</span>
<span class="sd">            These arguments are provided to forward_func in order following the arguments in inputs.</span>
<span class="sd">            Note that attributions are not computed with respect to these arguments. Default: None</span>
<span class="sd">        n_samples (int, optional):The number of randomly generated examples per sample in the input batch.</span>
<span class="sd">            Random examples are generated by adding gaussian random noise to each sample.</span>
<span class="sd">            Default: 5 if nt_samples is not provided.</span>
<span class="sd">        steps_per_batch (int, optional): The number of the n_samples that will be processed together.</span>
<span class="sd">            With the help of this parameter we can avoid out of memory situation and reduce the number of randomly</span>
<span class="sd">            generated examples per sample in each batch. Default: None if steps_per_batch is not provided.</span>
<span class="sd">            In this case all nt_samples will be processed together.</span>
<span class="sd">        perturbation_prob (float, optional): The probability that each band will be perturbed independently.</span>
<span class="sd">            Defaults to 0.5.</span>
<span class="sd">        num_perturbed_bands (int | None, optional): The number of perturbed bands in the whole image.</span>
<span class="sd">            The bands to be perturbed are selected randomly with no replacement.</span>
<span class="sd">            If set to None, the bands are perturbed with probability `perturbation_prob` each. Defaults to None.</span>
<span class="sd">        method (Literal[&quot;smoothgrad&quot;, &quot;smoothgrad_sq&quot;, &quot;vargrad&quot;], optional): Smoothing type of the attributions.</span>
<span class="sd">            smoothgrad, smoothgrad_sq or vargrad Default: smoothgrad if type is not provided.</span>
<span class="sd">        keep_gradient (bool, optional): Indicates whether to keep the gradient tensors in memory. By the default,</span>
<span class="sd">            the gradient tensors are removed from the computation graph after the attributions are computed, due</span>
<span class="sd">            to memory efficiency. If the gradient tensors are needed for further processing, this parameter should</span>
<span class="sd">            be set to True. Default: False</span>

<span class="sd">    Returns:</span>
<span class="sd">        HSIAttributes | list[HSIAttributes]: The computed attributions for the input hyperspectral image(s).</span>
<span class="sd">            if a list of HSI objects is provided, the attributions are computed for each HSI object in the list.</span>

<span class="sd">    Raises:</span>
<span class="sd">        HSIAttributesError: If an error occurs during the generation of the attributions.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; hyper_noise_tunnel = HyperNoiseTunnel(explainable_model)</span>
<span class="sd">        &gt;&gt;&gt; hsi = HSI(image=torch.ones((4, 240, 240)), wavelengths=[462.08, 465.27, 468.47, 471.68])</span>
<span class="sd">        &gt;&gt;&gt; attributions = hyper_noise_tunnel.attribute(hsi)</span>
<span class="sd">        &gt;&gt;&gt; attributions = hyper_noise_tunnel.attribute([hsi, hsi])</span>
<span class="sd">        &gt;&gt;&gt; len(attributions)</span>
<span class="sd">        2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">change_orientation</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">original_orientation</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">hsi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hsi</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">HSI</span><span class="p">)</span> <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">hsi</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All inputs must be HSI objects&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">hsi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">orientation</span> <span class="o">!=</span> <span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">):</span>
            <span class="n">change_orientation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">original_orientation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hsi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">orientation</span><span class="p">)</span>
            <span class="n">hsi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hsi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">change_orientation</span><span class="p">(</span><span class="s2">&quot;CHW&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">change_orientation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">baseline</span> <span class="o">=</span> <span class="p">[</span><span class="n">baseline</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">baseline</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of baseline must match the number of input images&quot;</span><span class="p">)</span>

    <span class="n">baseline</span> <span class="o">=</span> <span class="p">[</span><span class="n">validate_and_transform_baseline</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">hsi_image</span><span class="p">)</span> <span class="k">for</span> <span class="n">base</span><span class="p">,</span> <span class="n">hsi_image</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="n">hsi</span><span class="p">)]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">target</span> <span class="o">=</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

    <span class="n">hnt_attributes</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">))</span> <span class="o">+</span> <span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">hsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hsi</span><span class="p">)):</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="n">hsi</span><span class="p">[</span><span class="n">batch</span><span class="p">]</span>
        <span class="n">targeted</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="n">batch</span><span class="p">]</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">baseline</span><span class="p">[</span><span class="n">batch</span><span class="p">]</span>
        <span class="n">perturbed_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perturb_input</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">perturbation_prob</span><span class="p">,</span> <span class="n">num_perturbed_bands</span><span class="p">)</span>

        <span class="n">hnt_attributes</span><span class="p">[:,</span> <span class="n">batch</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_forward_loop</span><span class="p">(</span>
            <span class="n">perturbed_input</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">targeted</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">steps_per_batch</span>
        <span class="p">)</span>

    <span class="n">hnt_attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_attributions</span><span class="p">(</span><span class="n">hnt_attributes</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">HSIAttributes</span><span class="p">(</span>
                <span class="n">hsi</span><span class="o">=</span><span class="n">hsi_image</span><span class="p">,</span>
                <span class="n">attributes</span><span class="o">=</span><span class="n">attribution</span> <span class="k">if</span> <span class="n">keep_gradient</span> <span class="k">else</span> <span class="n">attribution</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span>
                <span class="n">attribution_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">(),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">hsi_image</span><span class="p">,</span> <span class="n">attribution</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hsi</span><span class="p">,</span> <span class="n">hnt_attributes</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">HSIAttributesError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error in generating HyperNoiseTunnel attributions: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">change_orientation</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">change_orientation</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">attributes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">hsi</span> <span class="o">=</span> <span class="n">attributes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">hsi</span><span class="o">.</span><span class="n">change_orientation</span><span class="p">(</span><span class="n">original_orientation</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">attributes</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="src.meteors.attr.noise_tunnel.HyperNoiseTunnel.perturb_input" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">perturb_input</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">perturbation_prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">num_perturbed_bands</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>The perturbation function used in the hyper noise tunnel. It randomly selects a subset of the input bands
that will be masked out and replaced with the baseline. The parameters <code>num_perturbed_bands</code> and
<code>perturbation_prob</code> control the number of bands that will be perturbed (masked). If <code>num_perturbed_bands</code> is
set, it will be used as the number of bands to perturb, which will be randomly selected. Otherwise, the number
of bands will be drawn from a binomial distribution with <code>perturbation_prob</code> as the probability of success.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>input</code>
            </td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An input tensor to be perturbed. It should have the shape (C, H, W).</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>baseline</code>
            </td>
            <td>
                  <code><span title="torch.Tensor">Tensor</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A tensor that will be used to replace the perturbed bands.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_samples</code>
            </td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A number of samples to be drawn - number of perturbed inputs to be generated.</p>
              </div>
            </td>
            <td>
                  <code>1</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>perturbation_prob</code>
            </td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A probability that each band will be perturbed intependently.
Defaults to 0.5.</p>
              </div>
            </td>
            <td>
                  <code>0.5</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>num_perturbed_bands</code>
            </td>
            <td>
                  <code>int | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A number of perturbed bands in the whole image.
If set to None, the bands are perturbed with probability <code>perturbation_prob</code> each. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="torch.Tensor">Tensor</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>torch.Tensor: A perturbed tensor, which contains <code>n_samples</code> perturbed inputs.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/meteors/attr/noise_tunnel.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">perturb_input</span><span class="p">(</span>
    <span class="nb">input</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">baseline</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">perturbation_prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="n">num_perturbed_bands</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The perturbation function used in the hyper noise tunnel. It randomly selects a subset of the input bands</span>
<span class="sd">    that will be masked out and replaced with the baseline. The parameters `num_perturbed_bands` and</span>
<span class="sd">    `perturbation_prob` control the number of bands that will be perturbed (masked). If `num_perturbed_bands` is</span>
<span class="sd">    set, it will be used as the number of bands to perturb, which will be randomly selected. Otherwise, the number</span>
<span class="sd">    of bands will be drawn from a binomial distribution with `perturbation_prob` as the probability of success.</span>

<span class="sd">    Args:</span>
<span class="sd">        input (torch.Tensor): An input tensor to be perturbed. It should have the shape (C, H, W).</span>
<span class="sd">        baseline (torch.Tensor | None, optional): A tensor that will be used to replace the perturbed bands.</span>
<span class="sd">        n_samples (int): A number of samples to be drawn - number of perturbed inputs to be generated.</span>
<span class="sd">        perturbation_prob (float, optional): A probability that each band will be perturbed intependently.</span>
<span class="sd">            Defaults to 0.5.</span>
<span class="sd">        num_perturbed_bands (int | None, optional): A number of perturbed bands in the whole image.</span>
<span class="sd">            If set to None, the bands are perturbed with probability `perturbation_prob` each. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        torch.Tensor: A perturbed tensor, which contains `n_samples` perturbed inputs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># validate the baseline against the input</span>
    <span class="k">if</span> <span class="n">baseline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Baseline must be provided for the HyperNoiseTunnel method&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">baseline</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ShapeMismatchError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Baseline shape </span><span class="si">{</span><span class="n">baseline</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> does not match input shape </span><span class="si">{</span><span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_samples</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of perturbated samples to be generated must be greater than 0&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">perturbation_prob</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">perturbation_prob</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Perturbation probability must be in the range [0, 1]&quot;</span><span class="p">)</span>

    <span class="c1"># the perturbation</span>
    <span class="n">perturbed_input</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># repeat the perturbed_input on the first dimension n_samples times</span>
    <span class="n">perturbed_input</span> <span class="o">=</span> <span class="n">perturbed_input</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">n_samples_x_channels_shape</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">n_samples</span><span class="p">,</span>
        <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">)</span>  <span class="c1"># shape of the tensor containing the perturbed channels for each sample</span>

    <span class="n">channels_to_be_perturbed</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_samples_x_channels_shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">bool</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">num_perturbed_bands</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">channel_perturbation_probabilities</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_samples_x_channels_shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">*</span> <span class="n">perturbation_prob</span>
        <span class="p">)</span>
        <span class="n">channels_to_be_perturbed</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">bernoulli</span><span class="p">(</span><span class="n">channel_perturbation_probabilities</span><span class="p">)</span><span class="o">.</span><span class="n">bool</span><span class="p">()</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num_perturbed_bands</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">num_perturbed_bands</span> <span class="o">&gt;</span> <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot perturb </span><span class="si">{</span><span class="n">num_perturbed_bands</span><span class="si">}</span><span class="s2"> bands in the input with </span><span class="si">{</span><span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> channels. The number of perturbed bands must be in the range [0, </span><span class="si">{</span><span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">]&quot;</span>
            <span class="p">)</span>

        <span class="n">channels_to_be_perturbed</span> <span class="o">=</span> <span class="n">torch_random_choice</span><span class="p">(</span>
            <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num_perturbed_bands</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">device</span>
        <span class="p">)</span>

    <span class="c1"># now having chosen the perturbed channels, we can replace them with the baseline</span>
    <span class="n">reshaped_baseline</span> <span class="o">=</span> <span class="n">baseline</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">perturbed_input</span><span class="p">[</span><span class="n">channels_to_be_perturbed</span><span class="p">]</span> <span class="o">=</span> <span class="n">reshaped_baseline</span><span class="p">[</span><span class="n">channels_to_be_perturbed</span><span class="p">]</span>

    <span class="n">perturbed_input</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">perturbed_input</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.tracking", "navigation.path", "navigation.top"], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"default": "latest", "provider": "mike"}}</script>
    
    
      <script src="../assets/javascripts/bundle.83f73b43.min.js"></script>
      
    
  </body>
</html>